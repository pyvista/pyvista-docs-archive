
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Filters &#8212; PyVista 0.31.dev0 documentation</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cameras" href="camera.html" />
    <link rel="prev" title="Composite Datasets" href="composite.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/pyvista_logo_sm.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting-started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../user-guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../examples/index.html">
  Examples
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../extras/index.html">
  Extras
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://slack.pyvista.org" rel="noopener" target="_blank" title="Slack Community">
            <span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack Community</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista-support" rel="noopener" target="_blank" title="Support">
            <span><i class="fa fa-comment fa-fw"></i></span>
            <label class="sr-only">Support</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/blob/master/CONTRIBUTING.md" rel="noopener" target="_blank" title="Contributing">
            <span><i class="fa fa-gavel fa-fw"></i></span>
            <label class="sr-only">Contributing</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://doi.org/10.21105/joss.01450" rel="noopener" target="_blank" title="The Paper">
            <span><i class="fa fa-file-text fa-fw"></i></span>
            <label class="sr-only">The Paper</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p class="caption">
 <span class="caption-text">
  API Reference
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="index.html">
   Core API
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="objects.html">
     Objects
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="dataset.html">
     Datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="points.html">
     Point Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="point-grids.html">
     Point-Based Grids
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="grids.html">
     Gridded Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="composite.html">
     Composite Datasets
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Filters
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="camera.html">
     Cameras
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="lights.html">
     Lights
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="helpers.html">
     Helpers
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../plotting/index.html">
   Plotting
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../plotting/plotting.html">
     Plotting
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../plotting/widgets.html">
     Widget API
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../plotting/qt_plotting.html">
     Pyvista and PyQt
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../utilities/index.html">
   Utilities
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../utilities/geometric.html">
     Geometric Objects
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../utilities/parametric.html">
     Parametric Objects
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../utilities/utilities.html">
     General Utilities
    </a>
   </li>
  </ul>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dataset-filters">
   Dataset Filters
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#polydata-filters">
   PolyData Filters
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unstructuredgrid-filters">
   UnstructuredGrid Filters
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#uniformgrid-filters">
   UniformGrid Filters
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#composite-filters">
   Composite Filters
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="module-pyvista.core.filters">
<span id="filters"></span><span id="filters-ref"></span><h1>Filters<a class="headerlink" href="#module-pyvista.core.filters" title="Permalink to this headline">¶</a></h1>
<p>These classes hold methods to apply general filters to any data type.</p>
<p>By inheriting these classes into the wrapped VTK data structures, a user
can easily apply common filters in an intuitive manner.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Threshold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slc</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">slice</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Clip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clp</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Contour</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iso</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">contour</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="dataset-filters">
<h2>Dataset Filters<a class="headerlink" href="#dataset-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.DataSetFilters</span></code></a> is inherited by <a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.DataSet</span></code></a> making
all the following filters available as callable methods directly from any
PyVista dataset.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_centers</span></code>([vertex])</p></td>
<td><p>Generate points at the center of the cells in this dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_data_to_point_data</span></code>([pass_cell_data])</p></td>
<td><p>Transform cell data into point data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([normal, origin, invert, value, …])</p></td>
<td><p>Clip a dataset by a plane by specifying the origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_box</span></code>([bounds, invert, factor])</p></td>
<td><p>Clip a dataset by a bounding box defined by the bounds.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_scalar</span></code>([scalars, invert, value, inplace])</p></td>
<td><p>Clip a dataset by a scalar.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_surface</span></code>(surface[, invert, value, …])</p></td>
<td><p>Clip any mesh type using a <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> surface mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cell_quality</span></code>([quality_measure, …])</p></td>
<td><p>Compute a function of (geometric) quality for each cell of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cell_sizes</span></code>([length, area, volume, …])</p></td>
<td><p>Compute sizes for 1D (length), 2D (area) and 3D (volume) cells.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_derivative</span></code>([scalars, gradient, …])</p></td>
<td><p>Compute derivative-based quantities of point/cell scalar field.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_implicit_distance</span></code>(surface[, inplace])</p></td>
<td><p>Compute the implicit distance from the points to a surface.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">connectivity</span></code>([largest])</p></td>
<td><p>Find and label connected bodies/volumes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contour</span></code>([isosurfaces, scalars, …])</p></td>
<td><p>Contour an input dataset by an array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctp</span></code>([pass_cell_data])</p></td>
<td><p>Transform cell data into point data.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate_boundary</span></code>([target_reduction])</p></td>
<td><p>Return a decimated version of a triangulation of the boundary.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delaunay_3d</span></code>([alpha, tol, offset, progress_bar])</p></td>
<td><p>Construct a 3D Delaunay triangulation of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elevation</span></code>([low_point, high_point, …])</p></td>
<td><p>Generate scalar values on a dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_all_edges</span></code>([progress_bar])</p></td>
<td><p>Extract all the internal/external edges of the dataset as PolyData.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_cells</span></code>(ind)</p></td>
<td><p>Return a subset of the grid.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_feature_edges</span></code>([feature_angle, …])</p></td>
<td><p>Extract edges from the surface of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_geometry</span></code>()</p></td>
<td><p>Extract the outer surface of a volume or structured grid dataset as PolyData.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_largest</span></code>([inplace])</p></td>
<td><p>Extract largest connected set in mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_points</span></code>(ind[, adjacent_cells, …])</p></td>
<td><p>Return a subset of the grid (with cells) that contains any of the given point indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_surface</span></code>([pass_pointid, pass_cellid, …])</p></td>
<td><p>Extract surface mesh of the grid.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">glyph</span></code>([orient, scale, factor, geom, …])</p></td>
<td><p>Copy a geometric representation (called a glyph) to the input dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(target[, sharpness, radius, …])</p></td>
<td><p>Interpolate values onto this mesh from a given dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code>([grid, merge_points, inplace, …])</p></td>
<td><p>Join one or many other grids to this grid.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([generate_faces])</p></td>
<td><p>Produce an outline of the full extent for the input dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline_corners</span></code>([factor])</p></td>
<td><p>Produce an outline of the corners for the input dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_over_circular_arc</span></code>(pointa, pointb, center)</p></td>
<td><p>Sample a dataset along a circular arc and plot it.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_over_circular_arc_normal</span></code>(center[, …])</p></td>
<td><p>Sample a dataset along a resolution circular arc defined by a normal and polar vector and plot it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_over_line</span></code>(pointa, pointb[, resolution, …])</p></td>
<td><p>Sample a dataset along a high resolution line and plot.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_data_to_cell_data</span></code>([pass_point_data])</p></td>
<td><p>Transform point data into cell data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">probe</span></code>(points[, tolerance, pass_cell_arrays, …])</p></td>
<td><p>Sample data values at specified point locations.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptc</span></code>([pass_point_data])</p></td>
<td><p>Transform point data into cell data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reflect</span></code>(normal[, point, inplace, …])</p></td>
<td><p>Reflect a dataset across a plane.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(target[, tolerance, …])</p></td>
<td><p>Resample array data from a passed mesh onto this mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_over_circular_arc</span></code>(pointa, pointb, center)</p></td>
<td><p>Sample a dataset over a circular arc.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_over_circular_arc_normal</span></code>(center[, …])</p></td>
<td><p>Sample a dataset over a circular arc defined by a normal and polar vector and plot it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_over_line</span></code>(pointa, pointb[, …])</p></td>
<td><p>Sample a dataset onto a line.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_enclosed_points</span></code>(surface[, tolerance, …])</p></td>
<td><p>Mark points as to whether they are inside a closed surface.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink</span></code>([shrink_factor, progress_bar])</p></td>
<td><p>Shrink the individual faces of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice</span></code>([normal, origin, generate_triangles, …])</p></td>
<td><p>Slice a dataset by a plane at the specified origin and normal vector orientation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_axis</span></code>([n, axis, tolerance, …])</p></td>
<td><p>Create many slices of the input dataset along a specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_line</span></code>(line[, generate_triangles, …])</p></td>
<td><p>Slice a dataset using a polyline/spline as the path.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_orthogonal</span></code>([x, y, z, …])</p></td>
<td><p>Create three orthogonal slices through the dataset on the three cartesian planes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_bodies</span></code>([label])</p></td>
<td><p>Find, label, and split connected bodies/volumes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">streamlines</span></code>([vectors, source_center, …])</p></td>
<td><p>Integrate a vector field to generate streamlines.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">streamlines_from_source</span></code>(source[, vectors, …])</p></td>
<td><p>Generate streamlines of vectors from the points of a source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">surface_indices</span></code>()</p></td>
<td><p>Return the surface indices of a grid.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">texture_map_to_plane</span></code>([origin, point_u, …])</p></td>
<td><p>Texture map this dataset to a user defined plane.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">texture_map_to_sphere</span></code>([center, …])</p></td>
<td><p>Texture map this dataset to a user defined sphere.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold</span></code>([value, scalars, invert, …])</p></td>
<td><p>Apply a <code class="docutils literal notranslate"><span class="pre">vtkThreshold</span></code> filter to the input dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_percent</span></code>([percent, scalars, …])</p></td>
<td><p>Threshold the dataset by a percentage of its range on the active scalars array or as specified.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code>(trans[, …])</p></td>
<td><p>Transform this mesh with a 4x4 transform.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangulate</span></code>([inplace])</p></td>
<td><p>Return an all triangle mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_by_scalar</span></code>([scalars, factor, normal, …])</p></td>
<td><p>Warp the dataset’s points by a point data scalars array’s values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_by_vector</span></code>([vectors, factor, inplace])</p></td>
<td><p>Warp the dataset’s points by a point data vectors array’s values.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pyvista.DataSetFilters">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyvista.</span></span><span class="sig-name descname"><span class="pre">DataSetFilters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of common filters that can be applied to any vtkDataSet.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.cell_centers">
<span class="sig-name descname"><span class="pre">cell_centers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.cell_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate points at the center of the cells in this dataset.</p>
<p>These points can be used for placing glyphs / vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vertex</strong> (<em>bool</em>) – Enable/disable the generation of vertex cells.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.cell_data_to_point_data">
<span class="sig-name descname"><span class="pre">cell_data_to_point_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_cell_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.cell_data_to_point_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform cell data into point data.</p>
<p>Point data are specified per node and cell data specified within cells.
Optionally, the input point data can be passed through to the output.</p>
<p>The method of transformation is based on averaging the data values of
all cells using a particular point. Optionally, the input cell data can
be passed through to the output as well.</p>
<p>See also: <a class="reference internal" href="#pyvista.DataSetFilters.point_data_to_cell_data" title="pyvista.DataSetFilters.point_data_to_cell_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.point_data_to_cell_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_cell_data</strong> (<em>bool</em>) – If enabled, pass the input cell data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.clip">
<span class="sig-name descname"><span class="pre">clip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_clipped</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a plane by specifying the origin and normal.</p>
<p>If no parameters are given the clip will occur in the center of that dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The center <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> coordinate of the plane on which the clip
occurs. The default is the center of the dataset.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag on whether to flip/invert the clip.</p></li>
<li><p><strong>value</strong> (<em>float</em><em>, </em><em>optional</em>) – Set the clipping value along the normal direction.
The default value is 0.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
<li><p><strong>return_clipped</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return both unclipped and clipped parts of the dataset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Clipped mesh when <code class="docutils literal notranslate"><span class="pre">return_clipped=False</span></code>,
otherwise a tuple containing the unclipped and clipped datasets.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a> or tuple(<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a>)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Clip a cube along the +X direction.  <code class="docutils literal notranslate"><span class="pre">triangulate</span></code> is used as
the cube is initially composed of quadrilateral faces and
subdivide only works on triangles.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">clip</span><span class="p">()</span>
</pre></div>
</div>
<p>Clip a cube in the +Z direction.  This leaves half a cube
below the XY plane.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.clip_box">
<span class="sig-name descname"><span class="pre">clip_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.35</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.clip_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a bounding box defined by the bounds.</p>
<p>If no bounds are given, a corner of the dataset bounds will be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 6 sequence of floats: (xmin, xmax, ymin, ymax, zmin, zmax).
Length 3 sequence of floats: distances from the min coordinate of
of the input mesh. Single float value: uniform distance from the
min coordinate. Length 12 sequence of length 3 sequence of floats:
a plane collection (normal, center, …).
<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a>: if a poly mesh is passed that represents
a box with 6 faces that all form a standard box, then planes will
be extracted from the box to define the clipping region.</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – If bounds are not given this is the factor along each axis to
extract the default box.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Clip a corner of a cube.  The bounds of a cube are normally
<code class="docutils literal notranslate"><span class="pre">[-0.5,</span> <span class="pre">0.5,</span> <span class="pre">-0.5,</span> <span class="pre">0.5,</span> <span class="pre">-0.5,</span> <span class="pre">0.5]</span></code>, and this removes 1/8 of
the cube’s surface.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">clip_box</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.clip_scalar">
<span class="sig-name descname"><span class="pre">clip_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.clip_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to clip on.  Defaults to currently active scalars.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag on whether to flip/invert the clip.  When <code class="docutils literal notranslate"><span class="pre">True</span></code>,
only the mesh below <code class="docutils literal notranslate"><span class="pre">value</span></code> will be kept.  When
<code class="docutils literal notranslate"><span class="pre">False</span></code>, only values above <code class="docutils literal notranslate"><span class="pre">value</span></code> will be kept.</p></li>
<li><p><strong>value</strong> (<em>float</em><em>, </em><em>optional</em>) – Set the clipping value.  The default value is 0.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Update mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pdata</strong> – Clipped dataset.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Remove the part of the mesh with “sample_point_scalars” above 100.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_hexbeam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">clip_scalar</span><span class="p">(</span><span class="n">scalars</span><span class="o">=</span><span class="s2">&quot;sample_point_scalars&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Remove the part of the mesh with “sample_point_scalars” below
100.  Since these scalars are already active, there’s no need
to specify <code class="docutils literal notranslate"><span class="pre">scalars=</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_hexbeam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">clip_scalar</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.clip_surface">
<span class="sig-name descname"><span class="pre">clip_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.clip_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip any mesh type using a <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> surface mesh.</p>
<p>This will return a <a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UnstructuredGrid</span></code></a> of the clipped
mesh. Geometry of the input dataset will be preserved where possible -
geometries near the clip intersection will be triangulated/tessellated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The PolyData surface mesh to use as a clipping function. If this
mesh is not PolyData, the external surface will be extracted.</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>value</strong> (<em>float:</em>) – Set the clipping value of the implicit function (if clipping with
implicit function) or scalar value (if clipping with scalars).
The default value is 0.0.</p></li>
<li><p><strong>compute_distance</strong> (<em>bool</em><em>, </em><em>optional</em>) – Compute the implicit distance from the mesh onto the input dataset.
A new array called <code class="docutils literal notranslate"><span class="pre">'implicit_distance'</span></code> will be added to the
output clipped mesh.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.compute_cell_quality">
<span class="sig-name descname"><span class="pre">compute_cell_quality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quality_measure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled_jacobian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.compute_cell_quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a function of (geometric) quality for each cell of a mesh.</p>
<p>The per-cell quality is added to the mesh’s cell data, in an array
named “CellQuality”. Cell types not supported by this filter or
undefined quality of supported cell types will have an entry of -1.</p>
<p>Defaults to computing the scaled jacobian.</p>
<p>Options for cell quality measure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'area'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'aspect_beta'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'aspect_frobenius'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'aspect_gamma'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'aspect_ratio'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'collapse_ratio'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'condition'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'diagonal'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dimension'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'distortion'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'jacobian'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'max_angle'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'max_aspect_frobenius'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'max_edge_ratio'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'med_aspect_frobenius'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'min_angle'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'oddy'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'radius_ratio'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'relative_size_squared'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'scaled_jacobian'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'shape'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'shape_and_size'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'shear'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'shear_and_size'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'skew'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'stretch'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'taper'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'volume'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'warpage'</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quality_measure</strong> (<em>str</em>) – The cell quality measure to use</p></li>
<li><p><strong>null_value</strong> (<em>float</em>) – Float value for undefined quality. Undefined quality are qualities
that could be addressed by this filter but is not well defined for
the particular geometry of cell in question, e.g. a volume query
for a triangle. Undefined quality will always be undefined.
The default value is -1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.compute_cell_sizes">
<span class="sig-name descname"><span class="pre">compute_cell_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.compute_cell_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sizes for 1D (length), 2D (area) and 3D (volume) cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>bool</em>) – Specify whether or not to compute the length of 1D cells.</p></li>
<li><p><strong>area</strong> (<em>bool</em>) – Specify whether or not to compute the area of 2D cells.</p></li>
<li><p><strong>volume</strong> (<em>bool</em>) – Specify whether or not to compute the volume of 3D cells.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.compute_derivative">
<span class="sig-name descname"><span class="pre">compute_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">divergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vorticity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qcriterion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faster</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'point'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.compute_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute derivative-based quantities of point/cell scalar field.</p>
<p>Utilize <code class="docutils literal notranslate"><span class="pre">vtkGradientFilter</span></code> to compute derivative-based quantities,
such as gradient, divergence, vorticity, and Q-criterion, of the
selected point or cell scalar field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – String name of the scalars array to use when computing the
derivative quantities.</p></li>
<li><p><strong>gradient</strong> (<em>bool</em><em>, </em><em>str</em><em>, </em><em>optional</em>) – Calculate gradient. If a string is passed, the string will be used
for the resulting array name. Otherwise, array name will be
‘gradient’. Default: True</p></li>
<li><p><strong>divergence</strong> (<em>bool</em><em>, </em><em>str</em><em>, </em><em>optional</em>) – Calculate divergence. If a string is passed, the string will be
used for the resulting array name. Otherwise, array name will be
‘divergence’. Default: None</p></li>
<li><p><strong>vorticity</strong> (<em>bool</em><em>, </em><em>str</em><em>, </em><em>optional</em>) – Calculate vorticity. If a string is passed, the string will be used
for the resulting array name. Otherwise, array name will be
‘vorticity’. Default: None</p></li>
<li><p><strong>qcriterion</strong> (<em>bool</em><em>, </em><em>str</em><em>, </em><em>optional</em>) – Calculate qcriterion. If a string is passed, the string will be
used for the resulting array name. Otherwise, array name will be
‘qcriterion’. Default: None</p></li>
<li><p><strong>faster</strong> (<em>bool</em><em>, </em><em>optional</em>) – Use faster algorithm for computing derivative quantities. Result is
less accurate and performs fewer derivative calculations,
increasing computation speed. The error will feature smoothing of
the output and possibly errors at boundaries. Option has no effect
if DataSet is not UnstructuredGrid. Default: False</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – Data type preference. Either ‘point’ or ‘cell’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.compute_implicit_distance">
<span class="sig-name descname"><span class="pre">compute_implicit_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.compute_implicit_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the implicit distance from the points to a surface.</p>
<p>This filter will compute the implicit distance from all of the nodes of
this mesh to a given surface. This distance will be added as a point
array called <code class="docutils literal notranslate"><span class="pre">'implicit_distance'</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The surface used to compute the distance</p></li>
<li><p><strong>inplace</strong> (<em>bool</em>) – If True, a new scalar array will be added to the <code class="docutils literal notranslate"><span class="pre">point_arrays</span></code>
of this mesh. Otherwise a copy of this mesh is returned with that
scalar field.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the distance between all the points on a sphere and a
plane.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plane</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plane</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">compute_implicit_distance</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">[</span><span class="s1">&#39;implicit_distance&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
<span class="go">&lt;class &#39;numpy.ndarray&#39;&gt;</span>
</pre></div>
</div>
<p>Plot these distances as a heatmap</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">sphere</span><span class="p">,</span> <span class="n">scalars</span><span class="o">=</span><span class="s1">&#39;implicit_distance&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;wireframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.connectivity">
<span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">largest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and label connected bodies/volumes.</p>
<p>This adds an ID array to the point and cell data to distinguish separate
connected bodies. This applies a <code class="docutils literal notranslate"><span class="pre">vtkConnectivityFilter</span></code> filter which
extracts cells that share common points and/or meet other connectivity
criterion.
(Cells that share vertices and meet other connectivity criterion such
as scalar range are known as a region.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>largest</strong> (<em>bool</em>) – Extract the largest connected part of the mesh.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.contour">
<span class="sig-name descname"><span class="pre">contour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isosurfaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_gradients</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'contour'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Contour an input dataset by an array.</p>
<p><code class="docutils literal notranslate"><span class="pre">isosurfaces</span></code> can be an integer specifying the number of isosurfaces in
the data range or a sequence of values for explicitly setting the isosurfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>isosurfaces</strong> (<em>int</em><em> or </em><em>sequence</em>) – Number of isosurfaces to compute across valid data range or a
sequence of float values to explicitly use as the isosurfaces.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to threshold on. Defaults to currently active scalars.</p></li>
<li><p><strong>compute_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – </p></li>
<li><p><strong>compute_gradients</strong> (<em>bool</em><em>, </em><em>optional</em>) – Desc</p></li>
<li><p><strong>compute_scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserves the scalar values that are being contoured</p></li>
<li><p><strong>rng</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – If an integer number of isosurfaces is specified, this is the range
over which to generate contours. Default is the scalars arrays’ full
data range.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the preferred array type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Specify to choose which vtk filter is used to create the contour.
Must be one of <code class="docutils literal notranslate"><span class="pre">'contour'</span></code>, <code class="docutils literal notranslate"><span class="pre">'marching_cubes'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'flying_edges'</span></code>. Defaults to <code class="docutils literal notranslate"><span class="pre">'contour'</span></code>.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.ctp">
<span class="sig-name descname"><span class="pre">ctp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_cell_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.ctp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform cell data into point data.</p>
<p>Point data are specified per node and cell data specified within cells.
Optionally, the input point data can be passed through to the output.</p>
<p>An alias/shortcut for <code class="docutils literal notranslate"><span class="pre">cell_data_to_point_data</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.decimate_boundary">
<span class="sig-name descname"><span class="pre">decimate_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_reduction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.decimate_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a decimated version of a triangulation of the boundary.</p>
<p>Only the outer surface of the input dataset will be considered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>target_reduction</strong> (<em>float</em>) – Fraction of the original mesh to remove. Default is <code class="docutils literal notranslate"><span class="pre">0.5</span></code>
TargetReduction is set to <code class="docutils literal notranslate"><span class="pre">0.9</span></code>, this filter will try to reduce
the data set to 10% of its original size and will remove 90%
of the input triangles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.delaunay_3d">
<span class="sig-name descname"><span class="pre">delaunay_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.delaunay_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a 3D Delaunay triangulation of the mesh.</p>
<p>This helps smooth out a rugged mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – Distance value to control output of this filter. For a non-zero
alpha value, only verts, edges, faces, or tetra contained within
the circumsphere (of radius alpha) will be output. Otherwise, only
tetrahedra will be output.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – tolerance to control discarding of closely spaced points.
This tolerance is specified as a fraction of the diagonal length
of the bounding box of the points.</p></li>
<li><p><strong>offset</strong> (<em>float</em><em>, </em><em>optional</em>) – multiplier to control the size of the initial, bounding Delaunay
triangulation.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.elevation">
<span class="sig-name descname"><span class="pre">elevation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_active</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.elevation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate scalar values on a dataset.</p>
<p>The scalar values lie within a user specified range, and are
generated by computing a projection of each dataset point onto
a line.  The line can be oriented arbitrarily.  A typical
example is to generate scalars based on elevation or height
above a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The low point of the projection line in 3D space. Default is bottom
center of the dataset. Otherwise pass a length 3 <code class="docutils literal notranslate"><span class="pre">tuple(float)</span></code>.</p></li>
<li><p><strong>high_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The high point of the projection line in 3D space. Default is top
center of the dataset. Otherwise pass a length 3 <code class="docutils literal notranslate"><span class="pre">tuple(float)</span></code>.</p></li>
<li><p><strong>scalar_range</strong> (<em>str</em><em> or </em><em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The scalar range to project to the low and high points on the line
that will be mapped to the dataset. If None given, the values will
be computed from the elevation (Z component) range between the
high and low points. Min and max of a range can be given as a length
2 tuple(float). If <code class="docutils literal notranslate"><span class="pre">str</span></code> name of scalara array present in the
dataset given, the valid range of that array will be used.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When an array name is specified for <code class="docutils literal notranslate"><span class="pre">scalar_range</span></code>, this is the
preferred array type to search for in the dataset.
Must be either ‘point’ or ‘cell’.</p></li>
<li><p><strong>set_active</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean flag on whether or not to set the new <cite>Elevation</cite> scalar
as the active scalars array on the output dataset.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will create a scalars array named <cite>Elevation</cite> on the point data of
the input dataset and overasdf write an array named <cite>Elevation</cite> if present.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_all_edges">
<span class="sig-name descname"><span class="pre">extract_all_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_all_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all the internal/external edges of the dataset as PolyData.</p>
<p>This produces a full wireframe representation of the input dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_cells">
<span class="sig-name descname"><span class="pre">extract_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> (<em>np.ndarray</em>) – Numpy array of cell indices to be extracted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>subgrid</strong> – Subselected grid</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_feature_edges">
<span class="sig-name descname"><span class="pre">extract_feature_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feature_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_manifold_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">manifold_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_feature_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract edges from the surface of the mesh.</p>
<p>If the given mesh is not PolyData, the external surface of the given
mesh is extracted and used.
From vtk documentation, the edges are one of the following</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>boundary (used by one polygon) or a line cell</p></li>
<li><p>non-manifold (used by three or more polygons)</p></li>
<li><p>feature edges (edges used by two triangles and whose
dihedral angle &gt; feature_angle)</p></li>
<li><p>manifold edges (edges used by exactly two polygons).</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Defaults to 30 degrees.</p></li>
<li><p><strong>boundary_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>non_manifold_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>feature_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>manifold_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates existing dataset with the extracted features.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>edges</strong> – Extracted edges.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pyvista.vtkPolyData</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_geometry">
<span class="sig-name descname"><span class="pre">extract_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the outer surface of a volume or structured grid dataset as PolyData.</p>
<p>This will extract all 0D, 1D, and 2D cells producing the
boundary faces of the dataset.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_largest">
<span class="sig-name descname"><span class="pre">extract_largest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_largest" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract largest connected set in mesh.</p>
<p>Can be used to reduce residues obtained when generating an isosurface.
Works only if residues are not connected (share at least one point with)
the main component of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Largest connected set in mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_points">
<span class="sig-name descname"><span class="pre">extract_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacent_cells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_cells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the grid (with cells) that contains any of the given point indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ind</strong> (<em>np.ndarray</em><em>, </em><em>list</em><em>, or </em><em>sequence</em>) – Numpy array of point indices to be extracted.</p></li>
<li><p><strong>adjacent_cells</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, extract the cells that contain at least one of the
extracted points. If False, extract the cells that contain
exclusively points from the extracted points list. The default is
True.</p></li>
<li><p><strong>include_cells</strong> (<em>bool</em><em>, </em><em>optional</em>) – Specifies if the cells shall be returned or not. The default is
True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>subgrid</strong> – Subselected grid.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.extract_surface">
<span class="sig-name descname"><span class="pre">extract_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_pointid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_cellid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_subdivision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract surface mesh of the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pass_pointid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Adds a point array “vtkOriginalPointIds” that idenfities which
original points these surface points correspond to</p></li>
<li><p><strong>pass_cellid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Adds a cell array “vtkOriginalPointIds” that idenfities which
original cells these surface cells correspond to</p></li>
<li><p><strong>nonlinear_subdivision</strong> (<em>int</em><em>, </em><em>optional</em>) – <p>If the input is an unstructured grid with nonlinear faces,
this parameter determines how many times the face is
subdivided into linear faces.</p>
<p>If 0, the output is the equivalent of its linear
counterpart (and the midpoints determining the nonlinear
interpolation are discarded). If 1 (the default), the
nonlinear face is triangulated based on the midpoints. If
greater than 1, the triangulated pieces are recursively
subdivided to reach the desired subdivision. Setting the
value to greater than 1 may cause some point data to not
be passed even if no nonlinear faces exist. This option
has no effect if the input is not an unstructured grid.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Surface mesh of the grid.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Extract the surface of an UnstructuredGrid.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_hexbeam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surf</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
<span class="go">&lt;class &#39;pyvista.core.pointset.PolyData&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.glyph">
<span class="sig-name descname"><span class="pre">glyph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.glyph" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a geometric representation (called a glyph) to the input dataset.</p>
<p>The glyph may be oriented along the input vectors, and it may
be scaled according to scalar data or vector
magnitude. Passing a table of glyphs to choose from based on
scalars or vector magnitudes is also supported.  The arrays
used for <code class="docutils literal notranslate"><span class="pre">orient</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> must be either both point data
or both cell data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orient</strong> (<em>bool</em><em> or </em><em>str</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the active vectors array to orient the glyphs.
If string, the vector array to use to orient the glyphs.</p></li>
<li><p><strong>scale</strong> (<em>bool</em><em> or </em><em>str</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, use the active scalars to scale the glyphs.
If string, the scalar array to use to scale the glyphs.</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Scale factor applied to scaling array.</p></li>
<li><p><strong>geom</strong> (<em>vtk.vtkDataSet</em><em> or </em><em>tuple</em><em>(</em><em>vtk.vtkDataSet</em><em>)</em><em>, </em><em>optional</em>) – The geometry to use for the glyph. If missing, an arrow glyph
is used. If a sequence, the datasets inside define a table of
geometries to choose from based on scalars or vectors. In this
case a sequence of numbers of the same length must be passed as
<code class="docutils literal notranslate"><span class="pre">indices</span></code>. The values of the range (see <code class="docutils literal notranslate"><span class="pre">rng</span></code>) affect lookup
in the table.</p></li>
<li><p><strong>indices</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – Specifies the index of each glyph in the table for lookup in case
<code class="docutils literal notranslate"><span class="pre">geom</span></code> is a sequence. If given, must be the same length as
<code class="docutils literal notranslate"><span class="pre">geom</span></code>. If missing, a default value of <code class="docutils literal notranslate"><span class="pre">range(len(geom))</span></code> is
used. Indices are interpreted in terms of the scalar range
(see <code class="docutils literal notranslate"><span class="pre">rng</span></code>). Ignored if <code class="docutils literal notranslate"><span class="pre">geom</span></code> has length 1.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify tolerance in terms of fraction of bounding box length.
Float value is between 0 and 1. Default is None. If <code class="docutils literal notranslate"><span class="pre">absolute</span></code>
is <code class="docutils literal notranslate"><span class="pre">True</span></code> then the tolerance can be an absolute distance.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, points merging as a preprocessing step is disabled.</p></li>
<li><p><strong>absolute</strong> (<em>bool</em><em>, </em><em>optional</em>) – Control if <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> is an absolute distance or a fraction.</p></li>
<li><p><strong>clamping</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off clamping of “scalar” values to range. Default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>rng</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – Set the range of values to be considered by the filter when scalars
values are provided.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>glyphs</strong> – Glyphs at either the cell centers or points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create arrow glyphs oriented by vectors and scaled by scalars.
Factor parameter is used to reduce the size of the arrows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">download_carotid</span><span class="p">()</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="mi">145</span><span class="p">,</span> <span class="n">scalars</span><span class="o">=</span><span class="s2">&quot;scalars&quot;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">glyph</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;vectors&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;scalars&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.interpolate">
<span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sharpness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'null_value'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_cell_arrays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_point_arrays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate values onto this mesh from a given dataset.</p>
<p>The input dataset is typically a point cloud.</p>
<p>This uses a gaussian interpolation kernel. Use the <code class="docutils literal notranslate"><span class="pre">sharpness</span></code> and
<code class="docutils literal notranslate"><span class="pre">radius</span></code> parameters to adjust this kernel. You can also switch this
kernel to use an N closest points approach.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The vtk data object to sample from - point and cell arrays from
this object are interpolated onto this mesh.</p></li>
<li><p><strong>sharpness</strong> (<em>float</em>) – Set / Get the sharpness (i.e., falloff) of the Gaussian. By
default Sharpness=2. As the sharpness increases the effects of
distant points are reduced.</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Specify the radius within which the basis points must lie.</p></li>
<li><p><strong>n_points</strong> (<em>int</em><em>, </em><em>optional</em>) – If given, specifies the number of the closest points used to form
the interpolation basis. This will invalidate the radius argument
in favor of an N closest points approach. This typically has poorer
results.</p></li>
<li><p><strong>strategy</strong> (<em>str</em><em>, </em><em>optional</em>) – Specify a strategy to use when encountering a “null” point during
the interpolation process. Null points occur when the local
neighborhood (of nearby points to interpolate from) is empty. If
the strategy is set to <code class="docutils literal notranslate"><span class="pre">'mask_points'</span></code>, then an output array is
created that marks points as being valid (=1) or null (invalid
=0) (and the NullValue is set as well). If the strategy is set to
<code class="docutils literal notranslate"><span class="pre">'null_value'</span></code> (this is the default), then the output data
value(s) are set to the <code class="docutils literal notranslate"><span class="pre">null_value</span></code> (specified in the output
point data). Finally, the strategy <code class="docutils literal notranslate"><span class="pre">'closest_point'</span></code> is to simply
use the closest point to perform the interpolation.</p></li>
<li><p><strong>null_value</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify the null point value. When a null point is encountered
then all components of each null tuple are set to this value. By
default the null value is set to zero.</p></li>
<li><p><strong>pass_cell_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve input mesh’s original cell data arrays</p></li>
<li><p><strong>pass_point_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve input mesh’s original point data arrays</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.merge">
<span class="sig-name descname"><span class="pre">merge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">main_has_priority</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Join one or many other grids to this grid.</p>
<p>Grid is updated in-place by default.</p>
<p>Can be used to merge points of adjacent cells when no grids
are input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<em>vtk.UnstructuredGrid</em><em> or </em><em>list of vtk.UnstructuredGrids</em>) – Grids to merge to this grid.</p></li>
<li><p><strong>merge_points</strong> (<em>bool</em><em>, </em><em>optional</em>) – Points in exactly the same location will be merged between
the two meshes. Warning: this can leave degenerate point data.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates grid inplace when True if the input type is an
<a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UnstructuredGrid</span></code></a>.</p></li>
<li><p><strong>main_has_priority</strong> (<em>bool</em><em>, </em><em>optional</em>) – When this parameter is true and merge_points is true,
the arrays of the merging grids will be overwritten
by the original main mesh.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>merged_grid</strong> – Merged grid.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>vtk.UnstructuredGrid</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When two or more grids are joined, the type and name of each
array must match or the arrays will be ignored and not
included in the final merged mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.outline">
<span class="sig-name descname"><span class="pre">outline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generate_faces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce an outline of the full extent for the input dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>generate_faces</strong> (<em>bool</em><em>, </em><em>optional</em>) – Generate solid faces for the box. This is off by default</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.outline_corners">
<span class="sig-name descname"><span class="pre">outline_corners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.outline_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce an outline of the corners for the input dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the relative size of the corners to the length of the
corresponding bounds</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.plot_over_circular_arc">
<span class="sig-name descname"><span class="pre">plot_over_circular_arc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pointa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.plot_over_circular_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset along a circular arc and plot it.</p>
<p>Plot the variables of interest in 2D where the X-axis is
distance from Point A and the Y-axis is the variable of
interest. Note that this filter returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pointa</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>pointb</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>center</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of pieces to divide the circular arc into. Defaults
to number of cells in the input mesh. Must be a positive
integer.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name of the variable in the input dataset to
probe. The active scalar is used by default.</p></li>
<li><p><strong>title</strong> (<em>str</em><em>, </em><em>optional</em>) – The string title of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure.</p></li>
<li><p><strong>ylabel</strong> (<em>str</em><em>, </em><em>optional</em>) – The string label of the Y-axis. Defaults to the variable name.</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em><em>, </em><em>optional</em>) – The size of the new figure.</p></li>
<li><p><strong>figure</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag on whether or not to create a new figure.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Shows the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure when <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is
in a cell of the input.  If not given, tolerance is
automatically generated.</p></li>
<li><p><strong>fname</strong> (<em>str</em><em>, </em><em>optional</em>) – Save the figure this file name when set.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Sample a dataset along a high resolution circular arc and plot.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">plot_over_circular_arc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.plot_over_circular_arc_normal">
<span class="sig-name descname"><span class="pre">plot_over_circular_arc_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.plot_over_circular_arc_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset along a resolution circular arc defined by a normal and polar vector and plot it.</p>
<p>Plot the variables of interest in 2D where the X-axis is
distance from Point A and the Y-axis is the variable of
interest. Note that this filter returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – number of pieces to divide circular arc into. Defaults to
number of cells in the input mesh. Must be a positive
integer.</p></li>
<li><p><strong>normal</strong> (<em>np.ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The normal vector to the plane of the arc.  By default it
points in the positive Z direction.</p></li>
<li><p><strong>polar</strong> (<em>np.ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – (starting point of the arc).  By default it is the unit vector
in the positive x direction.</p></li>
<li><p><strong>angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Arc length (in degrees), beginning at the polar vector.  The
direction is counterclockwise.  By default it is 360.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name of the variable in the input dataset to
probe. The active scalar is used by default.</p></li>
<li><p><strong>title</strong> (<em>str</em><em>, </em><em>optional</em>) – The string title of the <cite>matplotlib</cite> figure</p></li>
<li><p><strong>ylabel</strong> (<em>str</em><em>, </em><em>optional</em>) – The string label of the Y-axis. Defaults to variable name</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em><em>, </em><em>optional</em>) – the size of the new figure</p></li>
<li><p><strong>figure</strong> (<em>bool</em><em>, </em><em>optional</em>) – flag on whether or not to create a new figure</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Shows the matplotlib figure</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is
in a cell of the input.  If not given, tolerance is
automatically generated.</p></li>
<li><p><strong>fname</strong> (<em>str</em><em>, </em><em>optional</em>) – Save the figure this file name when set.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Sample a dataset along a high resolution circular arc and plot.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polar</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="mi">90</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">plot_over_circular_arc_normal</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="n">polar</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.plot_over_line">
<span class="sig-name descname"><span class="pre">plot_over_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pointa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.plot_over_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset along a high resolution line and plot.</p>
<p>Plot the variables of interest in 2D where the X-axis is distance from
Point A and the Y-axis is the variable of interest. Note that this filter
returns None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pointa</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in [x, y, z].</p></li>
<li><p><strong>pointb</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in [x, y, z].</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – number of pieces to divide line into. Defaults to number of cells
in the input mesh. Must be a positive integer.</p></li>
<li><p><strong>scalars</strong> (<em>str</em>) – The string name of the variable in the input dataset to probe. The
active scalar is used by default.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – The string title of the <cite>matplotlib</cite> figure</p></li>
<li><p><strong>ylabel</strong> (<em>str</em>) – The string label of the Y-axis. Defaults to variable name</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em>) – the size of the new figure</p></li>
<li><p><strong>figure</strong> (<em>bool</em>) – flag on whether or not to create a new figure</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Shows the matplotlib figure</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is in a
cell of the input.  If not given, tolerance is automatically generated.</p></li>
<li><p><strong>fname</strong> (<em>str</em><em>, </em><em>optional</em>) – Save the figure this file name when set.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.point_data_to_cell_data">
<span class="sig-name descname"><span class="pre">point_data_to_cell_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_point_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.point_data_to_cell_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform point data into cell data.</p>
<p>Point data are specified per node and cell data specified within cells.
Optionally, the input point data can be passed through to the output.</p>
<p>See also: <a class="reference internal" href="#pyvista.DataSetFilters.cell_data_to_point_data" title="pyvista.DataSetFilters.cell_data_to_point_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.cell_data_to_point_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_point_data</strong> (<em>bool</em>) – If enabled, pass the input point data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.probe">
<span class="sig-name descname"><span class="pre">probe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_cell_arrays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_point_arrays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">categorical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample data values at specified point locations.</p>
<p>This uses <code class="xref py py-class docutils literal notranslate"><span class="pre">vtk.vtkProbeFilter</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The mesh to probe from - point and cell arrays from
this object are probed onto the nodes of the <code class="docutils literal notranslate"><span class="pre">points</span></code> mesh</p></li>
<li><p><strong>points</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The points to probe values on to. This should be a PyVista mesh
or something <a class="reference internal" href="../utilities/utilities.html#pyvista.wrap" title="pyvista.wrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.wrap()</span></code></a> can handle.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is in a
cell of the input.  If not given, tolerance is automatically generated.</p></li>
<li><p><strong>pass_cell_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original cell data arrays</p></li>
<li><p><strong>pass_point_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original point data arrays</p></li>
<li><p><strong>categorical</strong> (<em>bool</em><em>, </em><em>optional</em>) – Control whether the source point data is to be treated as
categorical. If the data is categorical, then the resultant data
will be determined by a nearest neighbor interpolation scheme.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Probe the active scalars in <code class="docutils literal notranslate"><span class="pre">grid</span></code> at the points in <code class="docutils literal notranslate"><span class="pre">mesh</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Spatial Point Data&#39;</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">point_arrays</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.ptc">
<span class="sig-name descname"><span class="pre">ptc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_point_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.ptc" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform point data into cell data.</p>
<p>Point data are specified per node and cell data specified within cells.
Optionally, the input point data can be passed through to the output.</p>
<p>An alias/shortcut for <code class="docutils literal notranslate"><span class="pre">point_data_to_cell_data</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.reflect">
<span class="sig-name descname"><span class="pre">reflect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_all_input_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect a dataset across a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Normal direction for reflection.</p></li>
<li><p><strong>point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – Point which, along with <cite>normal</cite>, defines the reflection plane. If not
specified, this is the origin.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – When <code class="docutils literal notranslate"><span class="pre">True</span></code>, modifies the dataset inplace.</p></li>
<li><p><strong>transform_all_input_vectors</strong> (<em>bool</em><em>, </em><em>optional</em>) – When <code class="docutils literal notranslate"><span class="pre">True</span></code>, all input vectors are transformed. Otherwise, only the
points, normals and active vectors are transformed.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_airplane</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">reflect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_cell_arrays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_point_arrays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">categorical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample array data from a passed mesh onto this mesh.</p>
<p>This uses <code class="xref py py-class docutils literal notranslate"><span class="pre">vtk.vtkResampleWithDataSet</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The source vtk data object as the mesh to sample values on to</p></li>
<li><p><strong>target</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The vtk data object to sample from - point and cell arrays from
this object are sampled onto the nodes of the <code class="docutils literal notranslate"><span class="pre">dataset</span></code> mesh</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is in a
cell of the input.  If not given, tolerance is automatically generated.</p></li>
<li><p><strong>pass_cell_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original cell data arrays</p></li>
<li><p><strong>pass_point_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original point data arrays</p></li>
<li><p><strong>categorical</strong> (<em>bool</em><em>, </em><em>optional</em>) – Control whether the source point data is to be treated as
categorical. If the data is categorical, then the resultant data
will be determined by a nearest neighbor interpolation scheme.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.sample_over_circular_arc">
<span class="sig-name descname"><span class="pre">sample_over_circular_arc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pointa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.sample_over_circular_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset over a circular arc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pointa</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>pointb</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>center</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of pieces to divide circular arc into. Defaults to
number of cells in the input mesh. Must be a positive
integer.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is
in a cell of the input.  If not given, tolerance is
automatically generated.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Sample a dataset over a circular arc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniform</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniform</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointa</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointb</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampled_arc</span> <span class="o">=</span> <span class="n">uniform</span><span class="o">.</span><span class="n">sample_over_circular_arc</span><span class="p">(</span><span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.sample_over_circular_arc_normal">
<span class="sig-name descname"><span class="pre">sample_over_circular_arc_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.sample_over_circular_arc_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset over a circular arc defined by a normal and polar vector and plot it.</p>
<p>The number of segments composing the polyline is controlled by
setting the object resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code>.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of pieces to divide circular arc into. Defaults to
number of cells in the input mesh. Must be a positive
integer.</p></li>
<li><p><strong>normal</strong> (<em>np.ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The normal vector to the plane of the arc.  By default it
points in the positive Z direction.</p></li>
<li><p><strong>polar</strong> (<em>np.ndarray</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – Starting point of the arc in polar coordinates.  By
default it is the unit vector in the positive x direction.</p></li>
<li><p><strong>angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Arc length (in degrees), beginning at the polar vector.  The
direction is counterclockwise.  By default it is 360.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is
in a cell of the input.  If not given, tolerance is
automatically generated.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Sample a dataset over a circular arc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniform</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniform</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polar</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uniform</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampled_arc</span> <span class="o">=</span> <span class="n">uniform</span><span class="o">.</span><span class="n">sample_over_circular_arc_normal</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="n">normal</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="n">polar</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.sample_over_line">
<span class="sig-name descname"><span class="pre">sample_over_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pointa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.sample_over_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset onto a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pointa</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in [x, y, z].</p></li>
<li><p><strong>pointb</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in [x, y, z].</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – Number of pieces to divide line into. Defaults to number of cells
in the input mesh. Must be a positive integer.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance used to compute whether a point in the source is in a
cell of the input.  If not given, tolerance is automatically generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sampled_line</strong> – Line object with sampled data from dataset.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pv.PolyData</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.select_enclosed_points">
<span class="sig-name descname"><span class="pre">select_enclosed_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inside_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_surface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.select_enclosed_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark points as to whether they are inside a closed surface.</p>
<p>This evaluates all the input points to determine whether they are in an
enclosed surface. The filter produces a (0,1) mask
(in the form of a vtkDataArray) that indicates whether points are
outside (mask value=0) or inside (mask value=1) a provided surface.
(The name of the output vtkDataArray is “SelectedPoints”.)</p>
<p>This filter produces and output data array, but does not modify the
input dataset. If you wish to extract cells or poinrs, various
threshold filters are available (i.e., threshold the output array).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The filter assumes that the surface is closed and manifold. A boolean
flag can be set to force the filter to first check whether this is
true. If false, all points will be marked outside. Note that if this
check is not performed and the surface is not closed, the results are
undefined.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – Set the surface to be used to test for containment. This must be a
<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> object.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – The tolerance on the intersection. The tolerance is expressed as a
fraction of the bounding box of the enclosing surface.</p></li>
<li><p><strong>inside_out</strong> (<em>bool</em>) – By default, points inside the surface are marked inside or sent
to the output. If <code class="docutils literal notranslate"><span class="pre">inside_out</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the points
outside the surface are marked inside.</p></li>
<li><p><strong>check_surface</strong> (<em>bool</em>) – Specify whether to check the surface for closure. If on, then the
algorithm first checks to see if the surface is closed and
manifold. If the surface is not closed and manifold, a runtime
error is raised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.shrink">
<span class="sig-name descname"><span class="pre">shrink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shrink_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.shrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Shrink the individual faces of a mesh.</p>
<p>This filter shrinks the individual faces of a mesh rather than scaling
the entire mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shrink_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – fraction of shrink for each cell.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Extrude shrink mesh</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shrunk_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shrink</span><span class="p">(</span><span class="n">shrink_factor</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a dataset by a plane at the specified origin and normal vector orientation.</p>
<p>If no origin is specified, the center of the input dataset will be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)`</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – The center (x,y,z) coordinate of the plane on which the slice occurs</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.slice_along_axis">
<span class="sig-name descname"><span class="pre">slice_along_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create many slices of the input dataset along a specified axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of slices to create</p></li>
<li><p><strong>axis</strong> (<em>str</em><em> or </em><em>int</em>) – The axis to generate the slices along. Perpendicular to the slices.
Can be string name (<code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'z'</span></code>) or axis index
(<code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, or <code class="docutils literal notranslate"><span class="pre">2</span></code>).</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – The tolerance to the edge of the dataset bounds to create the slices</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.slice_along_line">
<span class="sig-name descname"><span class="pre">slice_along_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice_along_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a dataset using a polyline/spline as the path.</p>
<p>This also works for lines generated with <a class="reference internal" href="../utilities/geometric.html#pyvista.Line" title="pyvista.Line"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.Line()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – A PolyData object containing one single PolyLine cell.</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.slice_orthogonal">
<span class="sig-name descname"><span class="pre">slice_orthogonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create three orthogonal slices through the dataset on the three cartesian planes.</p>
<p>Yields a MutliBlock dataset of the three slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em>) – The X location of the YZ slice</p></li>
<li><p><strong>y</strong> (<em>float</em>) – The Y location of the XZ slice</p></li>
<li><p><strong>z</strong> (<em>float</em>) – The Z location of the XY slice</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.split_bodies">
<span class="sig-name descname"><span class="pre">split_bodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.split_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Find, label, and split connected bodies/volumes.</p>
<p>This splits different connected bodies into blocks in a MultiBlock dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> (<em>bool</em>) – A flag on whether to keep the ID arrays given by the
<code class="docutils literal notranslate"><span class="pre">connectivity</span></code> filter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.streamlines">
<span class="sig-name descname"><span class="pre">streamlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pointb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate a vector field to generate streamlines.</p>
<p>The default behavior uses a Sphere as the source - set it’s location and
radius via the <code class="docutils literal notranslate"><span class="pre">source_center</span></code> and <code class="docutils literal notranslate"><span class="pre">source_radius</span></code> keyword arguments.
<code class="docutils literal notranslate"><span class="pre">n_points</span></code> defines the number of starting points on the sphere surface.
Alternatively, a Line source can be used by specifying <code class="docutils literal notranslate"><span class="pre">pointa</span></code> and <code class="docutils literal notranslate"><span class="pre">pointb</span></code>.
<code class="docutils literal notranslate"><span class="pre">n_points</span></code> again defines the number of points on the line.</p>
<p>You can retrieve the source by specifying <code class="docutils literal notranslate"><span class="pre">return_source=True</span></code>.</p>
<p>Optional keyword parameters from <a class="reference internal" href="#pyvista.DataSetFilters.streamlines_from_source" title="pyvista.DataSetFilters.streamlines_from_source"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.streamlines_from_source()</span></code></a>
can be used here to control the generation of streamlines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name of the active vector field to integrate across.</p></li>
<li><p><strong>source_center</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – Length 3 tuple of floats defining the center of the source
particles. Defaults to the center of the dataset.</p></li>
<li><p><strong>source_radius</strong> (<em>float</em><em>, </em><em>optional</em>) – Float radius of the source particle cloud. Defaults to one-tenth of
the diagonal of the dataset’s spatial extent.</p></li>
<li><p><strong>n_points</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of particles present in source sphere or line.</p></li>
<li><p><strong>start_position</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – A single point.  This will override the sphere point source.</p></li>
<li><p><strong>return_source</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return the source particles as <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> as well as the
streamlines. This will be the second value returned if <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>pointa</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The coordinates of a start and end point for a line source. This
will override the sphere and start_position point source.</p></li>
<li><p><strong>pointb</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The coordinates of a start and end point for a line source. This
will override the sphere and start_position point source.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>streamlines</strong> (<em>pyvista.PolyData</em>) – This produces polylines as the output, with each cell
(i.e., polyline) representing a streamline. The attribute values
associated with each streamline are stored in the cell data, whereas
those associated with streamline-points are stored in the point data.</p></li>
<li><p><strong>source</strong> (<em>pyvista.PolyData</em>) – The points of the source are the seed points for the streamlines.
Only returned if <code class="docutils literal notranslate"><span class="pre">return_source=True</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.streamlines_from_source">
<span class="sig-name descname"><span class="pre">streamlines_from_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrator_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integration_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'both'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_streamlines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_step_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_step_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_step_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terminal_speed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_vorticity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolator_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'point'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.streamlines_from_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate streamlines of vectors from the points of a source mesh.</p>
<p>The integration is performed using a specified integrator, by default
Runge-Kutta2. This supports integration through any type of dataset.
If the dataset contains 2D cells like polygons or triangles and the
<code class="docutils literal notranslate"><span class="pre">surface_streamlines</span></code> parameter is used, the integration is constrained
to lie on the surface defined by 2D cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source</strong> (<a class="reference internal" href="dataset.html#pyvista.DataSet" title="pyvista.DataSet"><em>pyvista.DataSet</em></a>) – The points of the source provide the starting points of the
streamlines.  This will override both sphere and line sources.</p></li>
<li><p><strong>vectors</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name of the active vector field to integrate across.</p></li>
<li><p><strong>integrator_type</strong> (<em>int</em><em>, </em><em>optional</em>) – The integrator type to be used for streamline generation.
The default is Runge-Kutta45. The recognized solvers are:
RUNGE_KUTTA2 (<code class="docutils literal notranslate"><span class="pre">2</span></code>),  RUNGE_KUTTA4 (<code class="docutils literal notranslate"><span class="pre">4</span></code>), and RUNGE_KUTTA45
(<code class="docutils literal notranslate"><span class="pre">45</span></code>). Options are <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>, or <code class="docutils literal notranslate"><span class="pre">45</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">45</span></code>.</p></li>
<li><p><strong>integration_direction</strong> (<em>str</em><em>, </em><em>optional</em>) – Specify whether the streamline is integrated in the upstream or
downstream directions (or both). Options are <code class="docutils literal notranslate"><span class="pre">'both'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'backward'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'forward'</span></code>.</p></li>
<li><p><strong>surface_streamlines</strong> (<em>bool</em><em>, </em><em>optional</em>) – Compute streamlines on a surface. Default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>initial_step_length</strong> (<em>float</em><em>, </em><em>optional</em>) – Initial step size used for line integration, expressed ib length
unitsL or cell length units (see <code class="docutils literal notranslate"><span class="pre">step_unit</span></code> parameter).
either the starting size for an adaptive integrator, e.g., RK45, or
the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4).</p></li>
<li><p><strong>step_unit</strong> (<em>str</em><em>, </em><em>optional</em>) – Uniform integration step unit. The valid unit is now limited to
only LENGTH_UNIT (<code class="docutils literal notranslate"><span class="pre">'l'</span></code>) and CELL_LENGTH_UNIT (<code class="docutils literal notranslate"><span class="pre">'cl'</span></code>).
Default is CELL_LENGTH_UNIT: <code class="docutils literal notranslate"><span class="pre">'cl'</span></code>.</p></li>
<li><p><strong>min_step_length</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum step size used for line integration, expressed in length or
cell length units. Only valid for an adaptive integrator, e.g., RK45.</p></li>
<li><p><strong>max_step_length</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum step size used for line integration, expressed in length or
cell length units. Only valid for an adaptive integrator, e.g., RK45.</p></li>
<li><p><strong>max_steps</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of steps for integrating a streamline.
Defaults to <code class="docutils literal notranslate"><span class="pre">2000</span></code></p></li>
<li><p><strong>terminal_speed</strong> (<em>float</em><em>, </em><em>optional</em>) – Terminal speed value, below which integration is terminated.</p></li>
<li><p><strong>max_error</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum error tolerated throughout streamline integration.</p></li>
<li><p><strong>max_time</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify the maximum length of a streamline expressed in LENGTH_UNIT.</p></li>
<li><p><strong>compute_vorticity</strong> (<em>bool</em><em>, </em><em>optional</em>) – Vorticity computation at streamline points (necessary for generating
proper stream-ribbons using the <code class="docutils literal notranslate"><span class="pre">vtkRibbonFilter</span></code>.</p></li>
<li><p><strong>interpolator_type</strong> (<em>str</em><em>, </em><em>optional</em>) – Set the type of the velocity field interpolator to locate cells
during streamline integration either by points or cells.
The cell locator is more robust then the point locator. Options
are <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code> (abbreviations of <code class="docutils literal notranslate"><span class="pre">'p'</span></code> and <code class="docutils literal notranslate"><span class="pre">'c'</span></code>
are also supported).</p></li>
<li><p><strong>rotation_scale</strong> (<em>float</em><em>, </em><em>optional</em>) – This can be used to scale the rate with which the streamribbons
twist. The default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>streamlines</strong> – This produces polylines as the output, with each cell
(i.e., polyline) representing a streamline. The attribute values
associated with each streamline are stored in the cell data, whereas
those associated with streamline-points are stored in the point data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.surface_indices">
<span class="sig-name descname"><span class="pre">surface_indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.surface_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the surface indices of a grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>surf_ind</strong> – Indices of the surface points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.texture_map_to_plane">
<span class="sig-name descname"><span class="pre">texture_map_to_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Texture</span> <span class="pre">Coordinates'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.texture_map_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Texture map this dataset to a user defined plane.</p>
<p>This is often used to define a plane to texture map an image to this dataset.
The plane defines the spatial reference and extent of that image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
BOTTOM LEFT CORNER of the plane</p></li>
<li><p><strong>point_u</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
BOTTOM RIGHT CORNER of the plane</p></li>
<li><p><strong>point_v</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
TOP LEFT CORNER of the plane</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the new texture coordinates will be added to this
dataset. If False (default), a new dataset is returned
with the textures coordinates</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name to give the new texture coordinates if applying
the filter inplace.</p></li>
<li><p><strong>use_bounds</strong> (<em>bool</em><em>, </em><em>optional</em>) – Use the bounds to set the mapping plane by default (bottom plane
of the bounding box).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.texture_map_to_sphere">
<span class="sig-name descname"><span class="pre">texture_map_to_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevent_seam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Texture</span> <span class="pre">Coordinates'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.texture_map_to_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Texture map this dataset to a user defined sphere.</p>
<p>This is often used to define a sphere to texture map an image to this
dataset. The sphere defines the spatial reference and extent of that image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
center of the sphere. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, this will be automatically
calculated.</p></li>
<li><p><strong>prevent_seam</strong> (<em>bool</em>) – Default true. Control how the texture coordinates are generated.
If set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding
to the theta angle variation between 0-&gt;180 and 180-&gt;0 degrees.
Otherwise, the s-coordinate ranges from 0-&gt;1 between 0-&gt;360
degrees.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the new texture coordinates will be added to the dataset
inplace. If False (default), a new dataset is returned with the
textures coordinates</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name to give the new texture coordinates if applying
the filter inplace.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Map a puppy texture to a sphere</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">texture_map_to_sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tex</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">download_puppy_texture</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">texture</span><span class="o">=</span><span class="n">tex</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cell'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a <code class="docutils literal notranslate"><span class="pre">vtkThreshold</span></code> filter to the input dataset.</p>
<p>This filter will apply a <code class="docutils literal notranslate"><span class="pre">vtkThreshold</span></code> filter to the input dataset
and return the resulting object. This extracts cells where the scalar
value in each cell satisfies threshold criterion.  If scalars is None,
the inputs active scalars is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>float</em><em> or </em><em>sequence</em><em>, </em><em>optional</em>) – Single value or (min, max) to be used for the data threshold.  If
a sequence, then length must be 2. If no value is specified, the
non-NaN data range will be used to remove any NaN values.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to threshold on. Defaults to currently active scalars.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – If value is a single value, when invert is True cells are kept when
their values are below parameter “value”.  When invert is False
cells are kept when their value is above the threshold “value”.
Default is False: yielding above the threshold “value”.</p></li>
<li><p><strong>continuous</strong> (<em>bool</em><em>, </em><em>optional</em>) – When True, the continuous interval [minimum cell scalar,
maximum cell scalar] will be used to intersect the threshold bound,
rather than the set of discrete scalar values from the vertices.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the preferred array type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
<li><p><strong>all_scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – If using scalars from point data, all scalars for all
points in a cell must satisfy the threshold when this
value is <code class="docutils literal notranslate"><span class="pre">True</span></code>.  When <code class="docutils literal notranslate"><span class="pre">False</span></code>, any point of the cell
with a scalar value satisfying the threshold criterion
will extract the cell.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshed</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.threshold_percent">
<span class="sig-name descname"><span class="pre">threshold_percent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">percent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cell'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.threshold_percent" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold the dataset by a percentage of its range on the active scalars array or as specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>percent</strong> (<em>float</em><em> or </em><em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The percentage (0,1) to threshold. If value is out of 0 to 1 range,
then it will be divided by 100 and checked to be in that range.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to threshold on. Defaults to currently active scalars.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – When invert is True cells are kept when their values are below the
percentage of the range.  When invert is False, cells are kept when
their value is above the percentage of the range.
Default is False: yielding above the threshold “value”.</p></li>
<li><p><strong>continuous</strong> (<em>bool</em><em>, </em><em>optional</em>) – When True, the continuous interval [minimum cell scalar,
maximum cell scalar] will be used to intersect the threshold bound,
rather than the set of discrete scalar values from the vertices.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the preferred array type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trans</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">vtkmodules.vtkCommonMath.vtkMatrix4x4</span><span class="p"><span class="pre">,</span> </span><span class="pre">vtkmodules.vtkCommonTransforms.vtkTransform</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform_all_input_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform this mesh with a 4x4 transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> (<em>vtk.vtkMatrix4x4</em><em>, </em><em>vtk.vtkTransform</em><em>, or </em><em>np.ndarray</em>) – Accepts a vtk transformation object or a 4x4
transformation matrix.</p></li>
<li><p><strong>transform_all_input_vectors</strong> (<em>bool</em><em>, </em><em>optional</em>) – When <code class="docutils literal notranslate"><span class="pre">True</span></code>, all input vectors are
transformed. Otherwise, only the points, normals and
active vectors are transformed.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – When <code class="docutils literal notranslate"><span class="pre">True</span></code>, modifies the dataset inplace.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Translate a mesh by <code class="docutils literal notranslate"><span class="pre">(50,</span> <span class="pre">100,</span> <span class="pre">200)</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_airplane</span><span class="p">()</span>
</pre></div>
</div>
<p>Here a 4x4 <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array is used, but
<code class="docutils literal notranslate"><span class="pre">vtk.vtkMatrix4x4</span></code> and <code class="docutils literal notranslate"><span class="pre">vtk.vtkTransform</span></code> are also
accepted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transform_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transform_matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">transformed</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.triangulate">
<span class="sig-name descname"><span class="pre">triangulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an all triangle mesh.</p>
<p>More complex polygons will be broken down into triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh containing only triangles.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.warp_by_scalar">
<span class="sig-name descname"><span class="pre">warp_by_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.warp_by_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp the dataset’s points by a point data scalars array’s values.</p>
<p>This modifies point coordinates by moving points along point normals by
the scalar amount times the scale factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to warp by. Defaults to currently active scalars.</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – A scaling factor to increase the scaling effect. Alias
<code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> also accepted - if present, overrides <code class="docutils literal notranslate"><span class="pre">factor</span></code>.</p></li>
<li><p><strong>normal</strong> (<em>np.array</em><em>, </em><em>list</em><em>, </em><em>tuple of length 3</em>) – User specified normal. If given, data normals will be ignored and
the given normal will be used to project the warp.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em>) – If True, the points of the given dataset will be updated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.DataSetFilters.warp_by_vector">
<span class="sig-name descname"><span class="pre">warp_by_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.warp_by_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp the dataset’s points by a point data vectors array’s values.</p>
<p>This modifies point coordinates by moving points along point vectors by
the local vector times the scale factor.</p>
<p>A classical application of this transform is to visualize eigenmodes in
mechanics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of vector to warp by. Defaults to currently active vector.</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – A scaling factor that multiplies the vectors to warp by. Can
be used to enhance the warping effect.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the function will update the mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>warped_mesh</strong> – The warped mesh resulting from the operation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mesh</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polydata-filters">
<h2>PolyData Filters<a class="headerlink" href="#polydata-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.PolyDataFilters" title="pyvista.PolyDataFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyDataFilters</span></code></a> is inherited by <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a>
making all the following filters available as callable methods directly
from any <code class="docutils literal notranslate"><span class="pre">PolyData</span></code> mesh.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_add</span></code>(mesh[, inplace])</p></td>
<td><p>Add a mesh to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_cut</span></code>(cut[, tolerance, inplace])</p></td>
<td><p>Perform a Boolean cut using another mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_difference</span></code>(mesh[, inplace])</p></td>
<td><p>Combine two meshes and retains only the volume in common between the meshes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_union</span></code>(mesh[, inplace])</p></td>
<td><p>Combine two meshes and attempts to create a manifold mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clean</span></code>([point_merging, tolerance, …])</p></td>
<td><p>Clean the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_closed_surface</span></code>([normal, origin, …])</p></td>
<td><p>Clip a closed polydata surface with a plane.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_arc_length</span></code>()</p></td>
<td><p>Compute the arc length over the length of the probed line.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_normals</span></code>([cell_normals, …])</p></td>
<td><p>Compute point and/or cell normals for a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">curvature</span></code>([curv_type])</p></td>
<td><p>Return the pointwise curvature of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code>(target_reduction[, …])</p></td>
<td><p>Reduce the number of triangles in a triangular mesh using vtkQuadricDecimation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate_pro</span></code>(reduction[, feature_angle, …])</p></td>
<td><p>Reduce the number of triangles in a triangular mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delaunay_2d</span></code>([tol, alpha, offset, bound, …])</p></td>
<td><p>Apply a delaunay 2D filter along the best fitting plane.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_mask</span></code>(angle)</p></td>
<td><p>Return a mask of the points of a surface mesh that has a surface angle greater than angle.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extrude</span></code>(vector[, inplace, progress_bar])</p></td>
<td><p>Sweep polygonal data creating a “skirt” from free edges.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extrude_rotate</span></code>([resolution, inplace, …])</p></td>
<td><p>Sweep polygonal data creating “skirt” from free edges and lines, and lines from vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>(hole_size[, inplace, progress_bar])</p></td>
<td><p>Fill holes in a pyvista.PolyData or vtk.vtkPolyData object.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flip_normals</span></code>()</p></td>
<td><p>Flip normals of a triangular mesh by reversing the point ordering.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic</span></code>(start_vertex, end_vertex[, inplace])</p></td>
<td><p>Calculate the geodesic path between two vertices using Dijkstra’s algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic_distance</span></code>(start_vertex, end_vertex)</p></td>
<td><p>Calculate the geodesic distance between two vertices using Dijkstra’s algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(mesh[, split_first, split_second])</p></td>
<td><p>Compute the intersection between two meshes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_ray_trace</span></code>(origins, directions[, …])</p></td>
<td><p>Perform multiple ray trace calculations.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_boundaries</span></code>([edge_color])</p></td>
<td><p>Plot boundaries of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_curvature</span></code>([curv_type])</p></td>
<td><p>Plot the curvature.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_normals</span></code>([show_mesh, mag, flip, use_every])</p></td>
<td><p>Plot the point normals of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_points_to_plane</span></code>([origin, normal, …])</p></td>
<td><p>Project points of this mesh to a plane.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ray_trace</span></code>(origin, end_point[, first_point, …])</p></td>
<td><p>Perform a single ray trace calculation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_points</span></code>(remove[, mode, keep_scalars, …])</p></td>
<td><p>Rebuild a mesh by removing points.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ribbon</span></code>([width, scalars, angle, factor, …])</p></td>
<td><p>Create a ribbon of the lines in this dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth</span></code>([n_iter, relaxation_factor, …])</p></td>
<td><p>Adjust point coordinates using Laplacian smoothing.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">strip</span></code>([join, max_length, pass_cell_data, …])</p></td>
<td><p>Strip poly data cells.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>(nsub[, subfilter, inplace])</p></td>
<td><p>Increase the number of triangles in a single, connected triangular mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangulate</span></code>([inplace])</p></td>
<td><p>Return an all triangle mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tube</span></code>([radius, scalars, capping, n_sides, …])</p></td>
<td><p>Generate a tube around each input line.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyvista.</span></span><span class="sig-name descname"><span class="pre">PolyDataFilters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.core.filters.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.core.filters.DataSetFilters</span></code></a></p>
<p>An internal class to manage filters/algorithms for polydata datasets.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.boolean_add">
<span class="sig-name descname"><span class="pre">boolean_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a mesh to the current mesh.</p>
<p>Does not attempt to “join” the meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to add.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>joinedmesh</strong> – The joined mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.boolean_cut">
<span class="sig-name descname"><span class="pre">boolean_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a Boolean cut using another mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cut</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – Mesh making the cut</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – The cut mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.boolean_difference">
<span class="sig-name descname"><span class="pre">boolean_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two meshes and retains only the volume in common between the meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to perform a union against.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – The union mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.boolean_union">
<span class="sig-name descname"><span class="pre">boolean_union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two meshes and attempts to create a manifold mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to perform a union against.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – The union mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.clean">
<span class="sig-name descname"><span class="pre">clean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_merging</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lines_to_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polys_to_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strips_to_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean the mesh.</p>
<p>This merges duplicate points, removes unused points, and/or
removes degenerate cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_merging</strong> (<em>bool</em><em>, </em><em>optional</em>) – Enables point merging.  On by default.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Set merging tolerance.  When enabled merging is set to
absolute distance. If <code class="docutils literal notranslate"><span class="pre">absolute</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then the
merging tolerance is a fraction of the bounding box
length. The alias <code class="docutils literal notranslate"><span class="pre">merge_tol</span></code> is also excepted.</p></li>
<li><p><strong>lines_to_points</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off conversion of degenerate lines to points.
Enabled by default.</p></li>
<li><p><strong>polys_to_lines</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off conversion of degenerate polys to lines.
Enabled by default.</p></li>
<li><p><strong>strips_to_polys</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off conversion of degenerate strips to polys.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place. Default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>absolute</strong> (<em>bool</em><em>, </em><em>optional</em>) – Control if <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> is an absolute distance or a
fraction.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Cleaned mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a mesh with a degenerate face and then clean it,
removing the degenerate face</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">faces</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mout</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mout</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>  
<span class="go">[3 0 1 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.clip_closed_surface">
<span class="sig-name descname"><span class="pre">clip_closed_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.clip_closed_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a closed polydata surface with a plane.</p>
<p>This currently only supports one plane but could be
implemented to handle a plane collection.</p>
<p>It will produce a new closed surface by creating new polygonal
faces where the input data was clipped.</p>
<p>Non-manifold surfaces should not be used as input for this
filter.  The input surface should have no open edges, and must
not have any edges that are shared by more than two faces. In
addition, the input surface should not self-intersect, meaning
that the faces of the surface should only touch at their
edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>str</em><em>, </em><em>list</em><em>, </em><em>optional</em>) – Plane normal to clip with.  Plane is centered at
<code class="docutils literal notranslate"><span class="pre">origin</span></code>.  Normal can be either a 3 member list
(e.g. <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>) or one of the following strings:
<code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code>, <code class="docutils literal notranslate"><span class="pre">'z'</span></code>, <code class="docutils literal notranslate"><span class="pre">'-x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'-y'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'-z'</span></code>.</p></li>
<li><p><strong>origin</strong> (<em>list</em><em>, </em><em>optional</em>) – Coordinate of the origin (e.g. <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>).  Defaults
to the center of the mesh.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – The tolerance for creating new points while clipping.  If
the tolerance is too small, then degenerate triangles
might be produced.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>clipped_mesh</strong> – The clipped mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Clip a sphere in the X direction centered at the origin.  This
will leave behind half a sphere in the positive X direction.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_mesh</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">clip_closed_surface</span><span class="p">()</span>
</pre></div>
</div>
<p>Clip the sphere at the xy plane and leave behind half the
sphere in the positive Z direction.  Shift the clip upwards to
leave a smaller mesh behind.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_mesh</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">clip_closed_surface</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.compute_arc_length">
<span class="sig-name descname"><span class="pre">compute_arc_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.compute_arc_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arc length over the length of the probed line.</p>
<p>It adds a new point-data array named <code class="docutils literal notranslate"><span class="pre">&quot;arc_length&quot;</span></code> with the
computed arc length for each of the polylines in the
input. For all other cell types, the arc length is set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>arc_length</strong> – Arc length of the length of the probed line.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">compute_arc_length</span><span class="p">()[</span><span class="s1">&#39;arc_length&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Length is </span><span class="si">{</span><span class="n">length</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Length is 0.812</span>
</pre></div>
</div>
<p>This is identical to the geodesic_distance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">length</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">geodesic_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Length is </span><span class="si">{</span><span class="n">length</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Length is 0.812</span>
</pre></div>
</div>
<p>You can also plot the arc_length</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arc</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">compute_arc_length</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">scalars</span><span class="o">=</span><span class="s2">&quot;arc_length&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.compute_normals">
<span class="sig-name descname"><span class="pre">compute_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">consistent_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_orient_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_manifold_traversal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.compute_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute point and/or cell normals for a mesh.</p>
<p>The filter can reorder polygons to insure consistent
orientation across polygon neighbors. Sharp edges can be split
and points duplicated with separate normals to give crisp
(rendered) surface definition. It is also possible to globally
flip the normal orientation.</p>
<p>The algorithm works by determining normals for each polygon
and then averaging them at shared points. When sharp edges are
present, the edges are split and new points generated to
prevent blurry edges (due to Gouraud shading).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Calculation of cell normals. Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>point_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Calculation of point normals. Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>split_vertices</strong> (<em>bool</em><em>, </em><em>optional</em>) – Splitting of sharp edges. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>flip_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set global flipping of normal orientation. Flipping
modifies both the normal direction and the order of a
cell’s points. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>consistent_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Enforcement of consistent polygon ordering. Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>auto_orient_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off the automatic determination of correct normal
orientation. NOTE: This assumes a completely closed
surface (i.e. no boundary edges) and no non-manifold
edges. If these constraints do not hold, all bets are
off. This option adds some computational complexity, and
is useful if you do not want to have to inspect the
rendered image to determine whether to turn on the
<code class="docutils literal notranslate"><span class="pre">flip_normals</span></code> flag.  However, this flag can work with
the <code class="docutils literal notranslate"><span class="pre">flip_normals</span></code> flag, and if both are set, all the
normals in the output will point “inward”. Defaults to
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>non_manifold_traversal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off traversal across non-manifold edges. Changing
this may prevent problems where the consistency of
polygonal ordering is corrupted due to topological
loops. Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – The angle that defines a sharp edge. If the difference in
angle across neighboring polygons is greater than this
value, the shared edge is considered “sharp”. Defaults to
30.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Updated mesh with cell and point normals.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the point normals of the surface of a sphere.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">compute_normals</span><span class="p">(</span><span class="n">cell_normals</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normals</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normals</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(842, 3)</span>
</pre></div>
</div>
<p>Alternatively, create a new mesh when computing the normals
and compute both cell and point normals.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere_with_norm</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">compute_normals</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere_with_norm</span><span class="o">.</span><span class="n">point_arrays</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(842, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere_with_norm</span><span class="o">.</span><span class="n">cell_arrays</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1680, 3)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Previous arrays named “Normals” will be overwritten.</p>
<p>Normals are computed only for polygons and triangle
strips. Normals are not computed for lines or vertices.</p>
<p>Triangle strips are broken up into triangle polygons. You may
want to restrip the triangles.</p>
<p>May be easier to run <code class="docutils literal notranslate"><span class="pre">mesh.point_normals</span></code> or <code class="docutils literal notranslate"><span class="pre">mesh.cell_normals</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.curvature">
<span class="sig-name descname"><span class="pre">curvature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curv_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pointwise curvature of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>vtk.polydata</em>) – vtk polydata mesh</p></li>
<li><p><strong>string</strong> (<em>curvature</em>) – One of the following strings
Mean
Gaussian
Maximum
Minimum</p></li>
<li><p><strong>optional</strong> – One of the following strings
Mean
Gaussian
Maximum
Minimum</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>curvature</strong> – Curvature values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.decimate">
<span class="sig-name descname"><span class="pre">decimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_reduction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume_preservation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tcoords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normals_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tcoords_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the number of triangles in a triangular mesh using vtkQuadricDecimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>vtk.PolyData</em>) – Mesh to decimate</p></li>
<li><p><strong>target_reduction</strong> (<em>float</em>) – Fraction of the original mesh to remove.
TargetReduction is set to 0.9, this filter will try to reduce
the data set to 10% of its original size and will remove 90%
of the input triangles.</p></li>
<li><p><strong>volume_preservation</strong> (<em>bool</em><em>, </em><em>optional</em>) – Decide whether to activate volume preservation which greatly reduces
errors in triangle normal direction. If off, volume preservation is
disabled and if AttributeErrorMetric is active, these errors can be
large. Defaults to False.</p></li>
<li><p><strong>attribute_error</strong> (<em>bool</em><em>, </em><em>optional</em>) – Decide whether to include data attributes in the error metric. If
off, then only geometric error is used to control the decimation.
Defaults to False.</p></li>
<li><p><strong>scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – If attribute errors are to be included in the metric (i.e.,
AttributeErrorMetric is on), then the following flags control which
attributes are to be included in the error calculation. Defaults to
True.</p></li>
<li><p><strong>vectors</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to True.</p></li>
<li><p><strong>normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to False.</p></li>
<li><p><strong>tcoords</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to True.</p></li>
<li><p><strong>tensors</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to True.</p></li>
<li><p><strong>scalars_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – The scaling weight contribution of the scalar attribute. These
values are used to weight the contribution of the attributes towards
the error metric. Defaults to 0.1.</p></li>
<li><p><strong>vectors_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>normals_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>tcoords_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>tensors_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>outmesh</strong> – Decimated mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Decimate a sphere while preserving its volume</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">theta_resolution</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">phi_resolution</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
<span class="go">15840</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dec_sphere</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">volume_preservation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dec_sphere</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
<span class="go">1584</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>If you encounter a segmentation fault or other error, consider
using <code class="docutils literal notranslate"><span class="pre">clean</span></code> to remove any invalid cells before using this
filter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.decimate_pro">
<span class="sig-name descname"><span class="pre">decimate_pro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reduction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">75.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_split_mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_topology</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.decimate_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the number of triangles in a triangular mesh.</p>
<p>It forms a good approximation to the original geometry. Based on the algorithm
originally described in “Decimation of Triangle Meshes”, Proc Siggraph 92.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reduction</strong> (<em>float</em>) – Reduction factor. A value of 0.9 will leave 10 % of the original number
of vertices.</p></li>
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Angle used to define what an edge is (i.e., if the surface normal between
two adjacent triangles is &gt;= feature_angle, an edge exists).</p></li>
<li><p><strong>split_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Angle used to control the splitting of the mesh. A split line exists
when the surface normals between two edge connected triangles are &gt;= split_angle.</p></li>
<li><p><strong>splitting</strong> (<em>bool</em><em>, </em><em>optional</em>) – Controls the splitting of the mesh at corners, along edges, at non-manifold
points, or anywhere else a split is required. Turning splitting off
will better preserve the original topology of the mesh, but may not
necessarily give the exact requested decimation.</p></li>
<li><p><strong>pre_split_mesh</strong> (<em>bool</em><em>, </em><em>optional</em>) – Separates the mesh into semi-planar patches, which are disconnected
from each other. This can give superior results in some cases. If pre_split_mesh
is set to True, the mesh is split with the specified split_angle. Otherwise
mesh splitting is deferred as long as possible.</p></li>
<li><p><strong>preserve_topology</strong> (<em>bool</em><em>, </em><em>optional</em>) – Controls topology preservation. If on, mesh splitting and hole elimination
will not occur. This may limit the maximum reduction that may be achieved.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Decimated mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.delaunay_2d">
<span class="sig-name descname"><span class="pre">delaunay_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.delaunay_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a delaunay 2D filter along the best fitting plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify a tolerance to control discarding of closely
spaced points. This tolerance is specified as a fraction
of the diagonal length of the bounding box of the points.
Defaults to <code class="docutils literal notranslate"><span class="pre">1e-05</span></code>.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify alpha (or distance) value to control output of
this filter. For a non-zero alpha value, only edges or
triangles contained within a sphere centered at mesh
vertices will be output. Otherwise, only triangles will be
output. Defaults to <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.</p></li>
<li><p><strong>offset</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify a multiplier to control the size of the initial,
bounding Delaunay triangulation. Defaults to <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p></li>
<li><p><strong>bound</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean controls whether bounding triangulation points
and associated triangles are included in the
output. These are introduced as an initial triangulation
to begin the triangulation process. This feature is nice
for debugging output. Default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, overwrite this mesh with the triangulated
mesh. Default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>edge_source</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a><em>, </em><em>optional</em>) – Specify the source object used to specify constrained
edges and loops. If set, and lines/polygons are defined, a
constrained triangulation is created. The lines/polygons
are assumed to reference points in the input point set
(i.e. point ids are identical in the input and
source).</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress. Default
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Extract the points of a sphere and then convert the point
cloud to a surface mesh.  Note that only the bottom half is
converted to a mesh.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">delaunay_2d</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.edge_mask">
<span class="sig-name descname"><span class="pre">edge_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.edge_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mask of the points of a surface mesh that has a surface angle greater than angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>angle</strong> (<em>float</em>) – Angle to consider an edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.extrude">
<span class="sig-name descname"><span class="pre">extrude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.extrude" title="Permalink to this definition">¶</a></dt>
<dd><p>Sweep polygonal data creating a “skirt” from free edges.</p>
<p>This will create a line from vertices.</p>
<p>This takes polygonal data as input and generates polygonal
data on output. The input dataset is swept according to some
extrusion function and creates new polygonal primitives. These
primitives form a “skirt” or swept surface. For example,
sweeping a line results in a quadrilateral, and sweeping a
triangle creates a “wedge”.</p>
<p>There are a number of control parameters for this filter. You
can control whether the sweep of a 2D object (i.e., polygon or
triangle strip) is capped with the generating geometry via the
“Capping” parameter.</p>
<p>The skirt is generated by locating certain topological
features. Free edges (edges of polygons or triangle strips
only used by one polygon or triangle strips) generate
surfaces. This is true also of lines or polylines. Vertices
generate lines.</p>
<p>This filter can be used to create 3D fonts, 3D irregular bar
charts, or to model 2 1/2D objects like punched plates. It
also can be used to create solid objects from 2D polygonal
meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – Mesh to extrude.</p></li>
<li><p><strong>vector</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Direction and length to extrude the mesh in.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Overwrites the original mesh in-place.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Extrude a half arc circle</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arc</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">CircularArc</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">extrude</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.extrude_rotate">
<span class="sig-name descname"><span class="pre">extrude_rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dradius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">360.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.extrude_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sweep polygonal data creating “skirt” from free edges and lines, and lines from vertices.</p>
<p>This is a modeling filter.</p>
<p>This takes polygonal data as input and generates polygonal
data on output. The input dataset is swept around the z-axis
to create new polygonal primitives. These primitives form a
“skirt” or swept surface. For example, sweeping a line
results in a cylindrical shell, and sweeping a circle
creates a torus.</p>
<p>There are a number of control parameters for this filter.
You can control whether the sweep of a 2D object (i.e.,
polygon or triangle strip) is capped with the generating
geometry via the “Capping” instance variable. Also, you can
control the angle of rotation, and whether translation along
the z-axis is performed along with the rotation.
(Translation is useful for creating “springs”.) You also can
adjust the radius of the generating geometry using the
“DeltaRotation” instance variable.</p>
<p>The skirt is generated by locating certain topological
features. Free edges (edges of polygons or triangle strips
only used by one polygon or triangle strips) generate
surfaces. This is true also of lines or polylines. Vertices
generate lines.</p>
<p>This filter can be used to model axisymmetric objects like
cylinders, bottles, and wine glasses; or translational/
rotational symmetric objects like springs or corkscrews.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of pieces to divide line into.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Overwrites the original mesh inplace.</p></li>
<li><p><strong>translation</strong> (<em>float</em><em>, </em><em>optional</em>) – Total amount of translation along the z-axis.</p></li>
<li><p><strong>dradius</strong> (<em>float</em><em>, </em><em>optional</em>) – Change in radius during sweep process.</p></li>
<li><p><strong>angle</strong> (<em>float</em><em>, </em><em>optional</em>) – The angle of rotation.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">line</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Line</span><span class="p">(</span><span class="n">pointa</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">pointb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">extrude_rotate</span><span class="p">(</span><span class="n">resolution</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.fill_holes">
<span class="sig-name descname"><span class="pre">fill_holes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hole_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill holes in a pyvista.PolyData or vtk.vtkPolyData object.</p>
<p>Holes are identified by locating boundary edges, linking them together
into loops, and then triangulating the resulting loops. Note that you
can specify an approximate limit to the size of the hole that can be
filled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hole_size</strong> (<em>float</em>) – Specifies the maximum hole size to fill. This is represented as a
radius to the bounding circumsphere containing the hole. Note that
this is an approximate area; the actual area cannot be computed
without first triangulating the hole.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return new mesh or overwrite input.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh with holes filled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a partial sphere with a hole and then fill it</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere_with_hole</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">end_theta</span><span class="o">=</span><span class="mi">330</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">sphere_with_hole</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">extract_feature_edges</span><span class="p">(</span><span class="n">feature_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">manifold_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">edges</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.flip_normals">
<span class="sig-name descname"><span class="pre">flip_normals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.flip_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip normals of a triangular mesh by reversing the point ordering.</p>
<p class="rubric">Examples</p>
<p>Flip the normals of a sphere and plot the normals before and
after the flip.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">plot_normals</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span><span class="o">.</span><span class="n">flip_normals</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">plot_normals</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.geodesic">
<span class="sig-name descname"><span class="pre">geodesic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.geodesic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the geodesic path between two vertices using Dijkstra’s algorithm.</p>
<p>This will add an array titled <cite>vtkOriginalPointIds</cite> of the input
mesh’s point ids to the output mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_vertex</strong> (<em>int</em>) – Vertex index indicating the start point of the geodesic segment.</p></li>
<li><p><strong>end_vertex</strong> (<em>int</em>) – Vertex index indicating the end point of the geodesic segment.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>output</strong> – PolyData object consisting of the line segment between the
two given vertices.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the path between two points on a sphere.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">actor</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">sphere</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">actor</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.geodesic_distance">
<span class="sig-name descname"><span class="pre">geodesic_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_vertex</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.geodesic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the geodesic distance between two vertices using Dijkstra’s algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_vertex</strong> (<em>int</em>) – Vertex index indicating the start point of the geodesic segment.</p></li>
<li><p><strong>end_vertex</strong> (<em>int</em>) – Vertex index indicating the end point of the geodesic segment.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>length</strong> – Length of the geodesic segment.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">geodesic_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Length is </span><span class="si">{</span><span class="n">length</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Length is 0.812</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_first</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_second</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the intersection between two meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to intersect with.</p></li>
<li><p><strong>split_first</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, return the first input mesh split by the intersection with the
second input mesh.</p></li>
<li><p><strong>split_second</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, return the second input mesh split by the intersection with the
first input mesh.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intersection</strong> (<em>pyvista.PolyData</em>) – The intersection line.</p></li>
<li><p><strong>first_split</strong> (<em>pyvista.PolyData</em>) – The first mesh split along the intersection. Returns the original first mesh
if <cite>split_first</cite> is False.</p></li>
<li><p><strong>second_split</strong> (<em>pyvista.PolyData</em>) – The second mesh split along the intersection. Returns the original second mesh
if <cite>split_second</cite> is False.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Intersect two spheres, returning the intersection and both spheres
which have new points/cells along the intersection line.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intersection</span><span class="p">,</span> <span class="n">s1_split</span><span class="p">,</span> <span class="n">s2_split</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
</pre></div>
</div>
<p>The mesh splitting takes additional time and can be turned
off for either mesh individually.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">intersection</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">s2_split</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span>                                                         <span class="n">split_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>                                                         <span class="n">split_second</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.multi_ray_trace">
<span class="sig-name descname"><span class="pre">multi_ray_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.multi_ray_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform multiple ray trace calculations.</p>
<p>This requires a mesh with only triangular faces,
an array of origin points and an equal sized array of
direction vectors to trace along.</p>
<p>The embree library used for vectorisation of the ray traces is known to occasionally
return no intersections where the VTK implementation would return an intersection.
If the result appears to be missing some intersection points, set retry=True to run a second pass over rays
that returned no intersections, using the VTK ray_trace implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origins</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Starting point for each trace.</p></li>
<li><p><strong>directions</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Direction vector for each trace.</p></li>
<li><p><strong>first_point</strong> (<em>bool</em><em>, </em><em>optional</em>) – Returns intersection of first point only.</p></li>
<li><p><strong>retry</strong> (<em>bool</em><em>, </em><em>optional</em>) – Will retry rays that return no intersections using the ray_trace</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intersection_points</strong> (<em>np.ndarray</em>) – Location of the intersection points.  Empty array if no
intersections.</p></li>
<li><p><strong>intersection_rays</strong> (<em>np.ndarray</em>) – Indices of the ray for each intersection point. Empty array if no
intersections.</p></li>
<li><p><strong>intersection_cells</strong> (<em>np.ndarray</em>) – Indices of the intersection cells.  Empty array if no
intersections.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the intersection between rays from the origin in
directions <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code> and <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>, and
a sphere with radius 0.5 centered at the origin</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span> 
<span class="gp">... </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">... </span><span class="n">points</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">cells</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">multi_ray_trace</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">first_point</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Rays intersected at </span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Rays intersected at (0.499, 0.000, 0.000), (0.000, 0.497, 0.000), (0.000, 0.000, 0.500)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.plot_boundaries">
<span class="sig-name descname"><span class="pre">plot_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'red'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.plot_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot boundaries of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edge_color</strong> (<em>str</em><em>, </em><em>optional</em>) – The color of the edges when they are added to the plotter.</p></li>
<li><p><strong>kwargs</strong> (<em>optional</em>) – All additional keyword arguments will be passed to
<a class="reference internal" href="../plotting/plotting.html#pyvista.BasePlotter.add_mesh" title="pyvista.BasePlotter.add_mesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.BasePlotter.add_mesh()</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.plot_curvature">
<span class="sig-name descname"><span class="pre">plot_curvature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curv_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.plot_curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the curvature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>curvtype</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>One of the following strings indicating curvature type:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'Mean'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Gaussian'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Maximum'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Minimum'</span></code></p></li>
</ul>
</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – See <a class="reference internal" href="../plotting/plotting.html#pyvista.plot" title="pyvista.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.plot()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cpos</strong> – List of camera position, focal point, and view up.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the mean curvature of an example mesh.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hills</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_random_hills</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">hills</span><span class="o">.</span><span class="n">plot_curvature</span><span class="p">(</span><span class="n">smooth_shading</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.plot_normals">
<span class="sig-name descname"><span class="pre">plot_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">show_mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_every</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.plot_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the point normals of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>show_mesh</strong> (<em>bool</em><em>, </em><em>optional</em>) – Plot the mesh itself.  Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>mag</strong> (<em>float</em><em>, </em><em>optional</em>) – Size magnitude of the normal arrows.  Defaults to 1.0.</p></li>
<li><p><strong>flip</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flip the normal direction when <code class="docutils literal notranslate"><span class="pre">True</span></code>.  Default
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>use_every</strong> (<em>int</em><em>, </em><em>optional</em>) – Display every nth normal.  By default every normal is
displayed.  Display every 10th normal by setting this
parameter to 10.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the normals of a sphere.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">plot_normals</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.project_points_to_plane">
<span class="sig-name descname"><span class="pre">project_points_to_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.project_points_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Project points of this mesh to a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>np.ndarray</em><em> or </em><em>collections.abc.Sequence</em><em>, </em><em>optional</em>) – Plane origin.  Defaults the approximate center of the
input mesh minus half the length of the input mesh in the
direction of the normal.</p></li>
<li><p><strong>normal</strong> (<em>np.ndarray</em><em> or </em><em>collections.abc.Sequence</em><em>, </em><em>optional</em>) – Plane normal.  Defaults to +Z <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code></p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Overwrite the original mesh with the projected points</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Flatten a sphere to the XY plane</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projected</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">project_points_to_plane</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.ray_trace">
<span class="sig-name descname"><span class="pre">ray_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_screen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.ray_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single ray trace calculation.</p>
<p>This requires a mesh and a line segment defined by an origin
and end_point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Start of the line segment.</p></li>
<li><p><strong>end_point</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – End of the line segment.</p></li>
<li><p><strong>first_point</strong> (<em>bool</em><em>, </em><em>optional</em>) – Returns intersection of first point only.</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Plots ray trace results</p></li>
<li><p><strong>off_screen</strong> (<em>bool</em><em>, </em><em>optional</em>) – Plots off screen when <code class="docutils literal notranslate"><span class="pre">plot=True</span></code>.  Used for unit testing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intersection_points</strong> (<em>np.ndarray</em>) – Location of the intersection points.  Empty array if no
intersections.</p></li>
<li><p><strong>intersection_cells</strong> (<em>np.ndarray</em>) – Indices of the intersection cells.  Empty array if no
intersections.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the intersection between a ray from the origin and
[1, 0, 0] and a sphere with radius 0.5 centered at the origin</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span><span class="p">,</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">ray_trace</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">first_point</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Intersected at </span><span class="si">{</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Intersected at 0.499 0.000 0.000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.remove_points">
<span class="sig-name descname"><span class="pre">remove_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">remove</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'any'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.remove_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuild a mesh by removing points.</p>
<p>Only valid for all-triangle meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>remove</strong> (<em>np.ndarray</em>) – If remove is a bool array, points that are <code class="docutils literal notranslate"><span class="pre">True</span></code> will
be removed.  Otherwise, it is treated as a list of
indices.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – When <code class="docutils literal notranslate"><span class="pre">'all'</span></code>, only faces containing all points flagged
for removal will be removed.  Default <code class="docutils literal notranslate"><span class="pre">'any'</span></code>.</p></li>
<li><p><strong>keep_scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – When <code class="docutils literal notranslate"><span class="pre">True</span></code>, point and cell scalars will be passed on to
the new mesh.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.  Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mesh</strong> (<em>pyvista.PolyData</em>) – Mesh without the points flagged for removal.</p></li>
<li><p><strong>ridx</strong> (<em>np.ndarray</em>) – Indices of new points relative to the original mesh.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Remove the first 100 points from a sphere.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduced_sphere</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">remove_points</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.ribbon">
<span class="sig-name descname"><span class="pre">ribbon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tcoords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'points'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.ribbon" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ribbon of the lines in this dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<em>float</em><em>, </em><em>optional</em>) – Set the “half” width of the ribbon. If the width is
allowed to vary, this is the minimum width. The default is
10% the length.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – String name of the scalars array to use to vary the ribbon
width.  This is only used if a scalars array is specified.</p></li>
<li><p><strong>angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Angle in degrees of the offset angle of the ribbon from
the line normal. The default is 0.0.</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Set the maximum ribbon width in terms of a multiple of the
minimum width. The default is 2.0</p></li>
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – Normal to use as default.</p></li>
<li><p><strong>tcoords</strong> (<em>bool</em><em>, </em><em>str</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, generate texture coordinates along the
ribbon. This can also be specified to generate the texture
coordinates with either <code class="docutils literal notranslate"><span class="pre">'length'</span></code> or <code class="docutils literal notranslate"><span class="pre">'normalized'</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Convert a line to a ribbon and plot it.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ribbon</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpos</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">sphere</span><span class="p">,</span> <span class="n">ribbon</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>If there are no lines in the input dataset, then the output
will be an empty <code class="docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code> mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.smooth">
<span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relaxation_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust point coordinates using Laplacian smoothing.</p>
<p>The effect is to “relax” the mesh, making the cells better shaped and
the vertices more evenly distributed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_iter</strong> (<em>int</em>) – Number of iterations for Laplacian smoothing.</p></li>
<li><p><strong>relaxation_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Relaxation factor controls the amount of displacement in a single
iteration. Generally a lower relaxation factor and higher number of
iterations is numerically more stable.</p></li>
<li><p><strong>convergence</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for the iteration process. Smaller numbers
result in more smoothing iterations. Range from (0 to 1).</p></li>
<li><p><strong>edge_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Edge angle to control smoothing along edges (either interior or boundary).</p></li>
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Feature angle for sharp edge identification.</p></li>
<li><p><strong>boundary_smoothing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean flag to control smoothing of boundary edges.</p></li>
<li><p><strong>feature_smoothing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean flag to control smoothing of feature edges.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Smoothed mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Smooth the edges of an all triangular cube</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smooth_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">feature_smoothing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_edge_cells</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">extract_feature_edges</span><span class="p">()</span><span class="o">.</span><span class="n">n_cells</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_smooth_cells</span> <span class="o">=</span> <span class="n">smooth_cube</span><span class="o">.</span><span class="n">extract_feature_edges</span><span class="p">()</span><span class="o">.</span><span class="n">n_cells</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sharp Edges on Cube:        </span><span class="si">{</span><span class="n">n_edge_cells</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Sharp Edges on Cube:        384</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sharp Edges on Smooth Cube: </span><span class="si">{</span><span class="n">n_smooth_cells</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">Sharp Edges on Smooth Cube: 12</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.strip">
<span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">join</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_cell_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_cell_ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_point_ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip poly data cells.</p>
<p>Generates triangle strips and/or poly-lines from input
polygons, triangle strips, and lines.</p>
<p>Polygons are assembled into triangle strips only if they are
triangles; other types of polygons are passed through to the
output and not stripped. (Use <code class="docutils literal notranslate"><span class="pre">triangulate</span></code> filter to
triangulate non-triangular polygons prior to running this
filter if you need to strip all the data.) The filter will
pass through (to the output) vertices if they are present in
the input polydata.</p>
<p>Also note that if triangle strips or polylines are defined in
the input they are passed through and not joined nor
extended. (If you wish to strip these use <code class="docutils literal notranslate"><span class="pre">triangulate</span></code>
filter to fragment the input into triangles and lines prior to
running this filter.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>join</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the output polygonal segments will be joined
if they are contiguous. This is useful after slicing a
surface. The default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>max_length</strong> (<em>int</em><em>, </em><em>optional</em>) – Specify the maximum number of triangles in a triangle
strip, and/or the maximum number of lines in a poly-line.</p></li>
<li><p><strong>pass_cell_data</strong> (<em>bool</em><em>, </em><em>optional</em>) – Enable/Disable passing of the CellData in the input to the
output as FieldData. Note the field data is transformed.
Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>pass_cell_ids</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the output polygonal dataset will have a
celldata array that holds the cell index of the original
3D cell that produced each output cell. This is useful for
picking. The default is <code class="docutils literal notranslate"><span class="pre">False</span></code> to conserve memory.</p></li>
<li><p><strong>pass_point_ids</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the output polygonal dataset will have a
pointdata array that holds the point index of the original
vertex that produced each output vertex. This is useful
for picking. The default is <code class="docutils literal notranslate"><span class="pre">False</span></code> to conserve memory.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_airplane</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slc</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">normal</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stripped</span> <span class="o">=</span> <span class="n">slc</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stripped</span><span class="o">.</span><span class="n">n_cells</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.subdivide">
<span class="sig-name descname"><span class="pre">subdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subfilter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase the number of triangles in a single, connected triangular mesh.</p>
<p>Uses one of the following vtk subdivision filters to subdivide a mesh.
vtkButterflySubdivisionFilter
vtkLoopSubdivisionFilter
vtkLinearSubdivisionFilter</p>
<p>Linear subdivision results in the fastest mesh subdivision,
but it does not smooth mesh edges, but rather splits each
triangle into 4 smaller triangles.</p>
<p>Butterfly and loop subdivision perform smoothing when
dividing, and may introduce artifacts into the mesh when
dividing.</p>
<p>Subdivision filter appears to fail for multiple part meshes.
Should be one single mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsub</strong> (<em>int</em>) – Number of subdivisions.  Each subdivision creates 4 new
triangles, so the number of resulting triangles is
<code class="docutils literal notranslate"><span class="pre">nface*4**nsub</span></code> where <code class="docutils literal notranslate"><span class="pre">nface</span></code> is the current number of
faces.</p></li>
<li><p><strong>subfilter</strong> (<em>string</em><em>, </em><em>optional</em>) – Can be one of the following: ‘butterfly’, ‘loop’, ‘linear’.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place. Default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – <code class="docutils literal notranslate"><span class="pre">pyvista</span></code> polydata object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Polydata object</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">examples</span><span class="o">.</span><span class="n">planefile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loop&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, update the mesh in-place.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loop&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.triangulate">
<span class="sig-name descname"><span class="pre">triangulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an all triangle mesh.</p>
<p>More complex polygons will be broken down into tetrahedrals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh containing only triangles.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.PolyDataFilters.tube">
<span class="sig-name descname"><span class="pre">tube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.tube" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a tube around each input line.</p>
<p>The radius of the tube can be set to linearly vary with a scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> (<em>float</em>) – Minimum tube radius (minimum because the tube radius may vary).</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – scalars array by which the radius varies</p></li>
<li><p><strong>capping</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off whether to cap the ends with polygons. Default <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>n_sides</strong> (<em>int</em><em>, </em><em>optional</em>) – Set the number of sides for the tube. Minimum of 3.</p></li>
<li><p><strong>radius_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum tube radius in terms of a multiple of the minimum radius.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – The field preference when searching for the scalars array by name.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Tube-filtered mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Convert a single line to a tube</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">line</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Line</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tube</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">tube</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Line Cells:&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
<span class="go">Line Cells: 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tube Cells:&#39;</span><span class="p">,</span> <span class="n">tube</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
<span class="go">Tube Cells: 22</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="unstructuredgrid-filters">
<h2>UnstructuredGrid Filters<a class="headerlink" href="#unstructuredgrid-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.UnstructuredGridFilters" title="pyvista.UnstructuredGridFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UnstructuredGridFilters</span></code></a> is inherited by
<a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UnstructuredGrid</span></code></a> making all the following filters
available as callable methods directly from any <code class="docutils literal notranslate"><span class="pre">UnstructuredGrid</span></code> mesh.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delaunay_2d</span></code>([tol, alpha, offset, bound, …])</p></td>
<td><p>Apply a delaunay 2D filter along the best fitting plane.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pyvista.UnstructuredGridFilters">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyvista.</span></span><span class="sig-name descname"><span class="pre">UnstructuredGridFilters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.UnstructuredGridFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.core.filters.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.core.filters.DataSetFilters</span></code></a></p>
<p>An internal class to manage filters/algorithms for unstructured grid datasets.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyvista.UnstructuredGridFilters.delaunay_2d">
<span class="sig-name descname"><span class="pre">delaunay_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.UnstructuredGridFilters.delaunay_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a delaunay 2D filter along the best fitting plane.</p>
<p>This extracts the grid’s points and performs the triangulation
on those alone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="uniformgrid-filters">
<h2>UniformGrid Filters<a class="headerlink" href="#uniformgrid-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.UniformGridFilters" title="pyvista.UniformGridFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UniformGridFilters</span></code></a> is inherited by
<a class="reference internal" href="grids.html#pyvista.UniformGrid" title="pyvista.UniformGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UniformGrid</span></code></a> making all the following filters
available as callable methods directly from any <code class="docutils literal notranslate"><span class="pre">UniformGrid</span></code> mesh.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_subset</span></code>(voi[, rate, boundary])</p></td>
<td><p>Select piece (e.g., volume of interest).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian_smooth</span></code>([radius_factor, std_dev, …])</p></td>
<td><p>Smooth the data with a Gaussian kernel.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pyvista.UniformGridFilters">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyvista.</span></span><span class="sig-name descname"><span class="pre">UniformGridFilters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.UniformGridFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.core.filters.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.core.filters.DataSetFilters</span></code></a></p>
<p>An internal class to manage filters/algorithms for uniform grid datasets.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyvista.UniformGridFilters.extract_subset">
<span class="sig-name descname"><span class="pre">extract_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.UniformGridFilters.extract_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Select piece (e.g., volume of interest).</p>
<p>To use this filter set the VOI ivar which are i-j-k min/max indices
that specify a rectangular region in the data. (Note that these are
0-offset.) You can also specify a sampling rate to subsample the
data.</p>
<p>Typical applications of this filter are to extract a slice from a
volume for image processing, subsampling large volumes to reduce data
size, or extracting regions of a volume with interesting data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voi</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em>) – Length 6 iterable of ints: <code class="docutils literal notranslate"><span class="pre">(xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax,</span> <span class="pre">zmin,</span> <span class="pre">zmax)</span></code>.
These bounds specify the volume of interest in i-j-k min/max
indices.</p></li>
<li><p><strong>rate</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em>) – Length 3 iterable of ints: <code class="docutils literal notranslate"><span class="pre">(xrate,</span> <span class="pre">yrate,</span> <span class="pre">zrate)</span></code>.
Default: <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></code></p></li>
<li><p><strong>boundary</strong> (<em>bool</em>) – Control whether to enforce that the “boundary” of the grid is
output in the subsampling process. (This only has effect
when the rate in any direction is not equal to 1). When
this is on, the subsampling will always include the boundary of
the grid even though the sample rate is not an even multiple of
the grid dimensions. (By default this is off.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.UniformGridFilters.gaussian_smooth">
<span class="sig-name descname"><span class="pre">gaussian_smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_dev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'points'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.UniformGridFilters.gaussian_smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth the data with a Gaussian kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius_factor</strong> (<em>float</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – Unitless factor to limit the extent of the kernel.</p></li>
<li><p><strong>std_dev</strong> (<em>float</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – Standard deviation of the kernel in pixel units.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to process. Defaults to currently active scalars.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the preferred array type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="composite-filters">
<h2>Composite Filters<a class="headerlink" href="#composite-filters" title="Permalink to this headline">¶</a></h2>
<p>These are filters that can be applied to composite datasets, i.e.
<a class="reference internal" href="composite.html#pyvista.MultiBlock" title="pyvista.MultiBlock"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.MultiBlock</span></code></a>. The <a class="reference internal" href="#pyvista.CompositeFilters" title="pyvista.CompositeFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.CompositeFilters</span></code></a> class
inherits many but not all of the filters from <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.DataSetFilters</span></code></a>.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_centers</span></code>([vertex])</p></td>
<td><p>Generate points at the center of the cells in this dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_data_to_point_data</span></code>([pass_cell_data])</p></td>
<td><p>Transform cell data into point data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([normal, origin, invert, value, …])</p></td>
<td><p>Clip a dataset by a plane by specifying the origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_box</span></code>([bounds, invert, factor])</p></td>
<td><p>Clip a dataset by a bounding box defined by the bounds.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine</span></code>([merge_points])</p></td>
<td><p>Append all blocks into a single unstructured grid.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cell_sizes</span></code>([length, area, volume, …])</p></td>
<td><p>Compute sizes for 1D (length), 2D (area) and 3D (volume) cells.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elevation</span></code>([low_point, high_point, …])</p></td>
<td><p>Generate scalar values on a dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_all_edges</span></code>([progress_bar])</p></td>
<td><p>Extract all the internal/external edges of the dataset as PolyData.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_geometry</span></code>()</p></td>
<td><p>Combine the geometry of all blocks into a single <code class="docutils literal notranslate"><span class="pre">PolyData</span></code> object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([generate_faces, nested])</p></td>
<td><p>Produce an outline of the full extent for the all blocks in this composite dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline_corners</span></code>([factor, nested])</p></td>
<td><p>Produce an outline of the corners for the all blocks in this composite dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_data_to_cell_data</span></code>([pass_point_data])</p></td>
<td><p>Transform point data into cell data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice</span></code>([normal, origin, generate_triangles, …])</p></td>
<td><p>Slice a dataset by a plane at the specified origin and normal vector orientation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_axis</span></code>([n, axis, tolerance, …])</p></td>
<td><p>Create many slices of the input dataset along a specified axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_line</span></code>(line[, generate_triangles, …])</p></td>
<td><p>Slice a dataset using a polyline/spline as the path.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_orthogonal</span></code>([x, y, z, …])</p></td>
<td><p>Create three orthogonal slices through the dataset on the three cartesian planes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangulate</span></code>([inplace])</p></td>
<td><p>Return an all triangle mesh.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pyvista.CompositeFilters">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pyvista.</span></span><span class="sig-name descname"><span class="pre">CompositeFilters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An internal class to manage filters/algorithms for composite datasets.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.cell_centers">
<span class="sig-name descname"><span class="pre">cell_centers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.cell_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate points at the center of the cells in this dataset.</p>
<p>These points can be used for placing glyphs / vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vertex</strong> (<em>bool</em>) – Enable/disable the generation of vertex cells.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.cell_data_to_point_data">
<span class="sig-name descname"><span class="pre">cell_data_to_point_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_cell_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.cell_data_to_point_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform cell data into point data.</p>
<p>Point data are specified per node and cell data specified within cells.
Optionally, the input point data can be passed through to the output.</p>
<p>The method of transformation is based on averaging the data values of
all cells using a particular point. Optionally, the input cell data can
be passed through to the output as well.</p>
<p>See also: <a class="reference internal" href="#pyvista.DataSetFilters.point_data_to_cell_data" title="pyvista.DataSetFilters.point_data_to_cell_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.point_data_to_cell_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_cell_data</strong> (<em>bool</em>) – If enabled, pass the input cell data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.clip">
<span class="sig-name descname"><span class="pre">clip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_clipped</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a plane by specifying the origin and normal.</p>
<p>If no parameters are given the clip will occur in the center of that dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The center <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> coordinate of the plane on which the clip
occurs. The default is the center of the dataset.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag on whether to flip/invert the clip.</p></li>
<li><p><strong>value</strong> (<em>float</em><em>, </em><em>optional</em>) – Set the clipping value along the normal direction.
The default value is 0.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p></li>
<li><p><strong>return_clipped</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return both unclipped and clipped parts of the dataset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Clipped mesh when <code class="docutils literal notranslate"><span class="pre">return_clipped=False</span></code>,
otherwise a tuple containing the unclipped and clipped datasets.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a> or tuple(<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a>)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Clip a cube along the +X direction.  <code class="docutils literal notranslate"><span class="pre">triangulate</span></code> is used as
the cube is initially composed of quadrilateral faces and
subdivide only works on triangles.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">clip</span><span class="p">()</span>
</pre></div>
</div>
<p>Clip a cube in the +Z direction.  This leaves half a cube
below the XY plane.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.clip_box">
<span class="sig-name descname"><span class="pre">clip_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.35</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.clip_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a bounding box defined by the bounds.</p>
<p>If no bounds are given, a corner of the dataset bounds will be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 6 sequence of floats: (xmin, xmax, ymin, ymax, zmin, zmax).
Length 3 sequence of floats: distances from the min coordinate of
of the input mesh. Single float value: uniform distance from the
min coordinate. Length 12 sequence of length 3 sequence of floats:
a plane collection (normal, center, …).
<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a>: if a poly mesh is passed that represents
a box with 6 faces that all form a standard box, then planes will
be extracted from the box to define the clipping region.</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – If bounds are not given this is the factor along each axis to
extract the default box.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Clip a corner of a cube.  The bounds of a cube are normally
<code class="docutils literal notranslate"><span class="pre">[-0.5,</span> <span class="pre">0.5,</span> <span class="pre">-0.5,</span> <span class="pre">0.5,</span> <span class="pre">-0.5,</span> <span class="pre">0.5]</span></code>, and this removes 1/8 of
the cube’s surface.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clipped_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">clip_box</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.combine">
<span class="sig-name descname"><span class="pre">combine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">merge_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all blocks into a single unstructured grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>merge_points</strong> (<em>bool</em><em>, </em><em>optional</em>) – Merge coincidental points.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.compute_cell_sizes">
<span class="sig-name descname"><span class="pre">compute_cell_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.compute_cell_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sizes for 1D (length), 2D (area) and 3D (volume) cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>bool</em>) – Specify whether or not to compute the length of 1D cells.</p></li>
<li><p><strong>area</strong> (<em>bool</em>) – Specify whether or not to compute the area of 2D cells.</p></li>
<li><p><strong>volume</strong> (<em>bool</em>) – Specify whether or not to compute the volume of 3D cells.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.elevation">
<span class="sig-name descname"><span class="pre">elevation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_active</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.elevation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate scalar values on a dataset.</p>
<p>The scalar values lie within a user specified range, and are
generated by computing a projection of each dataset point onto
a line.  The line can be oriented arbitrarily.  A typical
example is to generate scalars based on elevation or height
above a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The low point of the projection line in 3D space. Default is bottom
center of the dataset. Otherwise pass a length 3 <code class="docutils literal notranslate"><span class="pre">tuple(float)</span></code>.</p></li>
<li><p><strong>high_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The high point of the projection line in 3D space. Default is top
center of the dataset. Otherwise pass a length 3 <code class="docutils literal notranslate"><span class="pre">tuple(float)</span></code>.</p></li>
<li><p><strong>scalar_range</strong> (<em>str</em><em> or </em><em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The scalar range to project to the low and high points on the line
that will be mapped to the dataset. If None given, the values will
be computed from the elevation (Z component) range between the
high and low points. Min and max of a range can be given as a length
2 tuple(float). If <code class="docutils literal notranslate"><span class="pre">str</span></code> name of scalara array present in the
dataset given, the valid range of that array will be used.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When an array name is specified for <code class="docutils literal notranslate"><span class="pre">scalar_range</span></code>, this is the
preferred array type to search for in the dataset.
Must be either ‘point’ or ‘cell’.</p></li>
<li><p><strong>set_active</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean flag on whether or not to set the new <cite>Elevation</cite> scalar
as the active scalars array on the output dataset.</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will create a scalars array named <cite>Elevation</cite> on the point data of
the input dataset and overasdf write an array named <cite>Elevation</cite> if present.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.extract_all_edges">
<span class="sig-name descname"><span class="pre">extract_all_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.extract_all_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all the internal/external edges of the dataset as PolyData.</p>
<p>This produces a full wireframe representation of the input dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar to indicate progress.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.extract_geometry">
<span class="sig-name descname"><span class="pre">extract_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.extract_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the geometry of all blocks into a single <code class="docutils literal notranslate"><span class="pre">PolyData</span></code> object.</p>
<p>Place this filter at the end of a pipeline before a polydata
consumer such as a polydata mapper to extract geometry from all blocks
and append them to one polydata object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.outline">
<span class="sig-name descname"><span class="pre">outline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generate_faces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nested</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce an outline of the full extent for the all blocks in this composite dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generate_faces</strong> (<em>bool</em><em>, </em><em>optional</em>) – Generate solid faces for the box. This is off by default</p></li>
<li><p><strong>nested</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, these creates individual outlines for each nested dataset</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.outline_corners">
<span class="sig-name descname"><span class="pre">outline_corners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nested</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.outline_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce an outline of the corners for the all blocks in this composite dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the relative size of the corners to the length of the
corresponding bounds</p></li>
<li><p><strong>nested</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, these creates individual outlines for each nested dataset</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.point_data_to_cell_data">
<span class="sig-name descname"><span class="pre">point_data_to_cell_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_point_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.point_data_to_cell_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform point data into cell data.</p>
<p>Point data are specified per node and cell data specified within cells.
Optionally, the input point data can be passed through to the output.</p>
<p>See also: <a class="reference internal" href="#pyvista.DataSetFilters.cell_data_to_point_data" title="pyvista.DataSetFilters.cell_data_to_point_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.cell_data_to_point_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_point_data</strong> (<em>bool</em>) – If enabled, pass the input point data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a dataset by a plane at the specified origin and normal vector orientation.</p>
<p>If no origin is specified, the center of the input dataset will be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)`</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – The center (x,y,z) coordinate of the plane on which the slice occurs</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.slice_along_axis">
<span class="sig-name descname"><span class="pre">slice_along_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create many slices of the input dataset along a specified axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of slices to create</p></li>
<li><p><strong>axis</strong> (<em>str</em><em> or </em><em>int</em>) – The axis to generate the slices along. Perpendicular to the slices.
Can be string name (<code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'z'</span></code>) or axis index
(<code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, or <code class="docutils literal notranslate"><span class="pre">2</span></code>).</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – The tolerance to the edge of the dataset bounds to create the slices</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.slice_along_line">
<span class="sig-name descname"><span class="pre">slice_along_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice_along_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a dataset using a polyline/spline as the path.</p>
<p>This also works for lines generated with <a class="reference internal" href="../utilities/geometric.html#pyvista.Line" title="pyvista.Line"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.Line()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – A PolyData object containing one single PolyLine cell.</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.slice_orthogonal">
<span class="sig-name descname"><span class="pre">slice_orthogonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create three orthogonal slices through the dataset on the three cartesian planes.</p>
<p>Yields a MutliBlock dataset of the three slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em>) – The X location of the YZ slice</p></li>
<li><p><strong>y</strong> (<em>float</em>) – The Y location of the XZ slice</p></li>
<li><p><strong>z</strong> (<em>float</em>) – The Z location of the XY slice</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyvista.CompositeFilters.triangulate">
<span class="sig-name descname"><span class="pre">triangulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an all triangle mesh.</p>
<p>More complex polygons will be broken down into triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh containing only triangles.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-140243896-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2017-2021, The PyVista Developers.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>
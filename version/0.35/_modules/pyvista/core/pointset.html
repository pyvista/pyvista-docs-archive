
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyvista.core.pointset &#8212; PyVista 0.35.2 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/no_search_highlight.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/summary.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    <img src="../../../_static/pyvista_logo_sm.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../_static/pyvista_logo_sm.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting-started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../user-guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../examples/index.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../extras/index.html">
  Extras
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        0.35  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/pyvista/core/pointset and {'json_url': 'https://docs.pyvista.org/versions.json', 'version_match': '0.35'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/pyvista/core/pointset.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.pyvista.org/versions.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/pyvista/core/pointset.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 0.35.2 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "0.35") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://slack.pyvista.org" rel="noopener" target="_blank" title="Slack Community"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack Community</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/discussions" rel="noopener" target="_blank" title="Support"><span><i class="fa fa-comment fa-fw"></i></span>
            <label class="sr-only">Support</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/blob/main/CONTRIBUTING.rst" rel="noopener" target="_blank" title="Contributing"><span><i class="fa fa-gavel fa-fw"></i></span>
            <label class="sr-only">Contributing</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://doi.org/10.21105/joss.01450" rel="noopener" target="_blank" title="The Paper"><span><i class="fa fa-file-text fa-fw"></i></span>
            <label class="sr-only">The Paper</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for pyvista.core.pointset</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Sub-classes and wrappers for vtk.vtkPointSet.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pyvista</span>
<span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">_vtk</span>
<span class="kn">from</span> <span class="nn">pyvista.utilities</span> <span class="kn">import</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">,</span> <span class="n">abstract_class</span>
<span class="kn">from</span> <span class="nn">pyvista.utilities.cells</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CellArray</span><span class="p">,</span>
    <span class="n">create_mixed_cells</span><span class="p">,</span>
    <span class="n">generate_cell_offsets</span><span class="p">,</span>
    <span class="n">get_mixed_cells</span><span class="p">,</span>
    <span class="n">numpy_to_idarr</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">..utilities.fileio</span> <span class="kn">import</span> <span class="n">get_ext</span>
<span class="kn">from</span> <span class="nn">.dataset</span> <span class="kn">import</span> <span class="n">DataSet</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">DeprecationError</span><span class="p">,</span> <span class="n">VTKVersionError</span>
<span class="kn">from</span> <span class="nn">.filters</span> <span class="kn">import</span> <span class="n">PolyDataFilters</span><span class="p">,</span> <span class="n">StructuredGridFilters</span><span class="p">,</span> <span class="n">UnstructuredGridFilters</span><span class="p">,</span> <span class="n">_get_output</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="s1">&#39;CRITICAL&#39;</span><span class="p">)</span>
<span class="n">DEFAULT_INPLACE_WARNING</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;You did not specify a value for `inplace` and the default value will &#39;</span>
    <span class="s1">&#39;be changing to `False` in future versions for point-based meshes (e.g., &#39;</span>
    <span class="s1">&#39;`PolyData`). Please make sure you are not assuming this to be an inplace &#39;</span>
    <span class="s1">&#39;operation.&#39;</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">_PointSet</span><span class="p">(</span><span class="n">DataSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PyVista&#39;s equivalent of vtk.vtkPointSet.</span>

<span class="sd">    This holds methods common to PolyData and UnstructuredGrid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_WRITERS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;.xyz&quot;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSimplePointsWriter</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the coordinates for the center of mass of the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars_weight : bool, optional</span>
<span class="sd">            Flag for using the mesh scalars as weights. Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Coordinates for the center of mass.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere(center=(1, 1, 1))</span>
<span class="sd">        &gt;&gt;&gt; mesh.center_of_mass()</span>
<span class="sd">        array([1., 1., 1.])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCenterOfMass</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetUseScalarsAsWeights</span><span class="p">(</span><span class="n">scalars_weight</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alg</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a shallow copy from a different dataset into this one.</span>

<span class="sd">        This method mutates this dataset and returns ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_copy : pyvista.DataSet</span>
<span class="sd">            Data object to perform the shallow copy from.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set default points if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_copy</span><span class="o">.</span><span class="n">GetPoints</span><span class="p">():</span>
            <span class="n">to_copy</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPoints</span><span class="p">())</span>
        <span class="n">DataSet</span><span class="o">.</span><span class="n">shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : sequence</span>
<span class="sd">            Cell indices to be removed.  The array can also be a</span>
<span class="sd">            boolean array of the same size as the number of cells.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to update the mesh in-place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Same type as the input, but with the specified cells</span>
<span class="sd">            removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Remove 20 cells from an unstructured grid.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; hex_mesh = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; removed = hex_mesh.remove_cells(range(10, 20))</span>
<span class="sd">        &gt;&gt;&gt; removed.plot(color=&#39;tan&#39;, show_edges=True, line_width=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">and</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Boolean array size must match the number of cells (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
        <span class="n">ghost_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">ghost_cells</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">DUPLICATECELL</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">target</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">GhostArrayName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">ghost_cells</span>
        <span class="n">target</span><span class="o">.</span><span class="n">RemoveGhostCells</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">points_to_double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the points datatype to double precision.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PointSet</span>
<span class="sd">            Pointset with points in double precision.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This operates in place.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a mesh that has points of the type ``float32`` and</span>
<span class="sd">        convert the points to ``float64``.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; mesh.points.dtype</span>
<span class="sd">        dtype(&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = mesh.points_to_double()</span>
<span class="sd">        &gt;&gt;&gt; mesh.points.dtype</span>
<span class="sd">        dtype(&#39;float64&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># todo: `transform_all_input_vectors` is not handled when modifying inplace</span>
    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz : list or tuple or numpy.ndarray</span>
<span class="sd">            Cartesian values to displace with. Length 3 list, tuple or array.</span>

<span class="sd">        transform_all_input_vectors : bool, optional</span>
<span class="sd">            When ``True``, all input vectors are transformed. Otherwise, only</span>
<span class="sd">            the points, normals and active vectors are transformed. This is</span>
<span class="sd">            only valid when not updating in place.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PointSet</span>
<span class="sd">            Translated pointset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a sphere and translate it by ``(2, 1, 2)``.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; mesh.center</span>
<span class="sd">        [0.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; trans = mesh.translate((2, 1, 2), inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; trans.center</span>
<span class="sd">        [2.0, 1.0, 2.0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="n">transform_all_input_vectors</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz : list or tuple or numpy.ndarray</span>
<span class="sd">            Scale factor in x, y, and z directions. Length 3 list, tuple or</span>
<span class="sd">            array.</span>

<span class="sd">        transform_all_input_vectors : bool, optional</span>
<span class="sd">            When ``True``, all input vectors are transformed. Otherwise, only</span>
<span class="sd">            the points, normals and active vectors are transformed. This is</span>
<span class="sd">            only valid when not updating in place.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PointSet</span>
<span class="sd">            Scaled pointset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``transform_all_input_vectors`` is not handled when modifying inplace.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter(shape=(1, 2))</span>
<span class="sd">        &gt;&gt;&gt; pl.subplot(0, 0)</span>
<span class="sd">        &gt;&gt;&gt; pl.show_axes()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.show_grid()</span>
<span class="sd">        &gt;&gt;&gt; mesh1 = examples.download_teapot()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(mesh1)</span>
<span class="sd">        &gt;&gt;&gt; pl.subplot(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; pl.show_axes()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.show_grid()</span>
<span class="sd">        &gt;&gt;&gt; mesh2 = mesh1.scale([10.0, 10.0, 10.0], inplace=False)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(mesh2)</span>
<span class="sd">        &gt;&gt;&gt; pl.show(cpos=&quot;xy&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="n">transform_all_input_vectors</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
        <span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">flip_x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flip_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.flip_x``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">flip_x</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">flip_y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flip_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.flip_y``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">flip_y</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">flip_z</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flip_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.flip_z``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">flip_z</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">flip_normal</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flip_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.flip_normal``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">flip_normal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">rotate_x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rotate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.rotate_x``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rotate_x</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">rotate_y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rotate_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.rotate_y``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rotate_y</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">rotate_z</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rotate_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.rotate_z``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rotate_z</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">rotate_vector</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rotate_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap ``DataSet.rotate_vector``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated on v0.32.0, estimated removal on v0.35.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">DEFAULT_INPLACE_WARNING</span><span class="p">,</span> <span class="n">PyvistaDeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rotate_vector</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="PointSet"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.PointSet.html#pyvista.PointSet">[docs]</a><span class="k">class</span> <span class="nc">PointSet</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPointSet</span><span class="p">,</span> <span class="n">_PointSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concrete class for storing a set of points.</span>

<span class="sd">    This is a concrete class representing a set of points that specifies the</span>
<span class="sd">    interface for datasets that explicitly use &quot;point&quot; arrays to represent</span>
<span class="sd">    geometry. This class is useful for improving the performance of filters on</span>
<span class="sd">    point clouds, but not plotting.</span>

<span class="sd">    For further details see `VTK: vtkPointSet Details</span>
<span class="sd">    &lt;https://vtk.org/doc/nightly/html/classvtkPointSet.html#details&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : Sequence, optional</span>
<span class="sd">        List, numpy array, or sequence containing point locations. Must be an</span>
<span class="sd">        ``(N, 3)`` array of points.</span>

<span class="sd">    deep : bool, optional</span>
<span class="sd">        Whether to copy the input ``points``, or to create a PointSet from them</span>
<span class="sd">        without copying them.  Setting ``deep=True`` ensures that the original</span>
<span class="sd">        arrays can be modified outside the mesh without affecting the</span>
<span class="sd">        mesh. Default is ``False``.</span>

<span class="sd">    force_float : bool, optional</span>
<span class="sd">        Casts the datatype to ``float32`` if points datatype is non-float.</span>
<span class="sd">        Default ``True``. Set this to ``False`` to allow non-float types,</span>
<span class="sd">        though this may lead to truncation of intermediate floats when</span>
<span class="sd">        transforming datasets.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class requires ``vtk&gt;=9.1.0``. This is an abstract class in</span>
<span class="sd">    ``vtk&lt;9.1.0`` and cannot be instantiated.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a simple point cloud of 10 points from a numpy array.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import pyvista</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; points = rng.random((10, 3))</span>
<span class="sd">    &gt;&gt;&gt; pset = pyvista.PointSet(points)</span>

<span class="sd">    Plot the pointset. Note: this casts to a :class:`pyvista.PolyData`</span>
<span class="sd">    internally when plotting.</span>

<span class="sd">    &gt;&gt;&gt; pset.plot(point_size=10)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a new PointSet object.</span>

<span class="sd">        Wrapping this is necessary for us to show an informative error</span>
<span class="sd">        message when the VTK version is too old, causing PointSet to be</span>
<span class="sd">        an abstract class. Since we inherit the ``__new__()`` method of</span>
<span class="sd">        ``vtk.vtkPointSet``, we would otherwise see a generic error about</span>
<span class="sd">        the class being abstract.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s2">&quot;pyvista.PointSet requires VTK &gt;= 9.1.0&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_float</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the pointset.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">force_float</span><span class="o">=</span><span class="n">force_float</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard str representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="PointSet.cast_to_polydata"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.PointSet.cast_to_polydata.html#pyvista.PointSet.cast_to_polydata">[docs]</a>    <span class="k">def</span> <span class="nf">cast_to_polydata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cast this dataset to polydata.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, optional</span>
<span class="sd">            Whether to copy the pointset points, or to create a PolyData</span>
<span class="sd">            without copying them.  Setting ``deep=True`` ensures that the</span>
<span class="sd">            original arrays can be modified outside the PolyData without</span>
<span class="sd">            affecting the PolyData. Default is ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            PointSet cast to a ``pyvista.PolyData``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pdata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">pdata</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">)</span>  <span class="c1"># update performs deep copy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">pdata</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">pdata</span></div>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">DataSet</span><span class="o">.</span><span class="n">plot</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cast to PolyData and plot.&quot;&quot;&quot;</span>
        <span class="n">pdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast_to_polydata</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pdata</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="PolyData"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.PolyData.html#pyvista.PolyData">[docs]</a><span class="k">class</span> <span class="nc">PolyData</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">,</span> <span class="n">_PointSet</span><span class="p">,</span> <span class="n">PolyDataFilters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset consisting of surface geometry (e.g. vertices, lines, and polygons).</span>

<span class="sd">    Can be initialized in several ways:</span>

<span class="sd">    - Create an empty mesh</span>
<span class="sd">    - Initialize from a vtk.vtkPolyData</span>
<span class="sd">    - Using vertices</span>
<span class="sd">    - Using vertices and faces</span>
<span class="sd">    - From a file</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    var_inp : vtk.vtkPolyData, str, sequence, optional</span>
<span class="sd">        Flexible input type.  Can be a ``vtk.vtkPolyData``, in which case</span>
<span class="sd">        this PolyData object will be copied if ``deep=True`` and will</span>
<span class="sd">        be a shallow copy if ``deep=False``.</span>

<span class="sd">        Also accepts a path, which may be local path as in</span>
<span class="sd">        ``&#39;my_mesh.stl&#39;`` or global path like ``&#39;/tmp/my_mesh.ply&#39;``</span>
<span class="sd">        or ``&#39;C:/Users/user/my_mesh.ply&#39;``.</span>

<span class="sd">        Otherwise, this must be a points array or list containing one</span>
<span class="sd">        or more points.  Each point must have 3 dimensions.</span>

<span class="sd">    faces : sequence, optional</span>
<span class="sd">        Face connectivity array.  Faces must contain padding</span>
<span class="sd">        indicating the number of points in the face.  For example, the</span>
<span class="sd">        two faces ``[10, 11, 12]`` and ``[20, 21, 22, 23]`` will be</span>
<span class="sd">        represented as ``[3, 10, 11, 12, 4, 20, 21, 22, 23]``.  This</span>
<span class="sd">        lets you have an arbitrary number of points per face.</span>

<span class="sd">        When not including the face connectivity array, each point</span>
<span class="sd">        will be assigned to a single vertex.  This is used for point</span>
<span class="sd">        clouds that have no connectivity.</span>

<span class="sd">    n_faces : int, optional</span>
<span class="sd">        Number of faces in the ``faces`` connectivity array.  While</span>
<span class="sd">        optional, setting this speeds up the creation of the</span>
<span class="sd">        ``PolyData``.</span>

<span class="sd">    lines : sequence, optional</span>
<span class="sd">        The line connectivity array.  Like ``faces``, this array</span>
<span class="sd">        requires padding indicating the number of points in a line</span>
<span class="sd">        segment.  For example, the two line segments ``[0, 1]`` and</span>
<span class="sd">        ``[1, 2, 3, 4]`` will be represented as</span>
<span class="sd">        ``[2, 0, 1, 4, 1, 2, 3, 4]``.</span>

<span class="sd">    n_lines : int, optional</span>
<span class="sd">        Number of lines in the ``lines`` connectivity array.  While</span>
<span class="sd">        optional, setting this speeds up the creation of the</span>
<span class="sd">        ``PolyData``.</span>

<span class="sd">    deep : bool, optional</span>
<span class="sd">        Whether to copy the inputs, or to create a mesh from them</span>
<span class="sd">        without copying them.  Setting ``deep=True`` ensures that the</span>
<span class="sd">        original arrays can be modified outside the mesh without</span>
<span class="sd">        affecting the mesh. Default is ``False``.</span>

<span class="sd">    force_ext : str, optional</span>
<span class="sd">        If initializing from a file, force the reader to treat the</span>
<span class="sd">        file as if it had this extension as opposed to the one in the</span>
<span class="sd">        file.</span>

<span class="sd">    force_float : bool, optional</span>
<span class="sd">        Casts the datatype to ``float32`` if points datatype is</span>
<span class="sd">        non-float.  Default ``True``. Set this to ``False`` to allow</span>
<span class="sd">        non-float types, though this may lead to truncation of</span>
<span class="sd">        intermediate floats when transforming datasets.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vtk</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">    &gt;&gt;&gt; import pyvista</span>

<span class="sd">    Create an empty mesh.</span>

<span class="sd">    &gt;&gt;&gt; mesh = pyvista.PolyData()</span>

<span class="sd">    Initialize from a ``vtk.vtkPolyData`` object.</span>

<span class="sd">    &gt;&gt;&gt; vtkobj = vtk.vtkPolyData()</span>
<span class="sd">    &gt;&gt;&gt; mesh = pyvista.PolyData(vtkobj)</span>

<span class="sd">    Initialize from just vertices.</span>

<span class="sd">    &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 0.5, 0], [0, 0.5, 0]])</span>
<span class="sd">    &gt;&gt;&gt; mesh = pyvista.PolyData(vertices)</span>

<span class="sd">    Initialize from vertices and faces.</span>

<span class="sd">    &gt;&gt;&gt; faces = np.hstack([[3, 0, 1, 2], [3, 0, 3, 2]])</span>
<span class="sd">    &gt;&gt;&gt; mesh = pyvista.PolyData(vertices, faces)</span>

<span class="sd">    Initialize from vertices and lines.</span>

<span class="sd">    &gt;&gt;&gt; lines = np.hstack([[2, 0, 1], [2, 1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; mesh = pyvista.PolyData(vertices, lines=lines)</span>

<span class="sd">    Initialize from a filename.</span>

<span class="sd">    &gt;&gt;&gt; mesh = pyvista.PolyData(examples.antfile)</span>

<span class="sd">    See :ref:`ref_create_poly` for more examples.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_WRITERS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;.ply&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPLYWriter</span><span class="p">,</span>
        <span class="s1">&#39;.vtp&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkXMLPolyDataWriter</span><span class="p">,</span>
        <span class="s1">&#39;.stl&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSTLWriter</span><span class="p">,</span>
        <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyDataWriter</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">var_inp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">force_ext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_float</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the polydata.&quot;&quot;&quot;</span>
        <span class="n">local_parms</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># allow empty input</span>
        <span class="k">if</span> <span class="n">var_inp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># filename</span>
        <span class="n">opt_kwarg</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;faces&#39;</span><span class="p">,</span> <span class="s1">&#39;n_faces&#39;</span><span class="p">,</span> <span class="s1">&#39;lines&#39;</span><span class="p">,</span> <span class="s1">&#39;n_lines&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_inp</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">opt_kwarg</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">local_parms</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;No other arguments should be set when first parameter is a string&#39;</span>
                    <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_file</span><span class="p">(</span><span class="n">var_inp</span><span class="p">,</span> <span class="n">force_ext</span><span class="o">=</span><span class="n">force_ext</span><span class="p">)</span>  <span class="c1"># is filename</span>

            <span class="k">return</span>

        <span class="c1"># PolyData-like</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_inp</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">opt_kwarg</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">local_parms</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;No other arguments should be set when first parameter is a PolyData&#39;</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">var_inp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shallow_copy</span><span class="p">(</span><span class="n">var_inp</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># First parameter is points</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_inp</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataArray</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_points</span><span class="p">(</span><span class="n">var_inp</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">force_float</span><span class="o">=</span><span class="n">force_float</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                Invalid Input type:</span>

<span class="s2">                Expected first argument to be either a:</span>
<span class="s2">                - vtk.PolyData</span>
<span class="s2">                - pyvista.PolyData</span>
<span class="s2">                - numeric numpy.ndarray (1 or 2 dimensions)</span>
<span class="s2">                - List (flat or nested with 3 points per vertex)</span>
<span class="s2">                - vtk.vtkDataArray</span>

<span class="s2">                Instead got: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">var_inp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">dedent</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)))</span>

        <span class="c1"># At this point, points have been setup, add faces and/or lines</span>
        <span class="k">if</span> <span class="n">faces</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># one cell per point (point cloud case)</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_vertex_cells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verts</span> <span class="o">=</span> <span class="n">CellArray</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># here we use CellArray since we must specify deep and n_faces</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">CellArray</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">n_faces</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>

        <span class="c1"># can always set lines</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># here we use CellArray since we must specify deep and n_lines</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">CellArray</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n_lines</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_post_file_load_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute after loading a PolyData from file.&quot;&quot;&quot;</span>
        <span class="c1"># When loading files with just point arrays, create and</span>
        <span class="c1"># set the polydata vertices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_vertex_cells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verts</span> <span class="o">=</span> <span class="n">CellArray</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard str representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_vertex_cells</span><span class="p">(</span><span class="n">npoints</span><span class="p">):</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">npoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pyvista</span><span class="o">.</span><span class="n">ID_TYPE</span><span class="p">)</span>
        <span class="n">cells</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">cells</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npoints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pyvista</span><span class="o">.</span><span class="n">ID_TYPE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cells</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">verts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the vertex cells.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of vertex cell indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a point cloud polydata and return the vertex cells.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.random.random((5, 3))</span>
<span class="sd">        &gt;&gt;&gt; pdata = pyvista.PolyData(points)</span>
<span class="sd">        &gt;&gt;&gt; pdata.verts</span>
<span class="sd">        array([1, 0, 1, 1, 1, 2, 1, 3, 1, 4])</span>

<span class="sd">        Set vertex cells.  Note how the mesh plots both the surface</span>
<span class="sd">        mesh and the additional vertices in a single plot.</span>

<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Plane(i_resolution=3, j_resolution=3)</span>
<span class="sd">        &gt;&gt;&gt; mesh.verts = np.vstack((np.ones(mesh.n_points, dtype=np.int64),</span>
<span class="sd">        ...                         np.arange(mesh.n_points))).T</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(color=&#39;tan&#39;, render_points_as_spheres=True, point_size=60)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetVerts</span><span class="p">()</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span>

    <span class="nd">@verts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">verts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the vertex cells.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">CellArray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetVerts</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetVerts</span><span class="p">(</span><span class="n">CellArray</span><span class="p">(</span><span class="n">verts</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a pointer to the lines as a numpy array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the lines from a spline.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.random.random((3, 3))</span>
<span class="sd">        &gt;&gt;&gt; spline = pyvista.Spline(points, 10)</span>
<span class="sd">        &gt;&gt;&gt; spline.lines</span>
<span class="sd">        array([10,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetLines</span><span class="p">()</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="nd">@lines</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the lines of the polydata.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">CellArray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetLines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetLines</span><span class="p">(</span><span class="n">CellArray</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a pointer to the faces as a numpy array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of face indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; plane = pv.Plane(i_resolution=2, j_resolution=2)</span>
<span class="sd">        &gt;&gt;&gt; plane.faces</span>
<span class="sd">        array([4, 0, 1, 4, 3, 4, 1, 2, 5, 4, 4, 3, 4, 7, 6, 4, 4, 5, 8, 7])</span>

<span class="sd">        Note how the faces contain a &quot;padding&quot; indicating the number</span>
<span class="sd">        of points per face:</span>

<span class="sd">        &gt;&gt;&gt; plane.faces.reshape(-1, 5)</span>
<span class="sd">        array([[4, 0, 1, 4, 3],</span>
<span class="sd">               [4, 1, 2, 5, 4],</span>
<span class="sd">               [4, 3, 4, 7, 6],</span>
<span class="sd">               [4, 4, 5, 8, 7]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetPolys</span><span class="p">()</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span>

    <span class="nd">@faces</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the face cells.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">CellArray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetPolys</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: faster to mutate in-place if array is same size?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetPolys</span><span class="p">(</span><span class="n">CellArray</span><span class="p">(</span><span class="n">faces</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_all_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return if all the faces of the :class:`pyvista.PolyData` are triangles.</span>

<span class="sd">        .. versionchanged:: 0.32.0</span>
<span class="sd">           ``is_all_triangles`` is now a property.  Calling this value</span>
<span class="sd">           will warn the user that this should not be called.</span>
<span class="sd">           Additionally, the ``is`` operator will not work the return</span>
<span class="sd">           value of this property since it is not a ``bool``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        CallableBool</span>
<span class="sd">            ``True`` if all the faces of the :class:`pyvista.PolyData`</span>
<span class="sd">            are triangles and does not contain any vertices or lines.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The return value is not a ``bool`` for compatibility</span>
<span class="sd">        reasons, though this behavior will change in a future</span>
<span class="sd">        release.  Future versions will simply return a ``bool``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Show a mesh from :func:`pyvista.Plane` is not composed of all</span>
<span class="sd">        triangles.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; plane.is_all_triangles</span>
<span class="sd">        False &lt;CallableBool&gt;</span>

<span class="sd">        Show that the mesh from :func:`pyvista.Sphere` contains only</span>
<span class="sd">        triangles.</span>

<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.is_all_triangles</span>
<span class="sd">        True &lt;CallableBool&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">class</span> <span class="nc">CallableBool</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Boolean that can be called.</span>

<span class="sd">            Programmer note: We must subclass int and not bool</span>
<span class="sd">            https://stackoverflow.com/questions/2172189/why-i-cant-extend-bool-in-python</span>

<span class="sd">            Implemented for backwards compatibility as</span>
<span class="sd">            ``is_all_triangles`` was changed to be a property in</span>
<span class="sd">            ``0.32.0``.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Use new instead of __init__.</span>

<span class="sd">                See:</span>
<span class="sd">                https://jfine-python-classes.readthedocs.io/en/latest/subclass-int.html#emulating-bool-using-new</span>

<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Return a ``bool`` of self.&quot;&quot;&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;``is_all_triangles`` is now property as of 0.32.0 and does not need ()&#39;</span><span class="p">,</span>
                    <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Return the string of bool.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1"> &lt;CallableBool&gt;&#39;</span>

        <span class="c1"># Need to make sure there are only face cells and no lines/verts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_faces</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lines</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_verts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CallableBool</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># in VTK9, they use connectivity and offset rather than cell</span>
        <span class="c1"># data.  Use the new API as this is faster</span>
        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="c1"># early return if not all triangular</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity_array</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CallableBool</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># next, check if there are three points per face</span>
            <span class="k">return</span> <span class="n">CallableBool</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># All we have are faces, check if all faces are indeed triangles</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>  <span class="c1"># grab once as this takes time to build</span>
            <span class="k">if</span> <span class="n">faces</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CallableBool</span><span class="p">((</span><span class="n">faces</span><span class="p">[::</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">CallableBool</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutting_mesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute boolean difference of two meshes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_difference</span><span class="p">(</span><span class="n">cutting_mesh</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_offset_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the array used to store cell offsets.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetPolys</span><span class="p">()</span><span class="o">.</span><span class="n">GetOffsetsArray</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s1">&#39;Offset array implemented in VTK 9 or newer.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_connectivity_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the array with the point ids that define the cells connectivity.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetPolys</span><span class="p">()</span><span class="o">.</span><span class="n">GetConnectivityArray</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s1">&#39;Connectivity array implemented in VTK 9 or newer.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of lines.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Line()</span>
<span class="sd">        &gt;&gt;&gt; mesh.n_lines</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetNumberOfLines</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_verts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of vertices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a simple mesh containing just two points and return the</span>
<span class="sd">        number of vertices.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.PolyData([[1.0, 0.0, 0.0], [1.0, 1.0, 1.0]])</span>
<span class="sd">        &gt;&gt;&gt; mesh.n_verts</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetNumberOfVerts</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of cells.</span>

<span class="sd">        Alias for ``n_cells``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane(i_resolution=2, j_resolution=2)</span>
<span class="sd">        &gt;&gt;&gt; plane.n_faces</span>
<span class="sd">        4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">number_of_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of cells.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">DeprecationError</span><span class="p">(</span><span class="s1">&#39;``number_of_faces`` has been deprecated.  Please use ``n_faces``&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="PolyData.save"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.PolyData.save.html#pyvista.PolyData.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">texture</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a surface mesh to disk.</span>

<span class="sd">        Written file may be an ASCII or binary ply, stl, or vtk mesh</span>
<span class="sd">        file. If ply or stl format is chosen, the face normals are</span>
<span class="sd">        computed in place to ensure the mesh is properly saved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename of mesh to be written.  File type is inferred from</span>
<span class="sd">            the extension of the filename unless overridden with</span>
<span class="sd">            ftype.  Can be one of many of the supported  the following</span>
<span class="sd">            types (``&#39;.ply&#39;``, ``&#39;.stl&#39;``, ``&#39;.vtk``).</span>

<span class="sd">        binary : bool, optional</span>
<span class="sd">            Writes the file as binary when ``True`` and ASCII when ``False``.</span>

<span class="sd">        texture : str, numpy.ndarray, optional</span>
<span class="sd">            Write a single texture array to file when using a PLY</span>
<span class="sd">            file.  Texture array must be a 3 or 4 component array with</span>
<span class="sd">            the datatype ``np.uint8``.  Array may be a cell array or a</span>
<span class="sd">            point array, and may also be a string if the array already</span>
<span class="sd">            exists in the PolyData.</span>

<span class="sd">            If a string is provided, the texture array will be saved</span>
<span class="sd">            to disk as that name.  If an array is provided, the</span>
<span class="sd">            texture array will be saved as ``&#39;RGBA&#39;`` if the array</span>
<span class="sd">            contains an alpha channel (i.e. 4 component array), or</span>
<span class="sd">            as ``&#39;RGB&#39;`` if the array is just a 3 component array.</span>

<span class="sd">            .. note::</span>
<span class="sd">               This feature is only available when saving PLY files.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Binary files write much faster than ASCII and have a smaller</span>
<span class="sd">        file size.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Save a mesh as a STL.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.save(&#39;my_mesh.stl&#39;)  # doctest:+SKIP</span>

<span class="sd">        Save a mesh as a PLY.</span>

<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.save(&#39;my_mesh.ply&#39;)  # doctest:+SKIP</span>

<span class="sd">        Save a mesh as a PLY with a texture array.  Here we also</span>
<span class="sd">        create a simple RGB array representing the texture.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; texture = np.zeros((sphere.n_points, 3), np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; texture[:, 1] = np.arange(sphere.n_points)[::-1]  # just blue channel</span>
<span class="sd">        &gt;&gt;&gt; sphere.point_data[&#39;my_texture&#39;] = texture</span>
<span class="sd">        &gt;&gt;&gt; sphere.save(&#39;my_mesh.ply&#39;, texture=&#39;my_texture&#39;)  # doctest:+SKIP</span>

<span class="sd">        Alternatively, provide just the texture array.  This will be</span>
<span class="sd">        written to the file as ``&#39;RGB&#39;`` since it does not contain an</span>
<span class="sd">        alpha channel.</span>

<span class="sd">        &gt;&gt;&gt; sphere.save(&#39;my_mesh.ply&#39;, texture=texture)  # doctest:+SKIP</span>

<span class="sd">        Save a mesh as a VTK file.</span>

<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.save(&#39;my_mesh.vtk&#39;)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)))</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="n">get_ext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c1"># Recompute normals prior to save.  Corrects a bug were some</span>
        <span class="c1"># triangular meshes are not saved correctly</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.stl&#39;</span><span class="p">,</span> <span class="s1">&#39;.ply&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_normals</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># validate texture</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;.ply&#39;</span> <span class="ow">and</span> <span class="n">texture</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">texture</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Invalid datatype </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">texture</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1"> of texture array &quot;</span><span class="si">{</span><span class="n">texture</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">texture</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid datatype </span><span class="si">{</span><span class="n">texture</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1"> of texture array&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Invalid type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">texture</span><span class="p">)</span><span class="si">}</span><span class="s1"> for texture.  &#39;</span>
                    <span class="s1">&#39;Should be either a string representing a point or &#39;</span>
                    <span class="s1">&#39;cell array, or a numpy array.&#39;</span>
                <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">texture</span><span class="o">=</span><span class="n">texture</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the mesh surface area.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Total area of the mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.area</span>
<span class="sd">        3.126</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_cell_sizes</span><span class="p">(</span>
            <span class="n">length</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">area</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">volume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)[</span><span class="s2">&quot;Area&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the volume of the dataset.</span>

<span class="sd">        This will throw a VTK error/warning if not a closed surface.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Total volume of the mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.volume</span>
<span class="sd">        0.5183</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mprop</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkMassProperties</span><span class="p">()</span>
        <span class="n">mprop</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">triangulate</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">mprop</span><span class="o">.</span><span class="n">GetVolume</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">point_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;pyvista.pyvista_ndarray&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the point normals.</span>

<span class="sd">        If the point data already contains an array named ``&#39;Normals&#39;``, this array will be returned. Otherwise, the</span>
<span class="sd">        normals will be computed using the default options of :func:`PolyData.compute_normals()` and returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.pyvista_ndarray</span>
<span class="sd">            Array of point normals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.point_normals  # doctest:+SKIP</span>
<span class="sd">        pyvista_ndarray([[-2.48721432e-10, -1.08815623e-09, -1.00000000e+00],</span>
<span class="sd">                         [-2.48721432e-10, -1.08815623e-09,  1.00000000e+00],</span>
<span class="sd">                         [-1.18888125e-01,  3.40539310e-03, -9.92901802e-01],</span>
<span class="sd">                         ...,</span>
<span class="sd">                         [-3.11940581e-01, -6.81432486e-02,  9.47654784e-01],</span>
<span class="sd">                         [-2.09880397e-01, -4.65070531e-02,  9.76620376e-01],</span>
<span class="sd">                         [-1.15582108e-01, -2.80492082e-02,  9.92901802e-01]],</span>
<span class="sd">                        dtype=float32)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;Normals&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">:</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_normals</span><span class="p">(</span><span class="n">cell_normals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">normals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;pyvista.pyvista_ndarray&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell normals.</span>

<span class="sd">        If the cell data already contains an array named ``&#39;Normals&#39;``, this array will be returned. Otherwise, the</span>
<span class="sd">        normals will be computed using the default options of :func:`PolyData.compute_normals()` and returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.pyvista_ndarray</span>
<span class="sd">            Array of cell normals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.cell_normals  # doctest:+SKIP</span>
<span class="sd">        pyvista_ndarray([[-0.05413816,  0.00569015, -0.9985172 ],</span>
<span class="sd">                         [-0.05177207,  0.01682176, -0.9985172 ],</span>
<span class="sd">                         [-0.04714328,  0.02721819, -0.9985172 ],</span>
<span class="sd">                         ...,</span>
<span class="sd">                         [-0.26742265, -0.02810723,  0.96316934],</span>
<span class="sd">                         [-0.1617585 , -0.01700151,  0.9866839 ],</span>
<span class="sd">                         [-0.1617585 , -0.01700151,  0.9866839 ]], dtype=float32)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;Normals&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">:</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_normals</span><span class="p">(</span><span class="n">point_normals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;Normals&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">normals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">face_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;pyvista.pyvista_ndarray&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell normals.</span>

<span class="sd">        Alias to :func:`PolyData.cell_normals`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.pyvista_ndarray</span>
<span class="sd">            Array of face normals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.face_normals  # doctest:+SKIP</span>
<span class="sd">        pyvista_ndarray([[-0.05413816,  0.00569015, -0.9985172 ],</span>
<span class="sd">                         [-0.05177207,  0.01682176, -0.9985172 ],</span>
<span class="sd">                         [-0.04714328,  0.02721819, -0.9985172 ],</span>
<span class="sd">                         ...,</span>
<span class="sd">                         [-0.26742265, -0.02810723,  0.96316934],</span>
<span class="sd">                         [-0.1617585 , -0.01700151,  0.9866839 ],</span>
<span class="sd">                         [-0.1617585 , -0.01700151,  0.9866839 ]], dtype=float32)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_normals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obbTree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the obbTree of the polydata.</span>

<span class="sd">        An obbTree is an object to generate oriented bounding box (OBB)</span>
<span class="sd">        trees. An oriented bounding box is a bounding box that does not</span>
<span class="sd">        necessarily line up along coordinate axes. The OBB tree is a</span>
<span class="sd">        hierarchical tree structure of such boxes, where deeper levels of OBB</span>
<span class="sd">        confine smaller regions of space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_obbTree&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obbTree</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkOBBTree</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obbTree</span><span class="o">.</span><span class="n">SetDataSet</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obbTree</span><span class="o">.</span><span class="n">BuildLocator</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obbTree</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_open_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of open edges on this mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the number of open edges on a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.n_open_edges</span>
<span class="sd">        0</span>

<span class="sd">        Return the number of open edges on a plane.</span>

<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane(i_resolution=1, j_resolution=1)</span>
<span class="sd">        &gt;&gt;&gt; plane.n_open_edges</span>
<span class="sd">        4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkFeatureEdges</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">FeatureEdgesOff</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">BoundaryEdgesOn</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">NonManifoldEdgesOn</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">alg</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span><span class="o">.</span><span class="n">GetNumberOfCells</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return if the mesh is manifold (no open edges).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Show a sphere is manifold.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; pyvista.Sphere().is_manifold</span>
<span class="sd">        True</span>

<span class="sd">        Show a plane is not manifold.</span>

<span class="sd">        &gt;&gt;&gt; pyvista.Plane().is_manifold</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_open_edges</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete the object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_obbTree&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obbTree</span></div>


<span class="nd">@abstract_class</span>
<span class="k">class</span> <span class="nc">PointGrid</span><span class="p">(</span><span class="n">_PointSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class in common with structured and unstructured grids.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the point grid.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_curvature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curv_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the curvature of the external surface of the grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curv_type : str, optional</span>
<span class="sd">            One of the following strings indicating curvature types.</span>
<span class="sd">            - ``&#39;mean&#39;``</span>
<span class="sd">            - ``&#39;gaussian&#39;``</span>
<span class="sd">            - ``&#39;maximum&#39;``</span>
<span class="sd">            - ``&#39;minimum&#39;``</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments.  See :func:`pyvista.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Camera position, focal point, and view up.  Returned when</span>
<span class="sd">            ``return_cpos`` is ``True``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trisurf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">trisurf</span><span class="o">.</span><span class="n">plot_curvature</span><span class="p">(</span><span class="n">curv_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the volume of the point grid.</span>

<span class="sd">        This extracts the external surface and computes the interior</span>
<span class="sd">        volume.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">()</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">surf</span><span class="o">.</span><span class="n">volume</span>


<div class="viewcode-block" id="UnstructuredGrid"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.UnstructuredGrid.html#pyvista.UnstructuredGrid">[docs]</a><span class="k">class</span> <span class="nc">UnstructuredGrid</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkUnstructuredGrid</span><span class="p">,</span> <span class="n">PointGrid</span><span class="p">,</span> <span class="n">UnstructuredGridFilters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset used for arbitrary combinations of all possible cell types.</span>

<span class="sd">    Can be initialized by the following:</span>

<span class="sd">    - Creating an empty grid</span>
<span class="sd">    - From a ``vtk.vtkPolyData`` or ``vtk.vtkStructuredGrid`` object</span>
<span class="sd">    - From cell, offset, and node arrays</span>
<span class="sd">    - From a file</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import pyvista</span>
<span class="sd">    &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">    &gt;&gt;&gt; import vtk</span>

<span class="sd">    Create an empty grid</span>

<span class="sd">    &gt;&gt;&gt; grid = pyvista.UnstructuredGrid()</span>

<span class="sd">    Copy a vtkUnstructuredGrid</span>

<span class="sd">    &gt;&gt;&gt; vtkgrid = vtk.vtkUnstructuredGrid()</span>
<span class="sd">    &gt;&gt;&gt; grid = pyvista.UnstructuredGrid(vtkgrid)  # Initialize from a vtkUnstructuredGrid</span>

<span class="sd">    &gt;&gt;&gt; # from arrays (vtk9)</span>
<span class="sd">    &gt;&gt;&gt; #grid = pyvista.UnstructuredGrid(cells, celltypes, points)</span>

<span class="sd">    &gt;&gt;&gt; # from arrays (vtk&lt;9)</span>
<span class="sd">    &gt;&gt;&gt; #grid = pyvista.UnstructuredGrid(offset, cells, celltypes, points)</span>

<span class="sd">    From a string filename</span>

<span class="sd">    &gt;&gt;&gt; grid = pyvista.UnstructuredGrid(examples.hexbeamfile)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_WRITERS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;.vtu&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkXMLUnstructuredGridWriter</span><span class="p">,</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkUnstructuredGridWriter</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the unstructured grid.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">deep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;deep&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkUnstructuredGrid</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shallow_copy</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_file</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStructuredGrid</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">)):</span>
                <span class="n">vtkappend</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkAppendFilter</span><span class="p">()</span>
                <span class="n">vtkappend</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">vtkappend</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shallow_copy</span><span class="p">(</span><span class="n">vtkappend</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">itype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot work with input type </span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Cell dictionary creation</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_cells_dict</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">deep</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_consistency</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># and VTK9:</span>
            <span class="n">arg0_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">arg1_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">arg2_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">arg0_is_arr</span><span class="p">,</span> <span class="n">arg1_is_arr</span><span class="p">,</span> <span class="n">arg2_is_arr</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_consistency</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;All input types must be np.ndarray&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">arg0_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">arg1_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">arg2_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">arg3_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">arg0_is_arr</span><span class="p">,</span> <span class="n">arg1_is_arr</span><span class="p">,</span> <span class="n">arg2_is_arr</span><span class="p">,</span> <span class="n">arg3_is_arr</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">deep</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_consistency</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;All input types must be np.ndarray&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Invalid parameters.  Initialization with arrays &#39;</span>
                <span class="o">+</span> <span class="s1">&#39;requires the following arrays:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">+</span> <span class="s1">&#39;`cells`, `cell_type`, `points`&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">+</span> <span class="s1">&#39;(`offset` optional), `cells`, `cell_type`, `points`&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard str representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_cells_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cells_dict</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points array must be a [M, 3] array&quot;</span><span class="p">)</span>

        <span class="n">nr_points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="n">cell_types</span><span class="p">,</span> <span class="n">cells</span> <span class="o">=</span> <span class="n">create_mixed_cells</span><span class="p">(</span><span class="n">cells_dict</span><span class="p">,</span> <span class="n">nr_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell_types</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">create_mixed_cells</span><span class="p">(</span><span class="n">cells_dict</span><span class="p">,</span> <span class="n">nr_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_arrays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">,</span>
        <span class="n">cell_type</span><span class="p">,</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">force_float</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create VTK unstructured grid from numpy arrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : numpy.ndarray dtype=np.int64</span>
<span class="sd">            Array indicating the start location of each cell in the cells</span>
<span class="sd">            array.  Set to ``None`` when using VTK 9+.</span>

<span class="sd">        cells : numpy.ndarray dtype=np.int64</span>
<span class="sd">            Array of cells.  Each cell contains the number of points in the</span>
<span class="sd">            cell and the node numbers of the cell.</span>

<span class="sd">        cell_type : np.uint8</span>
<span class="sd">            Cell types of each cell.  Each cell type numbers can be found from</span>
<span class="sd">            vtk documentation.  See example below.</span>

<span class="sd">        points : numpy.ndarray</span>
<span class="sd">            Numpy array containing point locations.</span>

<span class="sd">        deep : bool, optional</span>
<span class="sd">            When ``True``, makes a copy of the points array.  Default</span>
<span class="sd">            ``False``.  Cells and cell types are always copied.</span>

<span class="sd">        force_float : bool, optional</span>
<span class="sd">            Casts the datatype to ``float32`` if points datatype is</span>
<span class="sd">            non-float.  Default ``True``. Set this to ``False`` to allow</span>
<span class="sd">            non-float types, though this may lead to truncation of</span>
<span class="sd">            intermediate floats when transforming datasets.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import vtk</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; offset = np.array([0, 9])</span>
<span class="sd">        &gt;&gt;&gt; cells = np.array([8, 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15])</span>
<span class="sd">        &gt;&gt;&gt; cell_type = np.array([vtk.VTK_HEXAHEDRON, vtk.VTK_HEXAHEDRON], np.int8)</span>

<span class="sd">        &gt;&gt;&gt; cell1 = np.array([[0, 0, 0],</span>
<span class="sd">        ...                   [1, 0, 0],</span>
<span class="sd">        ...                   [1, 1, 0],</span>
<span class="sd">        ...                   [0, 1, 0],</span>
<span class="sd">        ...                   [0, 0, 1],</span>
<span class="sd">        ...                   [1, 0, 1],</span>
<span class="sd">        ...                   [1, 1, 1],</span>
<span class="sd">        ...                   [0, 1, 1]], dtype=np.float32)</span>

<span class="sd">        &gt;&gt;&gt; cell2 = np.array([[0, 0, 2],</span>
<span class="sd">        ...                   [1, 0, 2],</span>
<span class="sd">        ...                   [1, 1, 2],</span>
<span class="sd">        ...                   [0, 1, 2],</span>
<span class="sd">        ...                   [0, 0, 3],</span>
<span class="sd">        ...                   [1, 0, 3],</span>
<span class="sd">        ...                   [1, 1, 3],</span>
<span class="sd">        ...                   [0, 1, 3]], dtype=np.float32)</span>

<span class="sd">        &gt;&gt;&gt; points = np.vstack((cell1, cell2))</span>

<span class="sd">        &gt;&gt;&gt; grid = pyvista.UnstructuredGrid(offset, cells, cell_type, points)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert to vtk arrays</span>
        <span class="n">vtkcells</span> <span class="o">=</span> <span class="n">CellArray</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell_type</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="n">cell_type</span> <span class="o">=</span> <span class="n">cell_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">cell_type_np</span> <span class="o">=</span> <span class="n">cell_type</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">numpy_to_vtk</span><span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">deep</span><span class="p">,</span> <span class="n">force_float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># vtk9 does not require an offset array</span>
        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;VTK 9 no longer accepts an offset array&#39;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SetCells</span><span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">vtkcells</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">generate_cell_offsets</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">cell_type_np</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">SetCells</span><span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">numpy_to_idarr</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="n">vtkcells</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_for_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if size of offsets and celltypes match the number of cells.</span>

<span class="sd">        Checks if the number of offsets and celltypes correspond to</span>
<span class="sd">        the number of cells.  Called after initialization of the self</span>
<span class="sd">        from arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">celltypes</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Number of cell types (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">celltypes</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">) &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;must match the number of cells </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Size of the offset (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">) &#39;</span>
                    <span class="s1">&#39;must be one greater than the number of cells &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Size of the offset (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">) &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;must match the number of cells (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a pointer to the cells as a numpy object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the indices of the first two cells from the example hex</span>
<span class="sd">        beam.  Note how the cells have &quot;padding&quot; indicating the number</span>
<span class="sd">        of points per cell.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; hex_beam.cells[:18]  # doctest:+SKIP</span>
<span class="sd">        array([ 8,  0,  2,  8,  7, 27, 36, 90, 81,  8,  2,  1,  4,</span>
<span class="sd">                8, 36, 18, 54, 90])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetCells</span><span class="p">()</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cells_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary that contains all cells mapped from cell types.</span>

<span class="sd">        This function returns a :class:`numpy.ndarray` for each cell</span>
<span class="sd">        type in an ordered fashion.  Note that this function only</span>
<span class="sd">        works with element types of fixed sizes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary mapping containing all cells of this unstructured grid.</span>
<span class="sd">            Structure: vtk_enum_type (int) -&gt; cells (:class:`numpy.ndarray`).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the cells dictionary of the sample hex beam.  Note how</span>
<span class="sd">        there is only one key/value pair as the hex beam example is</span>
<span class="sd">        composed of only all hexahedral cells, which is</span>
<span class="sd">        ``vtk.VTK_HEXAHEDRON``, which evaluates to 12.</span>

<span class="sd">        Also note how there is no padding for the cell array.  This</span>
<span class="sd">        approach may be more helpful than the ``cells`` property when</span>
<span class="sd">        extracting cells.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; hex_beam.cells_dict  # doctest:+SKIP</span>
<span class="sd">        {12: array([[ 0,  2,  8,  7, 27, 36, 90, 81],</span>
<span class="sd">                [ 2,  1,  4,  8, 36, 18, 54, 90],</span>
<span class="sd">                [ 7,  8,  6,  5, 81, 90, 72, 63],</span>
<span class="sd">                ...</span>
<span class="sd">                [44, 26, 62, 98, 11, 10, 13, 17],</span>
<span class="sd">                [89, 98, 80, 71, 16, 17, 15, 14],</span>
<span class="sd">                [98, 62, 53, 80, 17, 13, 12, 15]])}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_mixed_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a the vtk cell connectivity as a numpy array.</span>

<span class="sd">        This is effecively :attr:`UnstructuredGrid.cells` without the</span>
<span class="sd">        padding.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This is only available in ``vtk&gt;=9.0.0``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Connectivity array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the cell connectivity for the first two cells.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; hex_beam.cell_connectivity[:16]</span>
<span class="sd">        array([ 0,  2,  8,  7, 27, 36, 90, 81,  2,  1,  4,  8, 36, 18, 54, 90])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">carr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCells</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">carr</span><span class="o">.</span><span class="n">GetConnectivityArray</span><span class="p">())</span>
        <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span>
            <span class="s1">&#39;Install vtk&gt;=9.0.0 for `cell_connectivity`</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Otherwise, use the legacy `cells` method&#39;</span>
        <span class="p">)</span>  <span class="c1"># pragma: no cover</span>

<div class="viewcode-block" id="UnstructuredGrid.linear_copy"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.UnstructuredGrid.linear_copy.html#pyvista.UnstructuredGrid.linear_copy">[docs]</a>    <span class="k">def</span> <span class="nf">linear_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the unstructured grid containing only linear cells.</span>

<span class="sd">        Converts the following cell types to their linear equivalents.</span>

<span class="sd">        - ``VTK_QUADRATIC_TETRA      --&gt; VTK_TETRA``</span>
<span class="sd">        - ``VTK_QUADRATIC_PYRAMID    --&gt; VTK_PYRAMID``</span>
<span class="sd">        - ``VTK_QUADRATIC_WEDGE      --&gt; VTK_WEDGE``</span>
<span class="sd">        - ``VTK_QUADRATIC_HEXAHEDRON --&gt; VTK_HEXAHEDRON``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool</span>
<span class="sd">            When ``True``, makes a copy of the points array.  Default</span>
<span class="sd">            ``False``.  Cells and cell types are always copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            UnstructuredGrid containing only linear cells when</span>
<span class="sd">            ``deep=False``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="p">)</span>

        <span class="c1"># grab the vtk object</span>
        <span class="n">vtk_cell_type</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">numpy_to_vtk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetCellTypesArray</span><span class="p">(),</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">celltype</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">vtk_cell_type</span><span class="p">)</span>
        <span class="n">celltype</span><span class="p">[</span><span class="n">celltype</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUADRATIC_TETRA</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_TETRA</span>
        <span class="n">celltype</span><span class="p">[</span><span class="n">celltype</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUADRATIC_PYRAMID</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_PYRAMID</span>
        <span class="n">celltype</span><span class="p">[</span><span class="n">celltype</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUADRATIC_WEDGE</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_WEDGE</span>
        <span class="n">celltype</span><span class="p">[</span><span class="n">celltype</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUADRATIC_HEXAHEDRON</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_HEXAHEDRON</span>

        <span class="c1"># track quad mask for later</span>
        <span class="n">quad_quad_mask</span> <span class="o">=</span> <span class="n">celltype</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUADRATIC_QUAD</span>
        <span class="n">celltype</span><span class="p">[</span><span class="n">quad_quad_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUAD</span>

        <span class="n">quad_tri_mask</span> <span class="o">=</span> <span class="n">celltype</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_QUADRATIC_TRIANGLE</span>
        <span class="n">celltype</span><span class="p">[</span><span class="n">quad_tri_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_TRIANGLE</span>

        <span class="n">vtk_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCellLocationsArray</span><span class="p">()</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCellArray</span><span class="p">()</span>
        <span class="n">cells</span><span class="o">.</span><span class="n">DeepCopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetCells</span><span class="p">())</span>
        <span class="n">lgrid</span><span class="o">.</span><span class="n">SetCells</span><span class="p">(</span><span class="n">vtk_cell_type</span><span class="p">,</span> <span class="n">vtk_offset</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>

        <span class="c1"># fixing bug with display of quad cells</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">quad_quad_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
                <span class="n">quad_offset</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">offset</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">quad_quad_mask</span><span class="p">]</span>
                <span class="n">base_point</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">quad_offset</span><span class="p">]</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quad_offset</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">offset</span><span class="p">[</span><span class="n">quad_quad_mask</span><span class="p">]</span>
                <span class="n">base_point</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">quad_offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">quad_tri_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
                <span class="n">tri_offset</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">offset</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">quad_tri_mask</span><span class="p">]</span>
                <span class="n">base_point</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">tri_offset</span><span class="p">]</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cell_connectivity</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tri_offset</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">offset</span><span class="p">[</span><span class="n">quad_tri_mask</span><span class="p">]</span>
                <span class="n">base_point</span> <span class="o">=</span> <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>
                <span class="n">lgrid</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">tri_offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_point</span>

        <span class="k">return</span> <span class="n">lgrid</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">celltypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell types array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of VTK cell types.  Some of the most popular cell types:</span>

<span class="sd">        * ``VTK_EMPTY_CELL = 0``</span>
<span class="sd">        * ``VTK_VERTEX = 1``</span>
<span class="sd">        * ``VTK_POLY_VERTEX = 2``</span>
<span class="sd">        * ``VTK_LINE = 3``</span>
<span class="sd">        * ``VTK_POLY_LINE = 4``</span>
<span class="sd">        * ``VTK_TRIANGLE = 5``</span>
<span class="sd">        * ``VTK_TRIANGLE_STRIP = 6``</span>
<span class="sd">        * ``VTK_POLYGON = 7``</span>
<span class="sd">        * ``VTK_PIXEL = 8``</span>
<span class="sd">        * ``VTK_QUAD = 9``</span>
<span class="sd">        * ``VTK_TETRA = 10``</span>
<span class="sd">        * ``VTK_VOXEL = 11``</span>
<span class="sd">        * ``VTK_HEXAHEDRON = 12``</span>
<span class="sd">        * ``VTK_WEDGE = 13``</span>
<span class="sd">        * ``VTK_PYRAMID = 14``</span>
<span class="sd">        * ``VTK_PENTAGONAL_PRISM = 15``</span>
<span class="sd">        * ``VTK_HEXAGONAL_PRISM = 16``</span>
<span class="sd">        * ``VTK_QUADRATIC_EDGE = 21``</span>
<span class="sd">        * ``VTK_QUADRATIC_TRIANGLE = 22``</span>
<span class="sd">        * ``VTK_QUADRATIC_QUAD = 23``</span>
<span class="sd">        * ``VTK_QUADRATIC_POLYGON = 36``</span>
<span class="sd">        * ``VTK_QUADRATIC_TETRA = 24``</span>
<span class="sd">        * ``VTK_QUADRATIC_HEXAHEDRON = 25``</span>
<span class="sd">        * ``VTK_QUADRATIC_WEDGE = 26``</span>
<span class="sd">        * ``VTK_QUADRATIC_PYRAMID = 27``</span>
<span class="sd">        * ``VTK_BIQUADRATIC_QUAD = 28``</span>
<span class="sd">        * ``VTK_TRIQUADRATIC_HEXAHEDRON = 29``</span>
<span class="sd">        * ``VTK_QUADRATIC_LINEAR_QUAD = 30``</span>
<span class="sd">        * ``VTK_QUADRATIC_LINEAR_WEDGE = 31``</span>
<span class="sd">        * ``VTK_BIQUADRATIC_QUADRATIC_WEDGE = 32``</span>
<span class="sd">        * ``VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON = 33``</span>
<span class="sd">        * ``VTK_BIQUADRATIC_TRIANGLE = 34``</span>

<span class="sd">        See</span>
<span class="sd">        https://vtk.org/doc/nightly/html/vtkCellType_8h_source.html</span>
<span class="sd">        for all cell types.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This mesh contains only linear hexahedral cells, type</span>
<span class="sd">        ``vtk.VTK_HEXAHEDRON``, which evaluates to 12.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; hex_beam.celltypes  # doctest:+SKIP</span>
<span class="sd">        array([12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,</span>
<span class="sd">               12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,</span>
<span class="sd">               12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],</span>
<span class="sd">               dtype=uint8)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetCellTypesArray</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell locations array.</span>

<span class="sd">        In VTK 9, this is the location of the start of each cell in</span>
<span class="sd">        :attr:`cell_connectivity`, and in VTK &lt; 9, this is the</span>
<span class="sd">        location of the start of each cell in :attr:`cells`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of cell offsets indicating the start of each cell.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the cell offset array within ``vtk==9``.  Since this</span>
<span class="sd">        mesh is composed of all hexahedral cells, note how each cell</span>
<span class="sd">        starts at 8 greater than the prior cell.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; hex_beam.offset</span>
<span class="sd">        array([  0,   8,  16,  24,  32,  40,  48,  56,  64,  72,  80,  88,  96,</span>
<span class="sd">               104, 112, 120, 128, 136, 144, 152, 160, 168, 176, 184, 192, 200,</span>
<span class="sd">               208, 216, 224, 232, 240, 248, 256, 264, 272, 280, 288, 296, 304,</span>
<span class="sd">               312, 320])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">carr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCells</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="c1"># This will be the number of cells + 1.</span>
            <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">carr</span><span class="o">.</span><span class="n">GetOffsetsArray</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># this is no longer used in &gt;= VTK9</span>
            <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetCellLocationsArray</span><span class="p">())</span>

<div class="viewcode-block" id="UnstructuredGrid.cast_to_explicit_structured_grid"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.UnstructuredGrid.cast_to_explicit_structured_grid.html#pyvista.UnstructuredGrid.cast_to_explicit_structured_grid">[docs]</a>    <span class="k">def</span> <span class="nf">cast_to_explicit_structured_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cast to an explicit structured grid.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This feature is only available in ``vtk&gt;=9.0.0``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.ExplicitStructuredGrid</span>
<span class="sd">            An explicit structured grid.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the unstructured grid doesn&#39;t have the ``&#39;BLOCK_I&#39;``,</span>
<span class="sd">            ``&#39;BLOCK_J&#39;`` and ``&#39;BLOCK_K&#39;`` cells arrays.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pyvista.ExplicitStructuredGrid.cast_to_unstructured_grid</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(80, 120))</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.cast_to_unstructured_grid()</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.cast_to_explicit_structured_grid()</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s1">&#39;VTK 9 or higher is required&#39;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BLOCK_I&#39;</span><span class="p">,</span> <span class="s1">&#39;BLOCK_J&#39;</span><span class="p">,</span> <span class="s1">&#39;BLOCK_K&#39;</span><span class="p">}</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;BLOCK_I&#39;, &#39;BLOCK_J&#39; and &#39;BLOCK_K&#39; cell arrays are required&quot;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkUnstructuredGridToExplicitStructuredGrid</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;BLOCK_I&#39;</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;BLOCK_J&#39;</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;BLOCK_K&#39;</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;ConnectivityFlags&#39;</span><span class="p">)</span>  <span class="c1"># unrequired</span>
        <span class="k">return</span> <span class="n">grid</span></div></div>


<div class="viewcode-block" id="StructuredGrid"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.StructuredGrid.html#pyvista.StructuredGrid">[docs]</a><span class="k">class</span> <span class="nc">StructuredGrid</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStructuredGrid</span><span class="p">,</span> <span class="n">PointGrid</span><span class="p">,</span> <span class="n">StructuredGridFilters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataset used for topologically regular arrays of data.</span>

<span class="sd">    Can be initialized in one of the following several ways:</span>

<span class="sd">    * Create empty grid.</span>
<span class="sd">    * Initialize from a filename.</span>
<span class="sd">    * Initialize from a ``vtk.vtkStructuredGrid`` object.</span>
<span class="sd">    * Initialize directly from one or more :class:`numpy.ndarray`. See the</span>
<span class="sd">      example or the documentation of ``uinput``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uinput : str, pathlib.Path, vtk.vtkStructuredGrid, numpy.ndarray, optional</span>
<span class="sd">        Filename, dataset, or array to initialize the structured grid from. If</span>
<span class="sd">        a filename is passed, pyvista will attempt to load it as a</span>
<span class="sd">        :class:`StructuredGrid`. If passed a ``vtk.vtkStructuredGrid``, it will</span>
<span class="sd">        be wrapped as a deep copy.</span>

<span class="sd">        If a :class:`numpy.ndarray` is provided and ``y`` and ``z`` are empty,</span>
<span class="sd">        this array will define the points of this :class:`StructuredGrid`.</span>
<span class="sd">        Set the dimensions with :attr:`StructuredGrid.dimensions`.</span>

<span class="sd">        Otherwise, this parameter will be loaded as the ``x`` points, and ``y``</span>
<span class="sd">        and ``z`` points must be set. The shape of this array defines the shape</span>
<span class="sd">        of the structured data and the shape should be ``(dimx, dimy,</span>
<span class="sd">        dimz)``. Missing trailing dimensions are assumed to be ``1``.</span>

<span class="sd">    y : numpy.ndarray, optional</span>
<span class="sd">        Coordinates of the points in y direction. If this is passed, ``uinput``</span>
<span class="sd">        must be a :class:`numpy.ndarray` and match the shape of ``y``.</span>

<span class="sd">    z : numpy.ndarray, optional</span>
<span class="sd">        Coordinates of the points in z direction. If this is passed, ``uinput``</span>
<span class="sd">        and ``y`` must be a :class:`numpy.ndarray` and match the shape of ``z``.</span>

<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Additional keyword arguments passed when reading from a file or loading</span>
<span class="sd">        from arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import pyvista</span>
<span class="sd">    &gt;&gt;&gt; import vtk</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    Create an empty structured grid.</span>

<span class="sd">    &gt;&gt;&gt; grid = pyvista.StructuredGrid()</span>

<span class="sd">    Initialize from a ``vtk.vtkStructuredGrid`` object</span>

<span class="sd">    &gt;&gt;&gt; vtkgrid = vtk.vtkStructuredGrid()</span>
<span class="sd">    &gt;&gt;&gt; grid = pyvista.StructuredGrid(vtkgrid)</span>

<span class="sd">    Create from NumPy arrays.</span>

<span class="sd">    &gt;&gt;&gt; xrng = np.arange(-10, 10, 2, dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; yrng = np.arange(-10, 10, 2, dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; zrng = np.arange(-10, 10, 2, dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; x, y, z = np.meshgrid(xrng, yrng, zrng)</span>
<span class="sd">    &gt;&gt;&gt; grid = pyvista.StructuredGrid(x, y, z)</span>
<span class="sd">    &gt;&gt;&gt; grid  # doctest:+SKIP</span>
<span class="sd">    StructuredGrid (0x7fb18f2a8580)</span>
<span class="sd">    N Cells:    729</span>
<span class="sd">    N Points:   1000</span>
<span class="sd">    X Bounds:   -1.000e+01, 8.000e+00</span>
<span class="sd">    Y Bounds:   -1.000e+01, 8.000e+00</span>
<span class="sd">    Z Bounds:   -1.000e+01, 8.000e+00</span>
<span class="sd">    Dimensions: 10, 10, 10</span>
<span class="sd">    N Arrays:   0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_WRITERS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;.vtk&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStructuredGridWriter</span><span class="p">,</span> <span class="s1">&#39;.vts&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkXMLStructuredGridWriter</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uinput</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the structured grid.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uinput</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStructuredGrid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">uinput</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uinput</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_file</span><span class="p">(</span><span class="n">uinput</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">uinput</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span><span class="n">uinput</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uinput</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">uinput</span>  <span class="c1"># type: ignore</span>
        <span class="k">elif</span> <span class="n">uinput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># do nothing, initialize as empty structured grid</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid parameters. Expecting one of the following:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot; - No arguments</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot; - Filename as the only argument</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot; - StructuredGrid as the only argument</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot; - Single `numpy.ndarray` as the only argument&quot;</span>
                <span class="s2">&quot; - Three `numpy.ndarray` as the first three arguments&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard str representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">force_float</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create VTK structured grid directly from numpy arrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numpy.ndarray</span>
<span class="sd">            Position of the points in x direction.</span>

<span class="sd">        y : numpy.ndarray</span>
<span class="sd">            Position of the points in y direction.</span>

<span class="sd">        z : numpy.ndarray</span>
<span class="sd">            Position of the points in z direction.</span>

<span class="sd">        force_float : bool, optional</span>
<span class="sd">            Casts the datatype to ``float32`` if points datatype is</span>
<span class="sd">            non-float.  Default ``True``. Set this to ``False`` to allow</span>
<span class="sd">            non-float types, though this may lead to truncation of</span>
<span class="sd">            intermediate floats when transforming datasets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input point array shapes must match exactly&#39;</span><span class="p">)</span>

        <span class="c1"># make the output points the same precision as the input arrays</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="c1"># ensure that the inputs are 3D</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create structured grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetDimensions</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">force_float</span><span class="o">=</span><span class="n">force_float</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a length 3 tuple of the grid&#39;s dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Grid dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; xrng = np.arange(-10, 10, 1, dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; yrng = np.arange(-10, 10, 2, dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; zrng = np.arange(-10, 10, 5, dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = np.meshgrid(xrng, yrng, zrng)</span>
<span class="sd">        &gt;&gt;&gt; grid = pyvista.StructuredGrid(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; grid.dimensions</span>
<span class="sd">        (10, 20, 4)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetDimensions</span><span class="p">())</span>

    <span class="nd">@dimensions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the dataset dimensions. Pass a length three tuple of integers.&quot;&quot;&quot;</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetDimensions</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Modified</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the X coordinates of all points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Numpy array of all X coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; xrng = np.arange(-10, 10, 1, dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; yrng = np.arange(-10, 10, 2, dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; zrng = np.arange(-10, 10, 5, dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = np.meshgrid(xrng, yrng, zrng)</span>
<span class="sd">        &gt;&gt;&gt; grid = pyvista.StructuredGrid(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; grid.x.shape</span>
<span class="sd">        (10, 20, 4)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_point_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Y coordinates of all points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_point_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Z coordinates of all points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_point_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Points as a 4-D matrix, with x/y/z along the last dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the representation methods (internal helper).&quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">PointGrid</span><span class="o">.</span><span class="n">_get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;Dimensions&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{:d}</span><span class="s2">, </span><span class="si">{:d}</span><span class="s2">, </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slice subsets of the StructuredGrid, or extract an array field.&quot;&quot;&quot;</span>
        <span class="c1"># legacy behavior which looks for a point or cell array</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># convert slice to VOI specification - only &quot;basic indexing&quot; is supported</span>
        <span class="n">voi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Slices must have exactly 3 dimensions.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Fancy indexing is not supported.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">step</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">voi</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
            <span class="n">rate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subset</span><span class="p">(</span><span class="n">voi</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="StructuredGrid.hide_cells"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.StructuredGrid.hide_cells.html#pyvista.StructuredGrid.hide_cells">[docs]</a>    <span class="k">def</span> <span class="nf">hide_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hide cells without deleting them.</span>

<span class="sd">        Hides cells by setting the ghost_cells array to ``HIDDEN_CELL``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : sequence</span>
<span class="sd">            List or array of cell indices to be hidden.  The array can</span>
<span class="sd">            also be a boolean array of the same size as the number of</span>
<span class="sd">            cells.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.StructuredGrid</span>
<span class="sd">            Structured grid with hidden cells.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Hide part of the middle of a structured surface.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.arange(-10, 10, 0.25)</span>
<span class="sd">        &gt;&gt;&gt; y = np.arange(-10, 10, 0.25)</span>
<span class="sd">        &gt;&gt;&gt; z = 0</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = np.meshgrid(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; grid = pv.StructuredGrid(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(79*30, 79*50))</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=True, show_edges=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">hide_cells</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">and</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Boolean array size must match the number of cells (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
        <span class="n">ghost_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">ghost_cells</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">HIDDENCELL</span>

        <span class="c1"># NOTE: cells cannot be removed from a structured grid, only</span>
        <span class="c1"># hidden setting ghost_cells to a value besides</span>
        <span class="c1"># vtk.vtkDataSetAttributes.HIDDENCELL will not hide them</span>
        <span class="c1"># properly, additionally, calling self.RemoveGhostCells will</span>
        <span class="c1"># have no effect</span>

        <span class="c1"># add but do not make active</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">ghost_cells</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">GhostArrayName</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="StructuredGrid.hide_points"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.StructuredGrid.hide_points.html#pyvista.StructuredGrid.hide_points">[docs]</a>    <span class="k">def</span> <span class="nf">hide_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hide points without deleting them.</span>

<span class="sd">        Hides points by setting the ghost_points array to ``HIDDEN_CELL``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : sequence</span>
<span class="sd">            List or array of point indices to be hidden.  The array</span>
<span class="sd">            can also be a boolean array of the same size as the number</span>
<span class="sd">            of points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PointSet</span>
<span class="sd">            Point set with hidden points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Hide part of the middle of a structured surface.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.arange(-10, 10, 0.25)</span>
<span class="sd">        &gt;&gt;&gt; y = np.arange(-10, 10, 0.25)</span>
<span class="sd">        &gt;&gt;&gt; z = 0</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = np.meshgrid(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; grid = pv.StructuredGrid(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; grid.hide_points(range(80*30, 80*50))</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=True, show_edges=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">and</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Boolean array size must match the number of points (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
        <span class="n">ghost_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">ghost_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">HIDDENPOINT</span>

        <span class="c1"># add but do not make active</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">ghost_points</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">GhostArrayName</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_reshape_point_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reshape point data to a 3-D matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reshape_cell_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reshape cell data to a 3-D matrix.&quot;&quot;&quot;</span>
        <span class="n">cell_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">cell_dims</span><span class="p">[</span><span class="n">cell_dims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cell_dims</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ExplicitStructuredGrid"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.html#pyvista.ExplicitStructuredGrid">[docs]</a><span class="k">class</span> <span class="nc">ExplicitStructuredGrid</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkExplicitStructuredGrid</span><span class="p">,</span> <span class="n">PointGrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extend the functionality of the ``vtk.vtkExplicitStructuredGrid`` class.</span>

<span class="sd">    Can be initialized by the following:</span>

<span class="sd">    - Creating an empty grid</span>
<span class="sd">    - From a ``vtk.vtkExplicitStructuredGrid`` or ``vtk.vtkUnstructuredGrid`` object</span>
<span class="sd">    - From a VTU or VTK file</span>
<span class="sd">    - From ``dims`` and ``corners`` arrays</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # grid size: ni*nj*nk cells; si, sj, sk steps</span>
<span class="sd">    &gt;&gt;&gt; ni, nj, nk = 4, 5, 6</span>
<span class="sd">    &gt;&gt;&gt; si, sj, sk = 20, 10, 1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # create raw coordinate grid</span>
<span class="sd">    &gt;&gt;&gt; grid_ijk = np.mgrid[:(ni+1)*si:si, :(nj+1)*sj:sj, :(nk+1)*sk:sk]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # repeat array along each Cartesian axis for connectivity</span>
<span class="sd">    &gt;&gt;&gt; for axis in range(1, 4):</span>
<span class="sd">    ...     grid_ijk = grid_ijk.repeat(2, axis=axis)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # slice off unnecessarily doubled edge coordinates</span>
<span class="sd">    &gt;&gt;&gt; grid_ijk = grid_ijk[:, 1:-1, 1:-1, 1:-1]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # reorder and reshape to VTK order</span>
<span class="sd">    &gt;&gt;&gt; corners = grid_ijk.transpose().reshape(-1, 3)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dims = np.array([ni, nj, nk]) + 1</span>
<span class="sd">    &gt;&gt;&gt; grid = pv.ExplicitStructuredGrid(dims, corners)</span>
<span class="sd">    &gt;&gt;&gt; grid = grid.compute_connectivity()</span>
<span class="sd">    &gt;&gt;&gt; grid.plot(show_edges=True)  # doctest:+SKIP</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_WRITERS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;.vtu&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkXMLUnstructuredGridWriter</span><span class="p">,</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkUnstructuredGridWriter</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the explicit structured grid.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s1">&#39;VTK 9 or higher is required&#39;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arg0</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkExplicitStructuredGrid</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkUnstructuredGrid</span><span class="p">):</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">arg0</span><span class="o">.</span><span class="n">cast_to_explicit_structured_grid</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cast_to_explicit_structured_grid</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">arg0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">arg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span>
            <span class="n">arg0_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">arg1_is_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">arg0_is_arr</span><span class="p">,</span> <span class="n">arg1_is_arr</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the standard ``str`` representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSet</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_from_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">corners</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a VTK explicit structured grid from NumPy arrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims : Sequence</span>
<span class="sd">            A sequence of integers with shape (3,) containing the</span>
<span class="sd">            topological dimensions of the grid.</span>

<span class="sd">        corners : Sequence</span>
<span class="sd">            A sequence of floats with shape (number of corners, 3)</span>
<span class="sd">            containing the coordinates of the corner points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">shape1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">shape0</span>
        <span class="n">ncells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shape0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">connectivity</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">cinds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">shape1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">cells</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">cinds</span><span class="p">]</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">CellArray</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">ncells</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetDimensions</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetCells</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

<div class="viewcode-block" id="ExplicitStructuredGrid.cast_to_unstructured_grid"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.cast_to_unstructured_grid.html#pyvista.ExplicitStructuredGrid.cast_to_unstructured_grid">[docs]</a>    <span class="k">def</span> <span class="nf">cast_to_unstructured_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;UnstructuredGrid&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cast to an unstructured grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UnstructuredGrid</span>
<span class="sd">            An unstructured grid. VTK adds the ``&#39;BLOCK_I&#39;``,</span>
<span class="sd">            ``&#39;BLOCK_J&#39;`` and ``&#39;BLOCK_K&#39;`` cell arrays. These arrays</span>
<span class="sd">            are required to restore the explicit structured grid.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pyvista.DataSetFilters.extract_cells : Extract a subset of a dataset.</span>
<span class="sd">        pyvista.UnstructuredGrid.cast_to_explicit_structured_grid : Cast an unstructured grid to an explicit structured grid.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The ghost cell array is disabled before casting the</span>
<span class="sd">        unstructured grid in order to allow the original structure</span>
<span class="sd">        and attributes data of the explicit structured grid to be</span>
<span class="sd">        restored. If you don&#39;t need to restore the explicit</span>
<span class="sd">        structured grid later or want to extract an unstructured</span>
<span class="sd">        grid from the visible subgrid, use the ``extract_cells``</span>
<span class="sd">        filter and the cell indices where the ghost cell array is</span>
<span class="sd">        ``0``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)  # doctest:+SKIP</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(80, 120))  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)  # doctest:+SKIP</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.cast_to_unstructured_grid()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)  # doctest:+SKIP</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.cast_to_explicit_structured_grid()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">ExplicitStructuredGrid</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">copy_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkExplicitStructuredGridToUnstructuredGrid</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;vtkOriginalCellIds&#39;</span><span class="p">)</span>  <span class="c1"># unrequired</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">copy_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># copy ghost cell array and other arrays</span>
        <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.save"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.save.html#pyvista.ExplicitStructuredGrid.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save this VTK object to file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Output file name. VTU and VTK extensions are supported.</span>
<span class="sd">        binary : bool, optional</span>
<span class="sd">            If ``True`` (default), write as binary, else ASCII.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        VTK adds the ``&#39;BLOCK_I&#39;``, ``&#39;BLOCK_J&#39;`` and ``&#39;BLOCK_K&#39;``</span>
<span class="sd">        cell arrays. These arrays are required to restore the explicit</span>
<span class="sd">        structured grid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(80, 120))  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.save(&#39;grid.vtu&#39;)  # doctest:+SKIP</span>

<span class="sd">        &gt;&gt;&gt; grid = pv.ExplicitStructuredGrid(&#39;grid.vtu&#39;)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)  # doctest:+SKIP</span>

<span class="sd">        &gt;&gt;&gt; grid.show_cells()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast_to_unstructured_grid</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">binary</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.hide_cells"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.hide_cells.html#pyvista.ExplicitStructuredGrid.hide_cells">[docs]</a>    <span class="k">def</span> <span class="nf">hide_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ExplicitStructuredGrid&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hide specific cells.</span>

<span class="sd">        Hides cells by setting the ghost cell array to ``HIDDENCELL``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : sequence(int)</span>
<span class="sd">            Cell indices to be hidden. A boolean array of the same</span>
<span class="sd">            size as the number of cells also is acceptable.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            This method is applied to this grid if ``True`` (default)</span>
<span class="sd">            or to a copy otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExplicitStructuredGrid or None</span>
<span class="sd">            A deep copy of this grid if ``inplace=False`` with the</span>
<span class="sd">            hidden cells, or this grid with the hidden cells if</span>
<span class="sd">            otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(80, 120))</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">array</span><span class="p">[</span><span class="n">ind_arr</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">HIDDENCELL</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">GhostArrayName</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">hide_cells</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.show_cells"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.show_cells.html#pyvista.ExplicitStructuredGrid.show_cells">[docs]</a>    <span class="k">def</span> <span class="nf">show_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ExplicitStructuredGrid&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show hidden cells.</span>

<span class="sd">        Shows hidden cells by setting the ghost cell array to ``0``</span>
<span class="sd">        where ``HIDDENCELL``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            This method is applied to this grid if ``True`` (default)</span>
<span class="sd">            or to a copy otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExplicitStructuredGrid</span>
<span class="sd">            A deep copy of this grid if ``inplace=False`` with the</span>
<span class="sd">            hidden cells shown.  Otherwise, this dataset with the</span>
<span class="sd">            shown cells.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(80, 120))</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &gt;&gt;&gt; grid = grid.show_cells()</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(color=&#39;w&#39;, show_edges=True, show_bounds=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">GhostArrayName</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">array</span> <span class="o">==</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">HIDDENCELL</span><span class="p">)</span>
                <span class="n">array</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">show_cells</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid</span></div>

    <span class="k">def</span> <span class="nf">_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This method is required to avoid conflict if a developer extends `ExplicitStructuredGrid`</span>
        <span class="c1"># and reimplements `dimensions` to return, for example, the number of cells in the I, J and</span>
        <span class="c1"># K directions.</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetExtent</span><span class="p">()</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the topological dimensions of the grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(int)</span>
<span class="sd">            Number of sampling points in the I, J and Z directions respectively.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.dimensions  # doctest:+SKIP</span>
<span class="sd">        (5, 6, 7)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">visible_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bounding box of the visible cells.</span>

<span class="sd">        Different from `bounds`, which returns the bounding box of the</span>
<span class="sd">        complete grid, this method returns the bounding box of the</span>
<span class="sd">        visible cells, where the ghost cell array is not</span>
<span class="sd">        ``HIDDENCELL``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(float)</span>
<span class="sd">            The limits of the visible grid in the X, Y and Z</span>
<span class="sd">            directions respectively.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.hide_cells(range(80, 120))  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.bounds  # doctest:+SKIP</span>
<span class="sd">        [0.0, 80.0, 0.0, 50.0, 0.0, 6.0]</span>

<span class="sd">        &gt;&gt;&gt; grid.visible_bounds  # doctest:+SKIP</span>
<span class="sd">        [0.0, 80.0, 0.0, 50.0, 0.0, 4.0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetAttributes</span><span class="o">.</span><span class="n">GhostArrayName</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_cells</span><span class="p">(</span><span class="n">array</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>

<div class="viewcode-block" id="ExplicitStructuredGrid.cell_id"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.cell_id.html#pyvista.ExplicitStructuredGrid.cell_id">[docs]</a>    <span class="k">def</span> <span class="nf">cell_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell ID.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : tuple(int), list(tuple(int)) or numpy.ndarray</span>
<span class="sd">            Cell structured coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int, numpy.ndarray, or None</span>
<span class="sd">            Cell IDs. ``None`` if ``coords`` is outside the grid extent.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pyvista.ExplicitStructuredGrid.cell_coords : Return the cell structured coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.cell_id((3, 4, 0))  # doctest:+SKIP</span>
<span class="sd">        19</span>

<span class="sd">        &gt;&gt;&gt; coords = [(3, 4, 0),</span>
<span class="sd">        ...           (3, 2, 1),</span>
<span class="sd">        ...           (1, 0, 2),</span>
<span class="sd">        ...           (2, 3, 2)]</span>
<span class="sd">        &gt;&gt;&gt; grid.cell_id(coords)  # doctest:+SKIP</span>
<span class="sd">        array([19, 31, 41, 54])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># `vtk.vtkExplicitStructuredGrid.ComputeCellId` is not used</span>
        <span class="c1"># here because this method returns invalid cell IDs when</span>
        <span class="c1"># `coords` is outside the grid extent.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.cell_coords"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.cell_coords.html#pyvista.ExplicitStructuredGrid.cell_coords">[docs]</a>    <span class="k">def</span> <span class="nf">cell_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell structured coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : int or iterable(int)</span>
<span class="sd">            Cell IDs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(int), numpy.ndarray, or None</span>
<span class="sd">            Cell structured coordinates. ``None`` if ``ind`` is</span>
<span class="sd">            outside the grid extent.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pyvista.ExplicitStructuredGrid.cell_id : Return the cell ID.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.cell_coords(19)  # doctest:+SKIP</span>
<span class="sd">        (3, 4, 0)</span>

<span class="sd">        &gt;&gt;&gt; grid.cell_coords((19, 31, 41, 54))  # doctest:+SKIP</span>
<span class="sd">        array([[3, 4, 0],</span>
<span class="sd">               [3, 2, 1],</span>
<span class="sd">               [1, 0, 2],</span>
<span class="sd">               [2, 3, 2]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.neighbors"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.neighbors.html#pyvista.ExplicitStructuredGrid.neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">rel</span><span class="o">=</span><span class="s1">&#39;connectivity&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the indices of neighboring cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : int or iterable(int)</span>
<span class="sd">            Cell IDs.</span>

<span class="sd">        rel : str, optional</span>
<span class="sd">            Defines the neighborhood relationship. If</span>
<span class="sd">            ``&#39;topological&#39;``, returns the ``(i-1, j, k)``, ``(i+1, j,</span>
<span class="sd">            k)``, ``(i, j-1, k)``, ``(i, j+1, k)``, ``(i, j, k-1)``</span>
<span class="sd">            and ``(i, j, k+1)`` cells. If ``&#39;connectivity&#39;``</span>
<span class="sd">            (default), returns only the topological neighbors</span>
<span class="sd">            considering faces connectivity. If ``&#39;geometric&#39;``,</span>
<span class="sd">            returns the cells in the ``(i-1, j)``, ``(i+1, j)``,</span>
<span class="sd">            ``(i,j-1)`` and ``(i, j+1)`` vertical cell groups whose</span>
<span class="sd">            faces intersect.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list(int)</span>
<span class="sd">            Indices of neighboring cells.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; cell = grid.extract_cells(31)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; ind = grid.neighbors(31)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; neighbors = grid.extract_cells(ind)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; plotter = pv.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; plotter.add_axes()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; plotter.add_mesh(cell, color=&#39;r&#39;, show_edges=True)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; plotter.add_mesh(neighbors, color=&#39;w&#39;, show_edges=True)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; plotter.show()  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">connectivity</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cell_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_coords</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">cell_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_points</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cell_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cell_coords</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_id</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ind</span><span class="p">:</span>
                        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_points</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                            <span class="n">a1</span> <span class="o">=</span> <span class="n">cell_points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
                            <span class="n">a2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">:]</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
                                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">indices</span>

        <span class="k">def</span> <span class="nf">topological</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cell_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_coords</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">cell_neighbors</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cell_neighbors</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cell_coords</span><span class="p">,</span> <span class="n">n</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_id</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ind</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">indices</span>

        <span class="k">def</span> <span class="nf">geometric</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cell_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_coords</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">cell_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_points</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cell_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cell_coords</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_id</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ind</span><span class="p">:</span>
                        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
                <span class="p">]</span>
                <span class="n">nk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                    <span class="n">cell_z</span> <span class="o">=</span> <span class="n">cell_points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="n">cell_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cell_z</span><span class="p">)</span>
                    <span class="n">cell_z</span> <span class="o">=</span> <span class="n">cell_z</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">cell_zmin</span> <span class="o">=</span> <span class="n">cell_z</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">cell_zmax</span> <span class="o">=</span> <span class="n">cell_z</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cell_coords</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                        <span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_id</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ind</span><span class="p">:</span>
                            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_points</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                                <span class="n">z</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">]</span>
                                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                                <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                                <span class="n">zmin</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                <span class="n">zmax</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                <span class="k">if</span> <span class="p">(</span>
                                    <span class="p">(</span><span class="n">zmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cell_zmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">zmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell_zmax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                    <span class="ow">or</span> <span class="p">(</span><span class="n">zmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cell_zmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">zmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell_zmax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                    <span class="ow">or</span> <span class="p">(</span><span class="n">zmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cell_zmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">zmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell_zmin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                    <span class="ow">or</span> <span class="p">(</span><span class="n">zmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cell_zmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">zmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell_zmin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                <span class="p">):</span>
                                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">indices</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">rel</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rel</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.compute_connectivity"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.compute_connectivity.html#pyvista.ExplicitStructuredGrid.compute_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ExplicitStructuredGrid&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the faces connectivity flags array.</span>

<span class="sd">        This method checks the faces connectivity of the cells with</span>
<span class="sd">        their topological neighbors.  The result is stored in the</span>
<span class="sd">        array of integers ``&#39;ConnectivityFlags&#39;``. Each value in this</span>
<span class="sd">        array must be interpreted as a binary number, where the digits</span>
<span class="sd">        shows the faces connectivity of a cell with its topological</span>
<span class="sd">        neighbors -Z, +Z, -Y, +Y, -X and +X respectively. For example,</span>
<span class="sd">        a cell with ``&#39;ConnectivityFlags&#39;`` equal to ``27``</span>
<span class="sd">        (``011011``) indicates that this cell is connected by faces</span>
<span class="sd">        with their neighbors ``(0, 0, 1)``, ``(0, -1, 0)``,</span>
<span class="sd">        ``(-1, 0, 0)`` and ``(1, 0, 0)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            This method is applied to this grid if ``True`` (default)</span>
<span class="sd">            or to a copy otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExplicitStructuredGrid</span>
<span class="sd">            A deep copy of this grid if ``inplace=False``, or this</span>
<span class="sd">            DataSet if otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ExplicitStructuredGrid.compute_connections : Compute an array with the number of connected cell faces.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.compute_connectivity()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(show_edges=True)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ComputeFacesConnectivityFlagsArray</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">compute_connectivity</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="ExplicitStructuredGrid.compute_connections"><a class="viewcode-back" href="../../../api/core/_autosummary/pyvista.ExplicitStructuredGrid.compute_connections.html#pyvista.ExplicitStructuredGrid.compute_connections">[docs]</a>    <span class="k">def</span> <span class="nf">compute_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute an array with the number of connected cell faces.</span>

<span class="sd">        This method calculates the number of topological cell</span>
<span class="sd">        neighbors connected by faces. The results are stored in the</span>
<span class="sd">        ``&#39;number_of_connections&#39;`` cell array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            This method is applied to this grid if ``True`` or to a copy</span>
<span class="sd">            otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExplicitStructuredGrid</span>
<span class="sd">            A deep copy of this grid if ``inplace=False`` or this</span>
<span class="sd">            DataSet if otherwise.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ExplicitStructuredGrid.compute_connectivity : Compute the faces connectivity flags array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_explicit_structured()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid = grid.compute_connections()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(show_edges=True)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;ConnectivityFlags&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;ConnectivityFlags&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_connectivity</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;ConnectivityFlags&#39;</span><span class="p">]</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;number_of_connections&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">compute_connections</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div></div>
</pre></div>

              </article>
              

              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2017-2023, The PyVista Developers.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyvista.core.filters.data_set &#8212; PyVista 0.35.2 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/no_search_highlight.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/summary.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
    <img src="../../../../_static/pyvista_logo_sm.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../../_static/pyvista_logo_sm.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../getting-started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user-guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../examples/index.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../api/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../extras/index.html">
  Extras
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        0.35  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/pyvista/core/filters/data_set and {'json_url': 'https://docs.pyvista.org/versions.json', 'version_match': '0.35'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/pyvista/core/filters/data_set.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.pyvista.org/versions.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/pyvista/core/filters/data_set.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 0.35.2 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "0.35") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://slack.pyvista.org" rel="noopener" target="_blank" title="Slack Community"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack Community</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/discussions" rel="noopener" target="_blank" title="Support"><span><i class="fa fa-comment fa-fw"></i></span>
            <label class="sr-only">Support</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/blob/main/CONTRIBUTING.rst" rel="noopener" target="_blank" title="Contributing"><span><i class="fa fa-gavel fa-fw"></i></span>
            <label class="sr-only">Contributing</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://doi.org/10.21105/joss.01450" rel="noopener" target="_blank" title="The Paper"><span><i class="fa fa-file-text fa-fw"></i></span>
            <label class="sr-only">The Paper</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for pyvista.core.filters.data_set</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Filters module with a class of common filters that can be applied to any vtkDataSet.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pyvista</span>
<span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">FieldAssociation</span><span class="p">,</span> <span class="n">_vtk</span>
<span class="kn">from</span> <span class="nn">pyvista.core.errors</span> <span class="kn">import</span> <span class="n">VTKVersionError</span>
<span class="kn">from</span> <span class="nn">pyvista.core.filters</span> <span class="kn">import</span> <span class="n">_get_output</span><span class="p">,</span> <span class="n">_update_alg</span>
<span class="kn">from</span> <span class="nn">pyvista.errors</span> <span class="kn">import</span> <span class="n">AmbiguousDataError</span><span class="p">,</span> <span class="n">MissingDataError</span>
<span class="kn">from</span> <span class="nn">pyvista.utilities</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NORMALS</span><span class="p">,</span>
    <span class="n">abstract_class</span><span class="p">,</span>
    <span class="n">assert_empty_kwargs</span><span class="p">,</span>
    <span class="n">generate_plane</span><span class="p">,</span>
    <span class="n">get_array</span><span class="p">,</span>
    <span class="n">get_array_association</span><span class="p">,</span>
    <span class="n">transformations</span><span class="p">,</span>
    <span class="n">wrap</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyvista.utilities.cells</span> <span class="kn">import</span> <span class="n">numpy_to_idarr</span>


<div class="viewcode-block" id="DataSetFilters"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.html#pyvista.DataSetFilters">[docs]</a><span class="nd">@abstract_class</span>
<span class="k">class</span> <span class="nc">DataSetFilters</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A set of common filters that can be applied to any vtkDataSet.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_clip_with_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">function</span><span class="p">,</span>
        <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">return_clipped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">crinkle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip using an implicit function (internal helper).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crinkle</span><span class="p">:</span>
            <span class="c1"># Add Cell IDs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkClipPolyData</span><span class="p">()</span>
        <span class="c1"># elif isinstance(self, vtk.vtkImageData):</span>
        <span class="c1">#     alg = vtk.vtkClipVolume()</span>
        <span class="c1">#     alg.SetMixed3DCellGeneration(True)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTableBasedClipDataSet</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Use the grid as the data we desire to cut</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetClipFunction</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>  <span class="c1"># the implicit function</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInsideOut</span><span class="p">(</span><span class="n">invert</span><span class="p">)</span>  <span class="c1"># invert the clip if needed</span>
        <span class="k">if</span> <span class="n">return_clipped</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">GenerateClippedOutputOn</span><span class="p">()</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Clipping with Function&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_clipped</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">crinkle</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_cells</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_cells</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="n">clipped</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crinkle</span><span class="p">:</span>
            <span class="n">clipped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_cells</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clipped</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">clipped</span>

<div class="viewcode-block" id="DataSetFilters.clip"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.clip.html#pyvista.DataSetFilters.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">normal</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
        <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_clipped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">crinkle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip a dataset by a plane by specifying the origin and normal.</span>

<span class="sd">        If no parameters are given the clip will occur in the center</span>
<span class="sd">        of that dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normal : tuple(float) or str</span>
<span class="sd">            Length 3 tuple for the normal vector direction. Can also</span>
<span class="sd">            be specified as a string conventional direction such as</span>
<span class="sd">            ``&#39;x&#39;`` for ``(1,0,0)`` or ``&#39;-x&#39;`` for ``(-1,0,0)``, etc.</span>

<span class="sd">        origin : tuple(float), optional</span>
<span class="sd">            The center ``(x,y,z)`` coordinate of the plane on which the clip</span>
<span class="sd">            occurs. The default is the center of the dataset.</span>

<span class="sd">        invert : bool, optional</span>
<span class="sd">            Flag on whether to flip/invert the clip.</span>

<span class="sd">        value : float, optional</span>
<span class="sd">            Set the clipping value along the normal direction.</span>
<span class="sd">            The default value is 0.0.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        return_clipped : bool, optional</span>
<span class="sd">            Return both unclipped and clipped parts of the dataset.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        crinkle : bool, optional</span>
<span class="sd">            Crinkle the clip by extracting the entire cells along the</span>
<span class="sd">            clip. This adds the ``&quot;cell_ids&quot;`` array to the ``cell_data``</span>
<span class="sd">            attribute that tracks the original cell IDs of the original</span>
<span class="sd">            dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData or tuple(pyvista.PolyData)</span>
<span class="sd">            Clipped mesh when ``return_clipped=False``,</span>
<span class="sd">            otherwise a tuple containing the unclipped and clipped datasets.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Clip a cube along the +X direction.  ``triangulate`` is used as</span>
<span class="sd">        the cube is initially composed of quadrilateral faces and</span>
<span class="sd">        subdivide only works on triangles.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; cube = pv.Cube().triangulate().subdivide(3)</span>
<span class="sd">        &gt;&gt;&gt; clipped_cube = cube.clip()</span>
<span class="sd">        &gt;&gt;&gt; clipped_cube.plot()</span>

<span class="sd">        Clip a cube in the +Z direction.  This leaves half a cube</span>
<span class="sd">        below the XY plane.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; cube = pv.Cube().triangulate().subdivide(3)</span>
<span class="sd">        &gt;&gt;&gt; clipped_cube = cube.clip(&#39;z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; clipped_cube.plot()</span>

<span class="sd">        See :ref:`clip_with_surface_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">NORMALS</span><span class="p">[</span><span class="n">normal</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="c1"># find center of data if origin not specified</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="c1"># create the plane for clipping</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">generate_plane</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="c1"># run the clip</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">_clip_with_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">function</span><span class="p">,</span>
            <span class="n">invert</span><span class="o">=</span><span class="n">invert</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">return_clipped</span><span class="o">=</span><span class="n">return_clipped</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
            <span class="n">crinkle</span><span class="o">=</span><span class="n">crinkle</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_clipped</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="DataSetFilters.clip_box"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.clip_box.html#pyvista.DataSetFilters.clip_box">[docs]</a>    <span class="k">def</span> <span class="nf">clip_box</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">factor</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">merge_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">crinkle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip a dataset by a bounding box defined by the bounds.</span>

<span class="sd">        If no bounds are given, a corner of the dataset bounds will be removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds : tuple(float), optional</span>
<span class="sd">            Length 6 sequence of floats: (xmin, xmax, ymin, ymax, zmin, zmax).</span>
<span class="sd">            Length 3 sequence of floats: distances from the min coordinate of</span>
<span class="sd">            of the input mesh. Single float value: uniform distance from the</span>
<span class="sd">            min coordinate. Length 12 sequence of length 3 sequence of floats:</span>
<span class="sd">            a plane collection (normal, center, ...).</span>
<span class="sd">            :class:`pyvista.PolyData`: if a poly mesh is passed that represents</span>
<span class="sd">            a box with 6 faces that all form a standard box, then planes will</span>
<span class="sd">            be extracted from the box to define the clipping region.</span>

<span class="sd">        invert : bool, optional</span>
<span class="sd">            Flag on whether to flip/invert the clip.</span>

<span class="sd">        factor : float, optional</span>
<span class="sd">            If bounds are not given this is the factor along each axis to</span>
<span class="sd">            extract the default box.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        merge_points : bool, optional</span>
<span class="sd">            If ``True`` (default), coinciding points of independently</span>
<span class="sd">            defined mesh elements will be merged.</span>

<span class="sd">        crinkle : bool, optional</span>
<span class="sd">            Crinkle the clip by extracting the entire cells along the</span>
<span class="sd">            clip. This adds the ``&quot;cell_ids&quot;`` array to the ``cell_data``</span>
<span class="sd">            attribute that tracks the original cell IDs of the original</span>
<span class="sd">            dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            Clipped dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Clip a corner of a cube.  The bounds of a cube are normally</span>
<span class="sd">        ``[-0.5, 0.5, -0.5, 0.5, -0.5, 0.5]``, and this removes 1/8 of</span>
<span class="sd">        the cube&#39;s surface.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; cube = pv.Cube().triangulate().subdivide(3)</span>
<span class="sd">        &gt;&gt;&gt; clipped_cube = cube.clip_box([0, 1, 0, 1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; clipped_cube.plot()</span>

<span class="sd">        See :ref:`clip_with_plane_box_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">_get_quarter</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Get a section of the given range (internal helper).&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">dmax</span> <span class="o">-</span> <span class="p">((</span><span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>

            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">_get_quarter</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">_get_quarter</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
            <span class="n">zmin</span> <span class="o">=</span> <span class="n">_get_quarter</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">bounds</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">bounds</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">):</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">bounds</span>
            <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">n_cells</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The bounds mesh must have only 6 faces.&quot;</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">poly</span><span class="o">.</span><span class="n">compute_normals</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">extract_cells</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s2">&quot;Normals&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Bounds must be a sequence of floats with length 3, 6 or 12.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bounds must be a sequence of floats with length 3, 6 or 12.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">crinkle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkBoxClipDataSet</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">merge_points</span><span class="p">:</span>
            <span class="c1"># vtkBoxClipDataSet uses vtkMergePoints by default</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetLocator</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkNonMergingPointLocator</span><span class="p">())</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetBoxClip</span><span class="p">(</span><span class="o">*</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
            <span class="c1"># invert the clip if needed</span>
            <span class="n">port</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">GenerateClippedOutputOn</span><span class="p">()</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Clipping a Dataset by a Bounding Box&#39;</span><span class="p">)</span>
        <span class="n">clipped</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="n">port</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crinkle</span><span class="p">:</span>
            <span class="n">clipped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_cells</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clipped</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">clipped</span></div>

<div class="viewcode-block" id="DataSetFilters.compute_implicit_distance"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.compute_implicit_distance.html#pyvista.DataSetFilters.compute_implicit_distance">[docs]</a>    <span class="k">def</span> <span class="nf">compute_implicit_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the implicit distance from the points to a surface.</span>

<span class="sd">        This filter will compute the implicit distance from all of the</span>
<span class="sd">        nodes of this mesh to a given surface. This distance will be</span>
<span class="sd">        added as a point array called ``&#39;implicit_distance&#39;``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface : pyvista.DataSet</span>
<span class="sd">            The surface used to compute the distance.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, a new scalar array will be added to the</span>
<span class="sd">            ``point_data`` of this mesh and the modified mesh will</span>
<span class="sd">            be returned. Otherwise a copy of this mesh is returned</span>
<span class="sd">            with that scalar field added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset containing the ``&#39;implicit_distance&#39;`` array in</span>
<span class="sd">            ``point_data``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute the distance between all the points on a sphere and a</span>
<span class="sd">        plane.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; plane = pv.Plane()</span>
<span class="sd">        &gt;&gt;&gt; _ = sphere.compute_implicit_distance(plane, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; dist = sphere[&#39;implicit_distance&#39;]</span>
<span class="sd">        &gt;&gt;&gt; type(dist)</span>
<span class="sd">        &lt;class &#39;pyvista.core.pyvista_ndarray.pyvista_ndarray&#39;&gt;</span>

<span class="sd">        Plot these distances as a heatmap</span>

<span class="sd">        &gt;&gt;&gt; pl = pv.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere, scalars=&#39;implicit_distance&#39;, cmap=&#39;bwr&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(plane, color=&#39;w&#39;, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`clip_with_surface_example` and</span>
<span class="sd">        :ref:`voxelize_surface_mesh_example` for more examples using</span>
<span class="sd">        this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkImplicitPolyDataDistance</span><span class="p">()</span>
        <span class="n">function</span><span class="o">.</span><span class="n">SetInput</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">convert_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDoubleArray</span><span class="p">()</span>
        <span class="n">function</span><span class="o">.</span><span class="n">FunctionValue</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;implicit_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">convert_array</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;implicit_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">convert_array</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="DataSetFilters.clip_scalar"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.clip_scalar.html#pyvista.DataSetFilters.clip_scalar">[docs]</a>    <span class="k">def</span> <span class="nf">clip_scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">both</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip a dataset by a scalar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars : str, optional</span>
<span class="sd">            Name of scalars to clip on.  Defaults to currently active scalars.</span>

<span class="sd">        invert : bool, optional</span>
<span class="sd">            Flag on whether to flip/invert the clip.  When ``True``,</span>
<span class="sd">            only the mesh below ``value`` will be kept.  When</span>
<span class="sd">            ``False``, only values above ``value`` will be kept.</span>

<span class="sd">        value : float, optional</span>
<span class="sd">            Set the clipping value.  The default value is 0.0.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Update mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        both : bool, optional</span>
<span class="sd">            If ``True``, also returns the complementary clipped mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData or tuple</span>
<span class="sd">            Clipped dataset if ``both=False``.  If ``both=True`` then</span>
<span class="sd">            returns a tuple of both clipped datasets.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Remove the part of the mesh with &quot;sample_point_scalars&quot; above 100.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; dataset = examples.load_hexbeam()</span>
<span class="sd">        &gt;&gt;&gt; clipped = dataset.clip_scalar(scalars=&quot;sample_point_scalars&quot;, value=100)</span>
<span class="sd">        &gt;&gt;&gt; clipped.plot()</span>

<span class="sd">        Get clipped meshes corresponding to the portions of the mesh above and below 100.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; dataset = examples.load_hexbeam()</span>
<span class="sd">        &gt;&gt;&gt; _below, _above = dataset.clip_scalar(scalars=&quot;sample_point_scalars&quot;, value=100, both=True)</span>

<span class="sd">        Remove the part of the mesh with &quot;sample_point_scalars&quot; below 100.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; dataset = examples.load_hexbeam()</span>
<span class="sd">        &gt;&gt;&gt; clipped = dataset.clip_scalar(scalars=&quot;sample_point_scalars&quot;, value=100, invert=False)</span>
<span class="sd">        &gt;&gt;&gt; clipped.plot()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkClipPolyData</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTableBasedClipDataSet</span><span class="p">()</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetInsideOut</span><span class="p">(</span><span class="n">invert</span><span class="p">)</span>  <span class="c1"># invert the clip if needed</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateClippedOutput</span><span class="p">(</span><span class="n">both</span><span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Clipping by a Scalar&#39;</span><span class="p">)</span>
        <span class="n">result0</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">result0</span><span class="p">)</span>
            <span class="n">result0</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">both</span><span class="p">:</span>
            <span class="n">result1</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
                <span class="c1"># For some reason vtkClipPolyData with SetGenerateClippedOutput on leaves unreferenced vertices</span>
                <span class="n">result0</span><span class="p">,</span> <span class="n">result1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">(</span><span class="n">result0</span><span class="p">,</span> <span class="n">result1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result0</span><span class="p">,</span> <span class="n">result1</span>
        <span class="k">return</span> <span class="n">result0</span></div>

<div class="viewcode-block" id="DataSetFilters.clip_surface"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.clip_surface.html#pyvista.DataSetFilters.clip_surface">[docs]</a>    <span class="k">def</span> <span class="nf">clip_surface</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">surface</span><span class="p">,</span>
        <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">compute_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">crinkle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip any mesh type using a :class:`pyvista.PolyData` surface mesh.</span>

<span class="sd">        This will return a :class:`pyvista.UnstructuredGrid` of the clipped</span>
<span class="sd">        mesh. Geometry of the input dataset will be preserved where possible.</span>
<span class="sd">        Geometries near the clip intersection will be triangulated/tessellated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface : pyvista.PolyData</span>
<span class="sd">            The ``PolyData`` surface mesh to use as a clipping</span>
<span class="sd">            function.  If this input mesh is not a :class`pyvista.PolyData`,</span>
<span class="sd">            the external surface will be extracted.</span>

<span class="sd">        invert : bool, optional</span>
<span class="sd">            Flag on whether to flip/invert the clip.</span>

<span class="sd">        value : float, optional</span>
<span class="sd">            Set the clipping value of the implicit function (if</span>
<span class="sd">            clipping with implicit function) or scalar value (if</span>
<span class="sd">            clipping with scalars).  The default value is 0.0.</span>

<span class="sd">        compute_distance : bool, optional</span>
<span class="sd">            Compute the implicit distance from the mesh onto the input</span>
<span class="sd">            dataset.  A new array called ``&#39;implicit_distance&#39;`` will</span>
<span class="sd">            be added to the output clipped mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        crinkle : bool, optional</span>
<span class="sd">            Crinkle the clip by extracting the entire cells along the</span>
<span class="sd">            clip. This adds the ``&quot;cell_ids&quot;`` array to the ``cell_data``</span>
<span class="sd">            attribute that tracks the original cell IDs of the original</span>
<span class="sd">            dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Clipped surface.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Clip a cube with a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(center=(-0.4, -0.4, -0.4))</span>
<span class="sd">        &gt;&gt;&gt; cube = pyvista.Cube().triangulate().subdivide(3)</span>
<span class="sd">        &gt;&gt;&gt; clipped = cube.clip_surface(sphere)</span>
<span class="sd">        &gt;&gt;&gt; clipped.plot(show_edges=True, cpos=&#39;xy&#39;, line_width=3)</span>

<span class="sd">        See :ref:`clip_with_surface_example` for more examples using</span>
<span class="sd">        this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="n">surface</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">extract_geometry</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkImplicitPolyDataDistance</span><span class="p">()</span>
        <span class="n">function</span><span class="o">.</span><span class="n">SetInput</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_distance</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">convert_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDoubleArray</span><span class="p">()</span>
            <span class="n">function</span><span class="o">.</span><span class="n">FunctionValue</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;implicit_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">convert_array</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="c1"># run the clip</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">_clip_with_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">function</span><span class="p">,</span>
            <span class="n">invert</span><span class="o">=</span><span class="n">invert</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
            <span class="n">crinkle</span><span class="o">=</span><span class="n">crinkle</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="DataSetFilters.slice"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.slice.html#pyvista.DataSetFilters.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">generate_triangles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contour</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slice a dataset by a plane at the specified origin and normal vector orientation.</span>

<span class="sd">        If no origin is specified, the center of the input dataset will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normal : tuple(float) or str</span>
<span class="sd">            Length 3 tuple for the normal vector direction. Can also be</span>
<span class="sd">            specified as a string conventional direction such as ``&#39;x&#39;`` for</span>
<span class="sd">            ``(1, 0, 0)`` or ``&#39;-x&#39;`` for ``(-1, 0, 0)``, etc.</span>

<span class="sd">        origin : tuple(float)</span>
<span class="sd">            The center ``(x, y, z)`` coordinate of the plane on which</span>
<span class="sd">            the slice occurs.</span>

<span class="sd">        generate_triangles : bool, optional</span>
<span class="sd">            If this is enabled (``False`` by default), the output will</span>
<span class="sd">            be triangles. Otherwise the output will be the intersection</span>
<span class="sd">            polygons.</span>

<span class="sd">        contour : bool, optional</span>
<span class="sd">            If ``True``, apply a ``contour`` filter after slicing.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Sliced dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Slice the surface of a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; slice_x = sphere.slice(normal=&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; slice_y = sphere.slice(normal=&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; slice_z = sphere.slice(normal=&#39;z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; slices = slice_x + slice_y + slice_z</span>
<span class="sd">        &gt;&gt;&gt; slices.plot(line_width=5)</span>

<span class="sd">        See :ref:`slice_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">NORMALS</span><span class="p">[</span><span class="n">normal</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="c1"># find center of data if origin not specified</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="c1"># create the plane for clipping</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">generate_plane</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="c1"># create slice</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCutter</span><span class="p">()</span>  <span class="c1"># Construct the cutter object</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Use the grid as the data we desire to cut</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCutFunction</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>  <span class="c1"># the cutter to use the plane we made</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generate_triangles</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">GenerateTrianglesOff</span><span class="p">()</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Slicing&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">contour</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">contour</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.slice_orthogonal"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.slice_orthogonal.html#pyvista.DataSetFilters.slice_orthogonal">[docs]</a>    <span class="k">def</span> <span class="nf">slice_orthogonal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">generate_triangles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contour</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create three orthogonal slices through the dataset on the three cartesian planes.</span>

<span class="sd">        Yields a MutliBlock dataset of the three slices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float, optional</span>
<span class="sd">            The X location of the YZ slice.</span>

<span class="sd">        y : float, optional</span>
<span class="sd">            The Y location of the XZ slice.</span>

<span class="sd">        z : float, optional</span>
<span class="sd">            The Z location of the XY slice.</span>

<span class="sd">        generate_triangles : bool, optional</span>
<span class="sd">            If this is enabled (``False`` by default), the output will</span>
<span class="sd">            be triangles. Otherwise the output will be the intersection</span>
<span class="sd">            polygons.</span>

<span class="sd">        contour : bool, optional</span>
<span class="sd">            If ``True``, apply a ``contour`` filter after slicing.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Sliced dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Slice the random hills dataset with three orthogonal planes.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; slices = hills.slice_orthogonal(contour=False)</span>
<span class="sd">        &gt;&gt;&gt; slices.plot(line_width=5)</span>

<span class="sd">        See :ref:`slice_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the three slices</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_blocks</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">slice_orthogonal</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">generate_triangles</span><span class="o">=</span><span class="n">generate_triangles</span><span class="p">,</span> <span class="n">contour</span><span class="o">=</span><span class="n">contour</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;YZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span>
            <span class="n">normal</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
            <span class="n">generate_triangles</span><span class="o">=</span><span class="n">generate_triangles</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;XZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span>
            <span class="n">normal</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
            <span class="n">generate_triangles</span><span class="o">=</span><span class="n">generate_triangles</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;XY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span>
            <span class="n">normal</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
            <span class="n">generate_triangles</span><span class="o">=</span><span class="n">generate_triangles</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.slice_along_axis"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.slice_along_axis.html#pyvista.DataSetFilters.slice_along_axis">[docs]</a>    <span class="k">def</span> <span class="nf">slice_along_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">generate_triangles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">contour</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create many slices of the input dataset along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            The number of slices to create.</span>

<span class="sd">        axis : str or int</span>
<span class="sd">            The axis to generate the slices along. Perpendicular to the</span>
<span class="sd">            slices. Can be string name (``&#39;x&#39;``, ``&#39;y&#39;``, or ``&#39;z&#39;``) or</span>
<span class="sd">            axis index (``0``, ``1``, or ``2``).</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance to the edge of the dataset bounds to create</span>
<span class="sd">            the slices. The ``n`` slices are placed equidistantly with</span>
<span class="sd">            an absolute padding of ``tolerance`` inside each side of the</span>
<span class="sd">            ``bounds`` along the specified axis. Defaults to 1% of the</span>
<span class="sd">            ``bounds`` along the specified axis.</span>

<span class="sd">        generate_triangles : bool, optional</span>
<span class="sd">            If this is enabled (``False`` by default), the output will</span>
<span class="sd">            be triangles. Otherwise the output will be the intersection</span>
<span class="sd">            polygons.</span>

<span class="sd">        contour : bool, optional</span>
<span class="sd">            If ``True``, apply a ``contour`` filter after slicing.</span>

<span class="sd">        bounds : sequence, optional</span>
<span class="sd">            A 6-length sequence overriding the bounds of the mesh.</span>
<span class="sd">            The bounds along the specified axis define the extent</span>
<span class="sd">            where slices are taken.</span>

<span class="sd">        center : sequence, optional</span>
<span class="sd">            A 3-length sequence specifying the position of the line</span>
<span class="sd">            along which slices are taken. Defaults to the center of</span>
<span class="sd">            the mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Sliced dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Slice the random hills dataset in the X direction.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; slices = hills.slice_along_axis(n=10)</span>
<span class="sd">        &gt;&gt;&gt; slices.plot(line_width=5)</span>

<span class="sd">        Slice the random hills dataset in the Z direction.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; slices = hills.slice_along_axis(n=10, axis=&#39;z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; slices.plot(line_width=5)</span>

<span class="sd">        See :ref:`slice_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># parse axis input</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
        <span class="n">label_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ax_index</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="n">ax_label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">ax_index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ax_index</span> <span class="o">=</span> <span class="n">label_to_index</span><span class="p">[</span><span class="n">axis</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Axis (</span><span class="si">{</span><span class="n">axis</span><span class="si">!r}</span><span class="s1">) not understood. Choose one of </span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
            <span class="n">ax_label</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="c1"># get the locations along that axis</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">ax_index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ax_index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.01</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">ax_index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ax_index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="c1"># Make each of the slices</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_blocks</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">slice_along_axis</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">ax_label</span><span class="p">,</span>
                    <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                    <span class="n">generate_triangles</span><span class="o">=</span><span class="n">generate_triangles</span><span class="p">,</span>
                    <span class="n">contour</span><span class="o">=</span><span class="n">contour</span><span class="p">,</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                    <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">center</span><span class="p">[</span><span class="n">ax_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">normal</span><span class="o">=</span><span class="n">ax_label</span><span class="p">,</span>
                <span class="n">origin</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="n">generate_triangles</span><span class="o">=</span><span class="n">generate_triangles</span><span class="p">,</span>
                <span class="n">contour</span><span class="o">=</span><span class="n">contour</span><span class="p">,</span>
                <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;slice</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">slc</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.slice_along_line"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.slice_along_line.html#pyvista.DataSetFilters.slice_along_line">[docs]</a>    <span class="k">def</span> <span class="nf">slice_along_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">generate_triangles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contour</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slice a dataset using a polyline/spline as the path.</span>

<span class="sd">        This also works for lines generated with :func:`pyvista.Line`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        line : pyvista.PolyData</span>
<span class="sd">            A PolyData object containing one single PolyLine cell.</span>

<span class="sd">        generate_triangles : bool, optional</span>
<span class="sd">            If this is enabled (``False`` by default), the output will</span>
<span class="sd">            be triangles. Otherwise the output will be the intersection</span>
<span class="sd">            polygons.</span>

<span class="sd">        contour : bool, optional</span>
<span class="sd">            If ``True``, apply a ``contour`` filter after slicing.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Sliced dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Slice the random hills dataset along a circular arc.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; center = np.array(hills.center)</span>
<span class="sd">        &gt;&gt;&gt; point_a = center + np.array([5, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; point_b = center + np.array([-5, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; arc = pyvista.CircularArc(point_a, point_b, center, resolution=100)</span>
<span class="sd">        &gt;&gt;&gt; line_slice = hills.slice_along_line(arc)</span>

<span class="sd">        Plot the circular arc and the hills mesh.</span>

<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(hills, smooth_shading=True, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(line_slice, line_width=10, render_lines_as_tubes=True,</span>
<span class="sd">        ...                 color=&#39;k&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(arc, line_width=10, color=&#39;grey&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`slice_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check that we have a PolyLine cell in the input line</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">GetNumberOfCells</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input line must have only one cell.&#39;</span><span class="p">)</span>
        <span class="n">polyline</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">GetCell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polyline</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyLine</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Input line must have a PolyLine cell, not (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="c1"># Generate PolyPlane</span>
        <span class="n">polyplane</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyPlane</span><span class="p">()</span>
        <span class="n">polyplane</span><span class="o">.</span><span class="n">SetPolyLine</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span>
        <span class="c1"># Create slice</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCutter</span><span class="p">()</span>  <span class="c1"># Construct the cutter object</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Use the grid as the data we desire to cut</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCutFunction</span><span class="p">(</span><span class="n">polyplane</span><span class="p">)</span>  <span class="c1"># the cutter to use the poly planes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generate_triangles</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">GenerateTrianglesOff</span><span class="p">()</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Slicing along Line&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">contour</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">contour</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.threshold"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.threshold.html#pyvista.DataSetFilters.threshold">[docs]</a>    <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">continuous</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span>
        <span class="n">all_scalars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">component_mode</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">component</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a ``vtkThreshold`` filter to the input dataset.</span>

<span class="sd">        This filter will apply a ``vtkThreshold`` filter to the input</span>
<span class="sd">        dataset and return the resulting object. This extracts cells</span>
<span class="sd">        where the scalar value in each cell satisfies the threshold</span>
<span class="sd">        criterion.  If ``scalars`` is ``None``, the input&#39;s active</span>
<span class="sd">        scalars array is used.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           Thresholding is inherently a cell operation, even though it can use</span>
<span class="sd">           associated point data for determining whether to keep a cell. In</span>
<span class="sd">           other words, whether or not a given point is included after</span>
<span class="sd">           thresholding depends on whether that point is part of a cell that</span>
<span class="sd">           is kept after thresholding.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : float or sequence, optional</span>
<span class="sd">            Single value or (min, max) to be used for the data threshold.  If</span>
<span class="sd">            a sequence, then length must be 2. If no value is specified, the</span>
<span class="sd">            non-NaN data range will be used to remove any NaN values.</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            Name of scalars to threshold on. Defaults to currently active scalars.</span>

<span class="sd">        invert : bool, optional</span>
<span class="sd">            If value is a single value, when invert is ``True`` cells</span>
<span class="sd">            are kept when their values are below parameter ``&quot;value&quot;``.</span>
<span class="sd">            When invert is ``False`` cells are kept when their value is</span>
<span class="sd">            above the threshold ``&quot;value&quot;``.  Default is ``False``:</span>
<span class="sd">            yielding above the threshold ``&quot;value&quot;``.</span>

<span class="sd">        continuous : bool, optional</span>
<span class="sd">            When True, the continuous interval [minimum cell scalar,</span>
<span class="sd">            maximum cell scalar] will be used to intersect the threshold bound,</span>
<span class="sd">            rather than the set of discrete scalar values from the vertices.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            When ``scalars`` is specified, this is the preferred array</span>
<span class="sd">            type to search for in the dataset.  Must be either</span>
<span class="sd">            ``&#39;point&#39;`` or ``&#39;cell&#39;``.</span>

<span class="sd">        all_scalars : bool, optional</span>
<span class="sd">            If using scalars from point data, all</span>
<span class="sd">            points in a cell must satisfy the threshold when this</span>
<span class="sd">            value is ``True``.  When ``False``, any point of the cell</span>
<span class="sd">            with a scalar value satisfying the threshold criterion</span>
<span class="sd">            will extract the cell. Has no effect when using cell data.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        component_mode : {&#39;selected&#39;, &#39;all&#39;, &#39;any&#39;}</span>
<span class="sd">            The method to satisfy the criteria for the threshold of</span>
<span class="sd">            multicomponent scalars.  &#39;selected&#39; (default)</span>
<span class="sd">            uses only the ``component``.  &#39;all&#39; requires all</span>
<span class="sd">            components to meet criteria.  &#39;any&#39; is when</span>
<span class="sd">            any component satisfies the criteria.</span>

<span class="sd">        component : int</span>
<span class="sd">            When using ``component_mode=&#39;selected&#39;``, this sets</span>
<span class="sd">            which component to threshold on.  Default is ``0``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            Dataset containing geometry that meets the threshold requirements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; volume = np.zeros([10, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; volume[:3] = 1</span>
<span class="sd">        &gt;&gt;&gt; vol = pyvista.wrap(volume)</span>
<span class="sd">        &gt;&gt;&gt; threshed = vol.threshold(0.1)</span>
<span class="sd">        &gt;&gt;&gt; threshed  # doctest:+SKIP</span>
<span class="sd">        UnstructuredGrid (0x7f00f9983fa0)</span>
<span class="sd">          N Cells:	243</span>
<span class="sd">          N Points:	400</span>
<span class="sd">          X Bounds:	0.000e+00, 3.000e+00</span>
<span class="sd">          Y Bounds:	0.000e+00, 9.000e+00</span>
<span class="sd">          Z Bounds:	0.000e+00, 9.000e+00</span>
<span class="sd">          N Arrays:	1</span>

<span class="sd">        Apply the threshold filter to Perlin noise.  First generate</span>
<span class="sd">        the structured grid.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; noise = pyvista.perlin_noise(0.1, (1, 1, 1), (0, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; grid = pyvista.sample_function(noise, [0, 1.0, -0, 1.0, 0, 1.0],</span>
<span class="sd">        ...                                dim=(20, 20, 20))</span>
<span class="sd">        &gt;&gt;&gt; grid.plot(cmap=&#39;gist_earth_r&#39;, show_scalar_bar=True, show_edges=False)</span>

<span class="sd">        Next, apply the threshold.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; noise = pyvista.perlin_noise(0.1, (1, 1, 1), (0, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; grid = pyvista.sample_function(noise, [0, 1.0, -0, 1.0, 0, 1.0],</span>
<span class="sd">        ...                                dim=(20, 20, 20))</span>
<span class="sd">        &gt;&gt;&gt; threshed = grid.threshold(value=0.02)</span>
<span class="sd">        &gt;&gt;&gt; threshed.plot(cmap=&#39;gist_earth_r&#39;, show_scalar_bar=False, show_edges=True)</span>

<span class="sd">        See :ref:`common_filter_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the scalars to threshold on</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No arrays present to threshold.&#39;</span><span class="p">)</span>

        <span class="n">field</span> <span class="o">=</span> <span class="n">get_array_association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>

        <span class="c1"># If using an inverted range, merge the result of two filters:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">))</span> <span class="ow">and</span> <span class="n">invert</span><span class="p">:</span>
            <span class="n">valid_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">arr</span><span class="p">)]</span>
            <span class="c1"># Create two thresholds</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span>
                <span class="p">[</span><span class="n">valid_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">scalars</span><span class="o">=</span><span class="n">scalars</span><span class="p">,</span>
                <span class="n">continuous</span><span class="o">=</span><span class="n">continuous</span><span class="p">,</span>
                <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">,</span>
                <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span>
                <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">valid_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">scalars</span><span class="o">=</span><span class="n">scalars</span><span class="p">,</span>
                <span class="n">continuous</span><span class="o">=</span><span class="n">continuous</span><span class="p">,</span>
                <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">,</span>
                <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Use an AppendFilter to merge the two results</span>
            <span class="n">appender</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkAppendFilter</span><span class="p">()</span>
            <span class="n">appender</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
            <span class="n">appender</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
            <span class="n">_update_alg</span><span class="p">(</span><span class="n">appender</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Thresholding&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">appender</span><span class="p">)</span>

        <span class="c1"># Run a standard threshold algorithm</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkThreshold</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetAllScalars</span><span class="p">(</span><span class="n">all_scalars</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scalars</span>
        <span class="p">)</span>  <span class="c1"># args: (idx, port, connection, field, name)</span>
        <span class="c1"># set thresholding parameters</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetUseContinuousCellRange</span><span class="p">(</span><span class="n">continuous</span><span class="p">)</span>
        <span class="c1"># use valid range if no value given</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_range</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="c1"># check if value is a sequence (if so threshold by min max range like ParaView)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Value range must be length one for a float value or two for min/max; not (</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">).&#39;</span>
                <span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">ThresholdBetween</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Value must either be a single scalar or a sequence.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just a single value</span>
            <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">ThresholdByLower</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">ThresholdByUpper</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">component_mode</span> <span class="o">==</span> <span class="s2">&quot;component&quot;</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetComponentModeToUseSelected</span><span class="p">()</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;component must be int&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">component</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">component</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;scalars has </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> components: supplied component </span><span class="si">{</span><span class="n">component</span><span class="si">}</span><span class="s2"> not in range&quot;</span>
                <span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetSelectedComponent</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">component_mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetComponentModeToUseAll</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">component_mode</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetComponentModeToUseAny</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;component_mode must be &#39;component&#39;, &#39;all&#39;, or &#39;any&#39; got: </span><span class="si">{</span><span class="n">component_mode</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Run the threshold</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Thresholding&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.threshold_percent"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.threshold_percent.html#pyvista.DataSetFilters.threshold_percent">[docs]</a>    <span class="k">def</span> <span class="nf">threshold_percent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">percent</span><span class="o">=</span><span class="mf">0.50</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">continuous</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Threshold the dataset by a percentage of its range on the active scalars array.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           Thresholding is inherently a cell operation, even though it can use</span>
<span class="sd">           associated point data for determining whether to keep a cell. In</span>
<span class="sd">           other words, whether or not a given point is included after</span>
<span class="sd">           thresholding depends on whether that point is part of a cell that</span>
<span class="sd">           is kept after thresholding.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percent : float or tuple(float), optional</span>
<span class="sd">            The percentage (0,1) to threshold. If value is out of 0 to 1 range,</span>
<span class="sd">            then it will be divided by 100 and checked to be in that range.</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            Name of scalars to threshold on. Defaults to currently active scalars.</span>

<span class="sd">        invert : bool, optional</span>
<span class="sd">            When invert is ``True`` cells are kept when their values are</span>
<span class="sd">            below the percentage of the range.  When invert is</span>
<span class="sd">            ``False``, cells are kept when their value is above the</span>
<span class="sd">            percentage of the range. Default is ``False``: yielding</span>
<span class="sd">            above the threshold ``&quot;value&quot;``.</span>

<span class="sd">        continuous : bool, optional</span>
<span class="sd">            When ``True``, the continuous interval [minimum cell scalar,</span>
<span class="sd">            maximum cell scalar] will be used to intersect the threshold</span>
<span class="sd">            bound, rather than the set of discrete scalar values from</span>
<span class="sd">            the vertices.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            When ``scalars`` is specified, this is the preferred array</span>
<span class="sd">            type to search for in the dataset.  Must be either</span>
<span class="sd">            ``&#39;point&#39;`` or ``&#39;cell&#39;``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            Dataset containing geometry that meets the threshold requirements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Apply a 50% threshold filter.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; noise = pyvista.perlin_noise(0.1, (2, 2, 2), (0, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; grid = pyvista.sample_function(noise, [0, 1.0, -0, 1.0, 0, 1.0],</span>
<span class="sd">        ...                                dim=(30, 30, 30))</span>
<span class="sd">        &gt;&gt;&gt; threshed = grid.threshold_percent(0.5)</span>
<span class="sd">        &gt;&gt;&gt; threshed.plot(cmap=&#39;gist_earth_r&#39;, show_scalar_bar=False, show_edges=True)</span>

<span class="sd">        Apply a 80% threshold filter.</span>

<span class="sd">        &gt;&gt;&gt; threshed = grid.threshold_percent(0.8)</span>
<span class="sd">        &gt;&gt;&gt; threshed.plot(cmap=&#39;gist_earth_r&#39;, show_scalar_bar=False, show_edges=True)</span>

<span class="sd">        See :ref:`common_filter_example` for more examples using a similar filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tscalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tscalars</span> <span class="o">=</span> <span class="n">scalars</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_range</span><span class="p">(</span><span class="n">arr_var</span><span class="o">=</span><span class="n">tscalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_percent</span><span class="p">(</span><span class="n">percent</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Make sure percent is between 0 and 1 or fix if between 0 and 100.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">percent</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">percent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>
                <span class="k">if</span> <span class="n">percent</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Percentage (</span><span class="si">{</span><span class="n">percent</span><span class="si">}</span><span class="s1">) is out of range (0, 1).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">percent</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Percentage (</span><span class="si">{</span><span class="n">percent</span><span class="si">}</span><span class="s1">) is too close to zero or negative.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">percent</span>

        <span class="k">def</span> <span class="nf">_get_val</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Get the value from a percentage of a range.&quot;&quot;&quot;</span>
            <span class="n">percent</span> <span class="o">=</span> <span class="n">_check_percent</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dmin</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span><span class="p">)</span>

        <span class="c1"># Compute the values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
            <span class="c1"># Get two values</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_val</span><span class="p">(</span><span class="n">percent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">),</span> <span class="n">_get_val</span><span class="p">(</span><span class="n">percent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Percent must either be a single scalar or a sequence.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute one value to threshold</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_get_val</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>
        <span class="c1"># Use the normal thresholding function on these values</span>
        <span class="k">return</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">scalars</span><span class="o">=</span><span class="n">scalars</span><span class="p">,</span>
            <span class="n">invert</span><span class="o">=</span><span class="n">invert</span><span class="p">,</span>
            <span class="n">continuous</span><span class="o">=</span><span class="n">continuous</span><span class="p">,</span>
            <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.outline"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.outline.html#pyvista.DataSetFilters.outline">[docs]</a>    <span class="k">def</span> <span class="nf">outline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generate_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce an outline of the full extent for the input dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        generate_faces : bool, optional</span>
<span class="sd">            Generate solid faces for the box. This is disabled by default.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh containing an outline of the original dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate and plot the outline of a sphere.  This is</span>
<span class="sd">        effectively the ``(x, y, z)`` bounds of the mesh.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; outline = sphere.outline()</span>
<span class="sd">        &gt;&gt;&gt; pyvista.plot([sphere, outline], line_width=5)</span>

<span class="sd">        See :ref:`common_filter_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkOutlineFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateFaces</span><span class="p">(</span><span class="n">generate_faces</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Producing an outline&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">alg</span><span class="o">.</span><span class="n">GetOutputDataObject</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="DataSetFilters.outline_corners"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.outline_corners.html#pyvista.DataSetFilters.outline_corners">[docs]</a>    <span class="k">def</span> <span class="nf">outline_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce an outline of the corners for the input dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factor : float, optional</span>
<span class="sd">            Controls the relative size of the corners to the length of</span>
<span class="sd">            the corresponding bounds.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh containing outlined corners.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate and plot the corners of a sphere.  This is</span>
<span class="sd">        effectively the ``(x, y, z)`` bounds of the mesh.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; corners = sphere.outline_corners(factor=0.1)</span>
<span class="sd">        &gt;&gt;&gt; pyvista.plot([sphere, corners], line_width=5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkOutlineCornerFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCornerFactor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Producing an Outline of the Corners&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">alg</span><span class="o">.</span><span class="n">GetOutputDataObject</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_geometry"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_geometry.html#pyvista.DataSetFilters.extract_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">extract_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract the outer surface of a volume or structured grid dataset.</span>

<span class="sd">        This will extract all 0D, 1D, and 2D cells producing the</span>
<span class="sd">        boundary faces of the dataset.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This tends to be less efficient than :func:`extract_surface`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Surface of the dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract the surface of a sample unstructured grid.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; hex_beam.extract_geometry()  # doctest:+SKIP</span>
<span class="sd">        PolyData (0x7f2f8c132040)</span>
<span class="sd">          N Cells:	88</span>
<span class="sd">          N Points:	90</span>
<span class="sd">          X Bounds:	0.000e+00, 1.000e+00</span>
<span class="sd">          Y Bounds:	0.000e+00, 1.000e+00</span>
<span class="sd">          Z Bounds:	0.000e+00, 5.000e+00</span>
<span class="sd">          N Arrays:	3</span>

<span class="sd">        See :ref:`surface_smoothing_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkGeometryFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extracting Geometry&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_all_edges"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_all_edges.html#pyvista.DataSetFilters.extract_all_edges">[docs]</a>    <span class="k">def</span> <span class="nf">extract_all_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract all the internal/external edges of the dataset as PolyData.</span>

<span class="sd">        This produces a full wireframe representation of the input dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Edges extracted from the dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract the edges of a sample unstructured grid and plot the edges.</span>
<span class="sd">        Note how it plots interior edges.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; edges = hex_beam.extract_all_edges()</span>
<span class="sd">        &gt;&gt;&gt; edges.plot(line_width=5, color=&#39;k&#39;)</span>

<span class="sd">        See :ref:`cell_centers_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkExtractEdges</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extracting All Edges&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.elevation"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.elevation.html#pyvista.DataSetFilters.elevation">[docs]</a>    <span class="k">def</span> <span class="nf">elevation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">low_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">high_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalar_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
        <span class="n">set_active</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate scalar values on a dataset.</span>

<span class="sd">        The scalar values lie within a user specified range, and are</span>
<span class="sd">        generated by computing a projection of each dataset point onto</span>
<span class="sd">        a line.  The line can be oriented arbitrarily.  A typical</span>
<span class="sd">        example is to generate scalars based on elevation or height</span>
<span class="sd">        above a plane.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           This will create a scalars array named ``&#39;Elevation&#39;`` on the</span>
<span class="sd">           point data of the input dataset and overwrite the array</span>
<span class="sd">           named ``&#39;Elevation&#39;`` if present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_point : tuple(float), optional</span>
<span class="sd">            The low point of the projection line in 3D space. Default is bottom</span>
<span class="sd">            center of the dataset. Otherwise pass a length 3 ``tuple(float)``.</span>

<span class="sd">        high_point : tuple(float), optional</span>
<span class="sd">            The high point of the projection line in 3D space. Default is top</span>
<span class="sd">            center of the dataset. Otherwise pass a length 3 ``tuple(float)``.</span>

<span class="sd">        scalar_range : str or tuple(float), optional</span>
<span class="sd">            The scalar range to project to the low and high points on the line</span>
<span class="sd">            that will be mapped to the dataset. If None given, the values will</span>
<span class="sd">            be computed from the elevation (Z component) range between the</span>
<span class="sd">            high and low points. Min and max of a range can be given as a length</span>
<span class="sd">            2 tuple(float). If ``str`` name of scalara array present in the</span>
<span class="sd">            dataset given, the valid range of that array will be used.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            When an array name is specified for ``scalar_range``, this is the</span>
<span class="sd">            preferred array type to search for in the dataset.</span>
<span class="sd">            Must be either ``&#39;point&#39;`` or ``&#39;cell&#39;``.</span>

<span class="sd">        set_active : bool, optional</span>
<span class="sd">            A boolean flag on whether or not to set the new</span>
<span class="sd">            ``&#39;Elevation&#39;`` scalar as the active scalars array on the</span>
<span class="sd">            output dataset.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset containing elevation scalars in the</span>
<span class="sd">            ``&quot;Elevation&quot;`` array in ``point_data``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate the &quot;elevation&quot; scalars for a sphere mesh.  This is</span>
<span class="sd">        simply the height in Z from the XY plane.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere_elv = sphere.elevation()</span>
<span class="sd">        &gt;&gt;&gt; sphere_elv.plot(smooth_shading=True)</span>

<span class="sd">        Access the first 4 elevation scalars.  This is a point-wise</span>
<span class="sd">        array containing the &quot;elevation&quot; of each point.</span>

<span class="sd">        &gt;&gt;&gt; sphere_elv[&#39;Elevation&#39;][:4]  # doctest:+SKIP</span>
<span class="sd">        array([-0.5       ,  0.5       , -0.49706897, -0.48831028], dtype=float32)</span>

<span class="sd">        See :ref:`common_filter_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Fix the projection line:</span>
        <span class="k">if</span> <span class="n">low_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">low_point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
            <span class="n">low_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">high_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high_point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
            <span class="n">high_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="c1"># Fix scalar_range:</span>
        <span class="k">if</span> <span class="n">scalar_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scalar_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">low_point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">high_point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scalar_range</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scalar_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_range</span><span class="p">(</span><span class="n">arr_var</span><span class="o">=</span><span class="n">scalar_range</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scalar_range</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scalar_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;scalar_range must have a length of two defining the min and max&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;scalar_range argument (</span><span class="si">{</span><span class="n">scalar_range</span><span class="si">}</span><span class="s1">) not understood.&#39;</span><span class="p">)</span>
        <span class="c1"># Construct the filter</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkElevationFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Set the parameters</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetScalarRange</span><span class="p">(</span><span class="n">scalar_range</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetLowPoint</span><span class="p">(</span><span class="n">low_point</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetHighPoint</span><span class="p">(</span><span class="n">high_point</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Elevation&#39;</span><span class="p">)</span>
        <span class="c1"># Decide on updating active scalars array</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">set_active</span><span class="p">:</span>
            <span class="c1"># &#39;Elevation&#39; is automatically made active by the VTK filter</span>
            <span class="n">output</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_scalars_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_scalars_name</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.contour"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.contour.html#pyvista.DataSetFilters.contour">[docs]</a>    <span class="k">def</span> <span class="nf">contour</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">isosurfaces</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compute_normals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_gradients</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_scalars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;contour&#39;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contour an input self by an array.</span>

<span class="sd">        ``isosurfaces`` can be an integer specifying the number of</span>
<span class="sd">        isosurfaces in the data range or a sequence of values for</span>
<span class="sd">        explicitly setting the isosurfaces.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        isosurfaces : int or sequence, optional</span>
<span class="sd">            Number of isosurfaces to compute across valid data range or a</span>
<span class="sd">            sequence of float values to explicitly use as the isosurfaces.</span>

<span class="sd">        scalars : str, collections.abc.Sequence, numpy.ndarray, optional</span>
<span class="sd">            Name or array of scalars to threshold on. If this is an array, the</span>
<span class="sd">            output of this filter will save them as ``&quot;Contour Data&quot;``.</span>
<span class="sd">            Defaults to currently active scalars.</span>

<span class="sd">        compute_normals : bool, optional</span>
<span class="sd">            Compute normals for the dataset.</span>

<span class="sd">        compute_gradients : bool, optional</span>
<span class="sd">            Compute gradients for the dataset.</span>

<span class="sd">        compute_scalars : bool, optional</span>
<span class="sd">            Preserves the scalar values that are being contoured.</span>

<span class="sd">        rng : tuple(float), optional</span>
<span class="sd">            If an integer number of isosurfaces is specified, this is</span>
<span class="sd">            the range over which to generate contours. Default is the</span>
<span class="sd">            scalars array&#39;s full data range.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            When ``scalars`` is specified, this is the preferred array</span>
<span class="sd">            type to search for in the dataset.  Must be either</span>
<span class="sd">            ``&#39;point&#39;`` or ``&#39;cell&#39;``.</span>

<span class="sd">        method : str, optional</span>
<span class="sd">            Specify to choose which vtk filter is used to create the contour.</span>
<span class="sd">            Must be one of ``&#39;contour&#39;``, ``&#39;marching_cubes&#39;`` and</span>
<span class="sd">            ``&#39;flying_edges&#39;``. Defaults to ``&#39;contour&#39;``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Contoured surface.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate contours for the random hills dataset.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; contours = hills.contour()</span>
<span class="sd">        &gt;&gt;&gt; contours.plot(line_width=5)</span>

<span class="sd">        Generate the surface of a mobius strip using flying edges.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; a = 0.4</span>
<span class="sd">        &gt;&gt;&gt; b = 0.1</span>
<span class="sd">        &gt;&gt;&gt; def f(x, y, z):</span>
<span class="sd">        ...     xx = x*x</span>
<span class="sd">        ...     yy = y*y</span>
<span class="sd">        ...     zz = z*z</span>
<span class="sd">        ...     xyz = x*y*z</span>
<span class="sd">        ...     xx_yy = xx + yy</span>
<span class="sd">        ...     a_xx = a*xx</span>
<span class="sd">        ...     b_yy = b*yy</span>
<span class="sd">        ...     return (</span>
<span class="sd">        ...         (xx_yy + 1) * (a_xx + b_yy)</span>
<span class="sd">        ...         + zz * (b * xx + a * yy) - 2 * (a - b) * xyz</span>
<span class="sd">        ...         - a * b * xx_yy</span>
<span class="sd">        ...     )**2 - 4 * (xx + yy) * (a_xx + b_yy - xyz * (a - b))**2</span>
<span class="sd">        &gt;&gt;&gt; n = 100</span>
<span class="sd">        &gt;&gt;&gt; x_min, y_min, z_min = -1.35, -1.7, -0.65</span>
<span class="sd">        &gt;&gt;&gt; grid = pv.UniformGrid(</span>
<span class="sd">        ...     dims=(n, n, n),</span>
<span class="sd">        ...     spacing=(abs(x_min)/n*2, abs(y_min)/n*2, abs(z_min)/n*2),</span>
<span class="sd">        ...     origin=(x_min, y_min, z_min),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = grid.points.T</span>
<span class="sd">        &gt;&gt;&gt; values = f(x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; out = grid.contour(</span>
<span class="sd">        ...     1, scalars=values, rng=[0, 0], method=&#39;flying_edges&#39;,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; out.plot(color=&#39;tan&#39;, smooth_shading=True)</span>

<span class="sd">        See :ref:`common_filter_example` or</span>
<span class="sd">        :ref:`marching_cubes_example` for more examples using this</span>
<span class="sd">        filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;contour&#39;</span><span class="p">:</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkContourFilter</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;marching_cubes&#39;</span><span class="p">:</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkMarchingCubes</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;flying_edges&#39;</span><span class="p">:</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkFlyingEdges3D</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Array-like rng expected, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="n">rng_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rng_shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;rng must be a two-length array-like, not </span><span class="si">{</span><span class="n">rng</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;rng must be a sorted min-max pair, not </span><span class="si">{</span><span class="n">rng</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scalars_name</span> <span class="o">=</span> <span class="n">scalars</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">scalars_name</span> <span class="o">=</span> <span class="s1">&#39;Contour Data&#39;</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">scalars_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">scalars</span>
        <span class="k">elif</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Invalid type for `scalars` (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span><span class="si">}</span><span class="s1">). Should be either &#39;</span>
                <span class="s1">&#39;a numpy.ndarray, a string, or None.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure the input has scalars to contour on</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_arrays</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input dataset for the contour filter must have scalar.&#39;</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeNormals</span><span class="p">(</span><span class="n">compute_normals</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeGradients</span><span class="p">(</span><span class="n">compute_gradients</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeScalars</span><span class="p">(</span><span class="n">compute_scalars</span><span class="p">)</span>
        <span class="c1"># set the array to contour on</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">scalars_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">get_array_association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars_name</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>
        <span class="c1"># NOTE: only point data is allowed? well cells works but seems buggy?</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="n">FieldAssociation</span><span class="o">.</span><span class="n">POINT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Contour filter only works on point data.&#39;</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">scalars_name</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># args: (idx, port, connection, field, name)</span>
        <span class="c1"># set the isosurfaces</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isosurfaces</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># generate values</span>
            <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_range</span><span class="p">(</span><span class="n">scalars_name</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">GenerateValues</span><span class="p">(</span><span class="n">isosurfaces</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isosurfaces</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetNumberOfContours</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">isosurfaces</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isosurfaces</span><span class="p">):</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;isosurfaces not understood.&#39;</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Contour&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>

        <span class="c1"># some of these filters fail to correctly name the array</span>
        <span class="k">if</span> <span class="n">scalars_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">point_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;Unnamed_0&#39;</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">point_data</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="n">scalars_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;Unnamed_0&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.texture_map_to_plane"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.texture_map_to_plane.html#pyvista.DataSetFilters.texture_map_to_plane">[docs]</a>    <span class="k">def</span> <span class="nf">texture_map_to_plane</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">point_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">point_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Texture Coordinates&#39;</span><span class="p">,</span>
        <span class="n">use_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Texture map this dataset to a user defined plane.</span>

<span class="sd">        This is often used to define a plane to texture map an image</span>
<span class="sd">        to this dataset.  The plane defines the spatial reference and</span>
<span class="sd">        extent of that image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin : tuple(float), optional</span>
<span class="sd">            Length 3 iterable of floats defining the XYZ coordinates of the</span>
<span class="sd">            bottom left corner of the plane.</span>

<span class="sd">        point_u : tuple(float), optional</span>
<span class="sd">            Length 3 iterable of floats defining the XYZ coordinates of the</span>
<span class="sd">            bottom right corner of the plane.</span>

<span class="sd">        point_v : tuple(float), optional</span>
<span class="sd">            Length 3 iterable of floats defining the XYZ coordinates of the</span>
<span class="sd">            top left corner of the plane.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, the new texture coordinates will be added to this</span>
<span class="sd">            dataset. If ``False`` (default), a new dataset is returned</span>
<span class="sd">            with the texture coordinates.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            The string name to give the new texture coordinates if applying</span>
<span class="sd">            the filter inplace.</span>

<span class="sd">        use_bounds : bool, optional</span>
<span class="sd">            Use the bounds to set the mapping plane by default (bottom plane</span>
<span class="sd">            of the bounding box).</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Original dataset with texture coordinates if</span>
<span class="sd">            ``inplace=True``, otherwise a copied dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See :ref:`ref_topo_map_example`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_bounds</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_bounds</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetBounds</span><span class="p">()</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>  <span class="c1"># BOTTOM LEFT CORNER</span>
            <span class="n">point_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>  <span class="c1"># BOTTOM RIGHT CORNER</span>
            <span class="n">point_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>  <span class="c1"># TOP LEFT CORNER</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTextureMapToPlane</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">point_u</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">point_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetAutomaticPlaneGeneration</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>  <span class="c1"># BOTTOM LEFT CORNER</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetPoint1</span><span class="p">(</span><span class="n">point_u</span><span class="p">)</span>  <span class="c1"># BOTTOM RIGHT CORNER</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetPoint2</span><span class="p">(</span><span class="n">point_v</span><span class="p">)</span>  <span class="c1"># TOP LEFT CORNER</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Texturing Map to Plane&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="n">t_coords</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">GetTCoords</span><span class="p">()</span>
        <span class="n">t_coords</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">otc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">GetTCoords</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">SetTCoords</span><span class="p">(</span><span class="n">t_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">AddArray</span><span class="p">(</span><span class="n">t_coords</span><span class="p">)</span>
        <span class="c1"># CRITICAL:</span>
        <span class="k">if</span> <span class="n">otc</span> <span class="ow">and</span> <span class="n">otc</span><span class="o">.</span><span class="n">GetName</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
            <span class="c1"># Add old ones back at the end if different name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">AddArray</span><span class="p">(</span><span class="n">otc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="DataSetFilters.texture_map_to_sphere"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.texture_map_to_sphere.html#pyvista.DataSetFilters.texture_map_to_sphere">[docs]</a>    <span class="k">def</span> <span class="nf">texture_map_to_sphere</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prevent_seam</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Texture Coordinates&#39;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Texture map this dataset to a user defined sphere.</span>

<span class="sd">        This is often used to define a sphere to texture map an image</span>
<span class="sd">        to this dataset. The sphere defines the spatial reference and</span>
<span class="sd">        extent of that image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : tuple(float)</span>
<span class="sd">            Length 3 iterable of floats defining the XYZ coordinates of the</span>
<span class="sd">            center of the sphere. If ``None``, this will be automatically</span>
<span class="sd">            calculated.</span>

<span class="sd">        prevent_seam : bool, optional</span>
<span class="sd">            Control how the texture coordinates are generated.  If</span>
<span class="sd">            set, the s-coordinate ranges from 0 to 1 and 1 to 0</span>
<span class="sd">            corresponding to the theta angle variation between 0 to</span>
<span class="sd">            180 and 180 to 0 degrees.  Otherwise, the s-coordinate</span>
<span class="sd">            ranges from 0 to 1 between 0 to 360 degrees.  Default</span>
<span class="sd">            ``True``.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, the new texture coordinates will be added to</span>
<span class="sd">            the dataset inplace. If ``False`` (default), a new dataset</span>
<span class="sd">            is returned with the texture coordinates.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            The string name to give the new texture coordinates if applying</span>
<span class="sd">            the filter inplace.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset containing the texture mapped to a sphere.  Return</span>
<span class="sd">            type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See :ref:`ref_texture_example`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTextureMapToSphere</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetAutomaticSphereGeneration</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetAutomaticSphereGeneration</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetCenter</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPreventSeam</span><span class="p">(</span><span class="n">prevent_seam</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Maping texture to sphere&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="n">t_coords</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">GetTCoords</span><span class="p">()</span>
        <span class="n">t_coords</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">otc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">GetTCoords</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">SetTCoords</span><span class="p">(</span><span class="n">t_coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">AddArray</span><span class="p">(</span><span class="n">t_coords</span><span class="p">)</span>
        <span class="c1"># CRITICAL:</span>
        <span class="k">if</span> <span class="n">otc</span> <span class="ow">and</span> <span class="n">otc</span><span class="o">.</span><span class="n">GetName</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
            <span class="c1"># Add old ones back at the end if different name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">AddArray</span><span class="p">(</span><span class="n">otc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="DataSetFilters.compute_cell_sizes"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.compute_cell_sizes.html#pyvista.DataSetFilters.compute_cell_sizes">[docs]</a>    <span class="k">def</span> <span class="nf">compute_cell_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute sizes for 1D (length), 2D (area) and 3D (volume) cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length : bool, optional</span>
<span class="sd">            Specify whether or not to compute the length of 1D cells.</span>

<span class="sd">        area : bool, optional</span>
<span class="sd">            Specify whether or not to compute the area of 2D cells.</span>

<span class="sd">        volume : bool, optional</span>
<span class="sd">            Specify whether or not to compute the volume of 3D cells.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with `cell_data` containing the ``&quot;Length&quot;``,</span>
<span class="sd">            ``&quot;Area&quot;``, and ``&quot;Volume&quot;`` arrays if set in the</span>
<span class="sd">            parameters.  Return type matches input.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If cells do not have a dimension (for example, the length of</span>
<span class="sd">        hexahedral cells), the corresponding array will be all zeros.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute the face area of the example airplane mesh.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; surf = examples.load_airplane()</span>
<span class="sd">        &gt;&gt;&gt; surf = surf.compute_cell_sizes(length=False, volume=False)</span>
<span class="sd">        &gt;&gt;&gt; surf.plot(show_edges=True, scalars=&#39;Area&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCellSizeFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeArea</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeVolume</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeLength</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeVertexCount</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Cell Sizes&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.cell_centers"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.cell_centers.html#pyvista.DataSetFilters.cell_centers">[docs]</a>    <span class="k">def</span> <span class="nf">cell_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate points at the center of the cells in this dataset.</span>

<span class="sd">        These points can be used for placing glyphs or vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vertex : bool</span>
<span class="sd">            Enable or disable the generation of vertex cells.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Polydata where the points are the cell centers of the</span>
<span class="sd">            original dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; mesh.point_data.clear()</span>
<span class="sd">        &gt;&gt;&gt; centers = mesh.cell_centers()</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(mesh, show_edges=True)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_points(centers, render_points_as_spheres=True,</span>
<span class="sd">        ...                       color=&#39;red&#39;, point_size=20)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`cell_centers_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCellCenters</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetVertexCells</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Generating Points at the Center of the Cells&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.glyph"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.glyph.html#pyvista.DataSetFilters.glyph">[docs]</a>    <span class="k">def</span> <span class="nf">glyph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">geom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">absolute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">clamping</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy a geometric representation (called a glyph) to the input dataset.</span>

<span class="sd">        The glyph may be oriented along the input vectors, and it may</span>
<span class="sd">        be scaled according to scalar data or vector</span>
<span class="sd">        magnitude. Passing a table of glyphs to choose from based on</span>
<span class="sd">        scalars or vector magnitudes is also supported.  The arrays</span>
<span class="sd">        used for ``orient`` and ``scale`` must be either both point data</span>
<span class="sd">        or both cell data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orient : bool or str, optional</span>
<span class="sd">            If ``True``, use the active vectors array to orient the glyphs.</span>
<span class="sd">            If string, the vector array to use to orient the glyphs.</span>
<span class="sd">            If ``False``, the glyphs will not be orientated.</span>

<span class="sd">        scale : bool, str or sequence, optional</span>
<span class="sd">            If ``True``, use the active scalars to scale the glyphs.</span>
<span class="sd">            If string, the scalar array to use to scale the glyphs.</span>
<span class="sd">            If ``False``, the glyphs will not be scaled.</span>

<span class="sd">        factor : float, optional</span>
<span class="sd">            Scale factor applied to scaling array.</span>

<span class="sd">        geom : vtk.vtkDataSet or tuple(vtk.vtkDataSet), optional</span>
<span class="sd">            The geometry to use for the glyph. If missing, an arrow glyph</span>
<span class="sd">            is used. If a sequence, the datasets inside define a table of</span>
<span class="sd">            geometries to choose from based on scalars or vectors. In this</span>
<span class="sd">            case a sequence of numbers of the same length must be passed as</span>
<span class="sd">            ``indices``. The values of the range (see ``rng``) affect lookup</span>
<span class="sd">            in the table.</span>

<span class="sd">        indices : tuple(float), optional</span>
<span class="sd">            Specifies the index of each glyph in the table for lookup in case</span>
<span class="sd">            ``geom`` is a sequence. If given, must be the same length as</span>
<span class="sd">            ``geom``. If missing, a default value of ``range(len(geom))`` is</span>
<span class="sd">            used. Indices are interpreted in terms of the scalar range</span>
<span class="sd">            (see ``rng``). Ignored if ``geom`` has length 1.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Specify tolerance in terms of fraction of bounding box length.</span>
<span class="sd">            Float value is between 0 and 1. Default is None. If ``absolute``</span>
<span class="sd">            is ``True`` then the tolerance can be an absolute distance.</span>
<span class="sd">            If ``None``, points merging as a preprocessing step is disabled.</span>

<span class="sd">        absolute : bool, optional</span>
<span class="sd">            Control if ``tolerance`` is an absolute distance or a fraction.</span>

<span class="sd">        clamping : bool, optional</span>
<span class="sd">            Turn on/off clamping of &quot;scalar&quot; values to range. Default ``False``.</span>

<span class="sd">        rng : tuple(float), optional</span>
<span class="sd">            Set the range of values to be considered by the filter</span>
<span class="sd">            when scalars values are provided.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Glyphs at either the cell centers or points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create arrow glyphs oriented by vectors and scaled by scalars.</span>
<span class="sd">        Factor parameter is used to reduce the size of the arrows.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; arrows = mesh.glyph(scale=&quot;Normals&quot;, orient=&quot;Normals&quot;, tolerance=0.05)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(arrows, color=&quot;black&quot;)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(mesh, scalars=&quot;Elevation&quot;, cmap=&quot;terrain&quot;,</span>
<span class="sd">        ...                     show_scalar_bar=False)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`glyph_example` and :ref:`glyph_table_example` for more</span>
<span class="sd">        examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># Make glyphing geometry if necessary</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arrow</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkArrowSource</span><span class="p">()</span>
            <span class="n">_update_alg</span><span class="p">(</span><span class="n">arrow</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Making Arrow&#39;</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>
        <span class="c1"># Check if a table of geometries was passed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># use default &quot;categorical&quot; indices</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">geom</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;If &quot;geom&quot; is a sequence then &quot;indices&quot; must &#39;</span>
                    <span class="s1">&#39;also be a sequence of the same length.&#39;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The sequence &quot;indices&quot; must be the same length &#39;</span> <span class="s1">&#39;as &quot;geom&quot;.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subgeom</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">)</span> <span class="k">for</span> <span class="n">subgeom</span> <span class="ow">in</span> <span class="n">geom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Only PolyData objects can be used as glyphs.&#39;</span><span class="p">)</span>
        <span class="c1"># Run the algorithm</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkGlyph3D</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># use a single glyph, ignore indices</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">subgeom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">geom</span><span class="p">):</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">subgeom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">alg</span><span class="o">.</span><span class="n">SetIndexModeToVector</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">alg</span><span class="o">.</span><span class="n">SetIndexModeToScalar</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">SetIndexModeToOff</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">scale</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">MissingDataError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No data to use for scale. scale will be set to False.&quot;</span><span class="p">)</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="n">AmbiguousDataError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="se">\n</span><span class="s2">It is unclear which one to use. scale will be set to False.&quot;</span><span class="p">)</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">alg</span><span class="o">.</span><span class="n">SetScaleModeToScaleByVector</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">alg</span><span class="o">.</span><span class="n">SetScaleModeToScaleByScalar</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetScaleModeToDataScalingOff</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orient</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="ow">and</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars_info</span><span class="o">.</span><span class="n">association</span> <span class="o">==</span> <span class="n">FieldAssociation</span><span class="o">.</span><span class="n">CELL</span><span class="p">:</span>
                <span class="n">prefer</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefer</span> <span class="o">=</span> <span class="s1">&#39;point&#39;</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="n">orient</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">prefer</span><span class="p">)</span>
            <span class="n">orient</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">orient</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_vectors</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">MissingDataError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No vector-like data to use for orient. orient will be set to False.&quot;</span><span class="p">)</span>
                <span class="n">orient</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="n">AmbiguousDataError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="se">\n</span><span class="s2">It is unclear which one to use. orient will be set to False.&quot;</span>
                <span class="p">)</span>
                <span class="n">orient</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">and</span> <span class="n">orient</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_vectors_info</span><span class="o">.</span><span class="n">association</span> <span class="o">!=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars_info</span><span class="o">.</span><span class="n">association</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both ``scale`` and ``orient`` must use point data or cell data.&quot;</span><span class="p">)</span>

        <span class="n">source_data</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="n">set_actives_on_source_data</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">scale</span> <span class="ow">and</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars_info</span><span class="o">.</span><span class="n">association</span> <span class="o">==</span> <span class="n">FieldAssociation</span><span class="o">.</span><span class="n">CELL</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">orient</span> <span class="ow">and</span> <span class="n">dataset</span><span class="o">.</span><span class="n">active_vectors_info</span><span class="o">.</span><span class="n">association</span> <span class="o">==</span> <span class="n">FieldAssociation</span><span class="o">.</span><span class="n">CELL</span>
        <span class="p">):</span>
            <span class="n">source_data</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">cell_centers</span><span class="p">()</span>
            <span class="n">set_actives_on_source_data</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Clean the points before glyphing</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">small</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">source_data</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">small</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">source_data</span><span class="o">.</span><span class="n">point_data</span><span class="p">)</span>
            <span class="n">source_data</span> <span class="o">=</span> <span class="n">small</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span>
                <span class="n">point_merging</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">merge_tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="n">lines_to_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">polys_to_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">strips_to_polys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">absolute</span><span class="o">=</span><span class="n">absolute</span><span class="p">,</span>
                <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">set_actives_on_source_data</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># upstream operations (cell to point conversion, point merging) may have unset the correct active</span>
        <span class="c1"># scalars/vectors, so set them again</span>
        <span class="k">if</span> <span class="n">set_actives_on_source_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
                <span class="n">source_data</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">active_scalars_name</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">orient</span><span class="p">:</span>
                <span class="n">source_data</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">active_vectors_name</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetRange</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetOrient</span><span class="p">(</span><span class="n">orient</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">source_data</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetVectorModeToUseVector</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetScaleFactor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetClamping</span><span class="p">(</span><span class="n">clamping</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Glyphs&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.connectivity"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.connectivity.html#pyvista.DataSetFilters.connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find and label connected bodies/volumes.</span>

<span class="sd">        This adds an ID array to the point and cell data to</span>
<span class="sd">        distinguish separate connected bodies. This applies a</span>
<span class="sd">        ``vtkConnectivityFilter`` filter which extracts cells that</span>
<span class="sd">        share common points and/or meet other connectivity criterion.</span>

<span class="sd">        Cells that share vertices and meet other connectivity</span>
<span class="sd">        criterion such as scalar range are known as a region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        largest : bool</span>
<span class="sd">            Extract the largest connected part of the mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with labeled connected bodies.  Return type</span>
<span class="sd">            matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Join two meshes together and plot their connectivity.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere() + pyvista.Sphere(center=(2, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; conn = mesh.connectivity(largest=False)</span>
<span class="sd">        &gt;&gt;&gt; conn.plot(cmap=[&#39;red&#39;, &#39;blue&#39;])</span>

<span class="sd">        See :ref:`volumetric_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkConnectivityFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">largest</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetExtractionModeToLargestRegion</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetExtractionModeToAllRegions</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetColorRegions</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Finding and Labeling Connected Bodies/Volumes.&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>

        <span class="c1"># remove regionID from the output when extraction mode is set to the</span>
        <span class="c1"># largest to avoid the VTK warning:</span>
        <span class="c1"># the Cell array RegionId ... has X tuples but there are only Y cells</span>
        <span class="k">if</span> <span class="n">largest</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;RegionId&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_largest"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_largest.html#pyvista.DataSetFilters.extract_largest">[docs]</a>    <span class="k">def</span> <span class="nf">extract_largest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract largest connected set in mesh.</span>

<span class="sd">        Can be used to reduce residues obtained when generating an</span>
<span class="sd">        isosurface.  Works only if residues are not connected (share</span>
<span class="sd">        at least one point with) the main component of the image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Largest connected set in the dataset.  Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Join two meshes together, extract the largest, and plot it.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere() + pyvista.Cube()</span>
<span class="sd">        &gt;&gt;&gt; largest = mesh.extract_largest()</span>
<span class="sd">        &gt;&gt;&gt; largest.point_data.clear()</span>
<span class="sd">        &gt;&gt;&gt; largest.cell_data.clear()</span>
<span class="sd">        &gt;&gt;&gt; largest.plot()</span>

<span class="sd">        See :ref:`volumetric_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="DataSetFilters.split_bodies"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.split_bodies.html#pyvista.DataSetFilters.split_bodies">[docs]</a>    <span class="k">def</span> <span class="nf">split_bodies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find, label, and split connected bodies/volumes.</span>

<span class="sd">        This splits different connected bodies into blocks in a</span>
<span class="sd">        :class:`pyvista.MultiBlock` dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : bool, optional</span>
<span class="sd">            A flag on whether to keep the ID arrays given by the</span>
<span class="sd">            ``connectivity`` filter.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.MultiBlock</span>
<span class="sd">            MultiBlock with a split bodies.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Split a uniform grid thresholded to be non-connected.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; dataset = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; dataset.set_active_scalars(&#39;Spatial Cell Data&#39;)</span>
<span class="sd">        &gt;&gt;&gt; threshed = dataset.threshold_percent([0.15, 0.50], invert=True)</span>
<span class="sd">        &gt;&gt;&gt; bodies = threshed.split_bodies()</span>
<span class="sd">        &gt;&gt;&gt; len(bodies)</span>
<span class="sd">        2</span>

<span class="sd">        See :ref:`split_vol_ref` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the connectivity and label different bodies</span>
        <span class="n">labeled</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;RegionId&#39;</span><span class="p">]</span>
        <span class="n">bodies</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">classifier</span><span class="p">):</span>
            <span class="c1"># Now extract it:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">labeled</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="n">vid</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">vid</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">scalars</span><span class="o">=</span><span class="s1">&#39;RegionId&#39;</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
                <span class="c1"># strange behavior:</span>
                <span class="c1"># must use this method rather than deleting from the point_data</span>
                <span class="c1"># or else object is collected.</span>
                <span class="n">b</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;RegionId&#39;</span><span class="p">)</span>
                <span class="n">b</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;RegionId&#39;</span><span class="p">)</span>
            <span class="n">bodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bodies</span></div>

<div class="viewcode-block" id="DataSetFilters.warp_by_scalar"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.warp_by_scalar.html#pyvista.DataSetFilters.warp_by_scalar">[docs]</a>    <span class="k">def</span> <span class="nf">warp_by_scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Warp the dataset&#39;s points by a point data scalars array&#39;s values.</span>

<span class="sd">        This modifies point coordinates by moving points along point</span>
<span class="sd">        normals by the scalar amount times the scale factor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars : str, optional</span>
<span class="sd">            Name of scalars to warp by. Defaults to currently active scalars.</span>

<span class="sd">        factor : float, optional</span>
<span class="sd">            A scaling factor to increase the scaling effect. Alias</span>
<span class="sd">            ``scale_factor`` also accepted - if present, overrides ``factor``.</span>

<span class="sd">        normal : sequence, optional</span>
<span class="sd">            User specified normal. If given, data normals will be</span>
<span class="sd">            ignored and the given normal will be used to project the</span>
<span class="sd">            warp.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, the points of the given dataset will be updated.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Accepts ``scale_factor`` instead of ``factor``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Warped Dataset.  Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, plot the unwarped mesh.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.download_st_helens()</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(cmap=&#39;gist_earth&#39;, show_scalar_bar=False)</span>

<span class="sd">        Now, warp the mesh by the ``&#39;Elevation&#39;`` scalars.</span>

<span class="sd">        &gt;&gt;&gt; warped = mesh.warp_by_scalar(&#39;Elevation&#39;)</span>
<span class="sd">        &gt;&gt;&gt; warped.plot(cmap=&#39;gist_earth&#39;, show_scalar_bar=False)</span>

<span class="sd">        See :ref:`surface_normal_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scale_factor&#39;</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
        <span class="n">assert_empty_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">field</span> <span class="o">=</span> <span class="n">get_array_association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="n">FieldAssociation</span><span class="o">.</span><span class="n">POINT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dataset can only by warped by a point data array.&#39;</span><span class="p">)</span>
        <span class="c1"># Run the algorithm</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkWarpScalar</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scalars</span>
        <span class="p">)</span>  <span class="c1"># args: (idx, port, connection, field, name)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetScaleFactor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetNormal</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetUseNormal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Warping by Scalar&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkImageData</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkRectilinearGrid</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;This filter cannot be applied inplace for this mesh type.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.warp_by_vector"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.warp_by_vector.html#pyvista.DataSetFilters.warp_by_vector">[docs]</a>    <span class="k">def</span> <span class="nf">warp_by_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Warp the dataset&#39;s points by a point data vectors array&#39;s values.</span>

<span class="sd">        This modifies point coordinates by moving points along point</span>
<span class="sd">        vectors by the local vector times the scale factor.</span>

<span class="sd">        A classical application of this transform is to visualize</span>
<span class="sd">        eigenmodes in mechanics.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : str, optional</span>
<span class="sd">            Name of vector to warp by. Defaults to currently active vector.</span>

<span class="sd">        factor : float, optional</span>
<span class="sd">            A scaling factor that multiplies the vectors to warp by. Can</span>
<span class="sd">            be used to enhance the warping effect.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, the function will update the mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The warped mesh resulting from the operation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Warp a sphere by vectors.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; sphere = examples.load_sphere_vectors()</span>
<span class="sd">        &gt;&gt;&gt; warped = sphere.warp_by_vector()</span>
<span class="sd">        &gt;&gt;&gt; pl = pv.Plotter(shape=(1, 2))</span>
<span class="sd">        &gt;&gt;&gt; pl.subplot(0, 0)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_text(&quot;Before warp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(sphere, color=&#39;white&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.subplot(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_text(&quot;After warp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(warped, color=&#39;white&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`warp_by_vectors_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vectors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_vectors_info</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">)</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">get_array_association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No vectors present to warp by vector.&#39;</span><span class="p">)</span>

        <span class="c1"># check that this is indeed a vector field</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Dataset can only by warped by a 3D vector point data array. &#39;</span>
                <span class="s1">&#39;The values you provided do not satisfy this requirement&#39;</span>
            <span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkWarpVector</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">vectors</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetScaleFactor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Warping by Vector&#39;</span><span class="p">)</span>
        <span class="n">warped_mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">warped_mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">warped_mesh</span></div>

<div class="viewcode-block" id="DataSetFilters.cell_data_to_point_data"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.cell_data_to_point_data.html#pyvista.DataSetFilters.cell_data_to_point_data">[docs]</a>    <span class="k">def</span> <span class="nf">cell_data_to_point_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pass_cell_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform cell data into point data.</span>

<span class="sd">        Point data are specified per node and cell data specified</span>
<span class="sd">        within cells.  Optionally, the input point data can be passed</span>
<span class="sd">        through to the output.</span>

<span class="sd">        The method of transformation is based on averaging the data</span>
<span class="sd">        values of all cells using a particular point. Optionally, the</span>
<span class="sd">        input cell data can be passed through to the output as well.</span>

<span class="sd">        See also :func:`pyvista.DataSetFilters.point_data_to_cell_data`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pass_cell_data : bool, optional</span>
<span class="sd">            If enabled, pass the input cell data through to the output.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with the point data transformed into cell data.</span>
<span class="sd">            Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First compute the face area of the example airplane mesh and</span>
<span class="sd">        show the cell values.  This is to show discrete cell data.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; surf = examples.load_airplane()</span>
<span class="sd">        &gt;&gt;&gt; surf = surf.compute_cell_sizes(length=False, volume=False)</span>
<span class="sd">        &gt;&gt;&gt; surf.plot(scalars=&#39;Area&#39;)</span>

<span class="sd">        These cell scalars can be applied to individual points to</span>
<span class="sd">        effectively smooth out the cell data onto the points.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; surf = examples.load_airplane()</span>
<span class="sd">        &gt;&gt;&gt; surf = surf.compute_cell_sizes(length=False, volume=False)</span>
<span class="sd">        &gt;&gt;&gt; surf = surf.cell_data_to_point_data()</span>
<span class="sd">        &gt;&gt;&gt; surf.plot(scalars=&#39;Area&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCellDataToPointData</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassCellData</span><span class="p">(</span><span class="n">pass_cell_data</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Transforming cell data into point data.&#39;</span><span class="p">)</span>
        <span class="n">active_scalars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">):</span>
            <span class="n">active_scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_name</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">active_scalars</span><span class="o">=</span><span class="n">active_scalars</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.ctp"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.ctp.html#pyvista.DataSetFilters.ctp">[docs]</a>    <span class="k">def</span> <span class="nf">ctp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pass_cell_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform cell data into point data.</span>

<span class="sd">        Point data are specified per node and cell data specified</span>
<span class="sd">        within cells.  Optionally, the input point data can be passed</span>
<span class="sd">        through to the output.</span>

<span class="sd">        This method is an alias for</span>
<span class="sd">        :func:`pyvista.DataSetFilters.cell_data_to_point_data`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pass_cell_data : bool, optional</span>
<span class="sd">            If enabled, pass the input cell data through to the output.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with the cell data transformed into point data.</span>
<span class="sd">            Return type matches input.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">cell_data_to_point_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pass_cell_data</span><span class="o">=</span><span class="n">pass_cell_data</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.point_data_to_cell_data"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.point_data_to_cell_data.html#pyvista.DataSetFilters.point_data_to_cell_data">[docs]</a>    <span class="k">def</span> <span class="nf">point_data_to_cell_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pass_point_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform point data into cell data.</span>

<span class="sd">        Point data are specified per node and cell data specified within cells.</span>
<span class="sd">        Optionally, the input point data can be passed through to the output.</span>

<span class="sd">        See also: :func:`pyvista.DataSetFilters.cell_data_to_point_data`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pass_point_data : bool, optional</span>
<span class="sd">            If enabled, pass the input point data through to the output.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with the point data transformed into cell data.</span>
<span class="sd">            Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Color cells by their z coordinates.  First, create point</span>
<span class="sd">        scalars based on z-coordinates of a sample sphere mesh.  Then</span>
<span class="sd">        convert this point data to cell data.  Use a low resolution</span>
<span class="sd">        sphere for emphasis of cell valued data.</span>

<span class="sd">        First, plot these values as point values to show the</span>
<span class="sd">        difference between point and cell data.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(theta_resolution=10, phi_resolution=10)</span>
<span class="sd">        &gt;&gt;&gt; sphere[&#39;Z Coordinates&#39;] = sphere.points[:, 2]</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot()</span>

<span class="sd">        Now, convert these values to cell data and then plot it.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(theta_resolution=10, phi_resolution=10)</span>
<span class="sd">        &gt;&gt;&gt; sphere[&#39;Z Coordinates&#39;] = sphere.points[:, 2]</span>
<span class="sd">        &gt;&gt;&gt; sphere = sphere.point_data_to_cell_data()</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPointDataToCellData</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassPointData</span><span class="p">(</span><span class="n">pass_point_data</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Transforming point data into cell data&#39;</span><span class="p">)</span>
        <span class="n">active_scalars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">):</span>
            <span class="n">active_scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_name</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">active_scalars</span><span class="o">=</span><span class="n">active_scalars</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.ptc"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.ptc.html#pyvista.DataSetFilters.ptc">[docs]</a>    <span class="k">def</span> <span class="nf">ptc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pass_point_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform point data into cell data.</span>

<span class="sd">        Point data are specified per node and cell data specified</span>
<span class="sd">        within cells.  Optionally, the input point data can be passed</span>
<span class="sd">        through to the output.</span>

<span class="sd">        This method is an alias for</span>
<span class="sd">        :func:`pyvista.DataSetFilters.point_data_to_cell_data`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pass_point_data : bool, optional</span>
<span class="sd">            If enabled, pass the input point data through to the output.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with the point data transformed into cell data.</span>
<span class="sd">            Return type matches input.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">point_data_to_cell_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pass_point_data</span><span class="o">=</span><span class="n">pass_point_data</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.triangulate"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.triangulate.html#pyvista.DataSetFilters.triangulate">[docs]</a>    <span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an all triangle mesh.</span>

<span class="sd">        More complex polygons will be broken down into triangles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh containing only triangles.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate a mesh with quadrilateral faces.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; plane.point_data.clear()</span>
<span class="sd">        &gt;&gt;&gt; plane.plot(show_edges=True, line_width=5)</span>

<span class="sd">        Convert it to an all triangle mesh.</span>

<span class="sd">        &gt;&gt;&gt; mesh = plane.triangulate()</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True, line_width=5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetTriangleFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Converting to triangle mesh&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="DataSetFilters.delaunay_3d"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.delaunay_3d.html#pyvista.DataSetFilters.delaunay_3d">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a 3D Delaunay triangulation of the mesh.</span>

<span class="sd">        This filter can be used to generate a 3D tetrahedral mesh from</span>
<span class="sd">        a surface or scattered points.  If you want to create a</span>
<span class="sd">        surface from a point cloud, see</span>
<span class="sd">        :func:`pyvista.PolyDataFilters.reconstruct_surface`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Distance value to control output of this filter. For a</span>
<span class="sd">            non-zero alpha value, only vertices, edges, faces, or</span>
<span class="sd">            tetrahedra contained within the circumsphere (of radius</span>
<span class="sd">            alpha) will be output. Otherwise, only tetrahedra will be</span>
<span class="sd">            output.</span>

<span class="sd">        tol : float, optional</span>
<span class="sd">            Tolerance to control discarding of closely spaced points.</span>
<span class="sd">            This tolerance is specified as a fraction of the diagonal</span>
<span class="sd">            length of the bounding box of the points.</span>

<span class="sd">        offset : float, optional</span>
<span class="sd">            Multiplier to control the size of the initial, bounding</span>
<span class="sd">            Delaunay triangulation.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            UnstructuredGrid containing the Delaunay triangulation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate a 3D Delaunay triangulation of a surface mesh of a</span>
<span class="sd">        sphere and plot the interior edges generated.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(theta_resolution=5, phi_resolution=5)</span>
<span class="sd">        &gt;&gt;&gt; grid = sphere.delaunay_3d()</span>
<span class="sd">        &gt;&gt;&gt; edges = grid.extract_all_edges()</span>
<span class="sd">        &gt;&gt;&gt; edges.plot(line_width=5, color=&#39;k&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDelaunay3D</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetAlpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing 3D Triangulation&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.select_enclosed_points"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.select_enclosed_points.html#pyvista.DataSetFilters.select_enclosed_points">[docs]</a>    <span class="k">def</span> <span class="nf">select_enclosed_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">inside_out</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark points as to whether they are inside a closed surface.</span>

<span class="sd">        This evaluates all the input points to determine whether they are in an</span>
<span class="sd">        enclosed surface. The filter produces a (0,1) mask</span>
<span class="sd">        (in the form of a vtkDataArray) that indicates whether points are</span>
<span class="sd">        outside (mask value=0) or inside (mask value=1) a provided surface.</span>
<span class="sd">        (The name of the output vtkDataArray is ``&quot;SelectedPoints&quot;``.)</span>

<span class="sd">        This filter produces and output data array, but does not modify the</span>
<span class="sd">        input dataset. If you wish to extract cells or poinrs, various</span>
<span class="sd">        threshold filters are available (i.e., threshold the output array).</span>

<span class="sd">        .. warning::</span>
<span class="sd">           The filter assumes that the surface is closed and</span>
<span class="sd">           manifold. A boolean flag can be set to force the filter to</span>
<span class="sd">           first check whether this is true. If ``False`` and not manifold,</span>
<span class="sd">           an error will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        surface : pyvista.PolyData</span>
<span class="sd">            Set the surface to be used to test for containment. This must be a</span>
<span class="sd">            :class:`pyvista.PolyData` object.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance on the intersection. The tolerance is expressed as a</span>
<span class="sd">            fraction of the bounding box of the enclosing surface.</span>

<span class="sd">        inside_out : bool, optional</span>
<span class="sd">            By default, points inside the surface are marked inside or sent</span>
<span class="sd">            to the output. If ``inside_out`` is ``True``, then the points</span>
<span class="sd">            outside the surface are marked inside.</span>

<span class="sd">        check_surface : bool, optional</span>
<span class="sd">            Specify whether to check the surface for closure. If on, then the</span>
<span class="sd">            algorithm first checks to see if the surface is closed and</span>
<span class="sd">            manifold. If the surface is not closed and manifold, a runtime</span>
<span class="sd">            error is raised.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh containing the ``point_data[&#39;SelectedPoints&#39;]`` array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Determine which points on a plane are inside a manifold sphere</span>
<span class="sd">        surface mesh.  Extract these points using the</span>
<span class="sd">        :func:`DataSetFilters.extract_points` filter and then plot them.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; selected = plane.select_enclosed_points(sphere)</span>
<span class="sd">        &gt;&gt;&gt; pts = plane.extract_points(selected[&#39;SelectedPoints&#39;].view(bool),</span>
<span class="sd">        ...                            adjacent_cells=False)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_points(pts, color=&#39;r&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`surface` must be `pyvista.PolyData`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_surface</span> <span class="ow">and</span> <span class="n">surface</span><span class="o">.</span><span class="n">n_open_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Surface is not closed. Please read the warning in the &quot;</span>
                <span class="s2">&quot;documentation for this function and either pass &quot;</span>
                <span class="s2">&quot;`check_surface=False` or repair the surface.&quot;</span>
            <span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectEnclosedPoints</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSurfaceData</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInsideOut</span><span class="p">(</span><span class="n">inside_out</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Selecting Enclosed Points&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bools</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;SelectedPoints&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bools</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bools</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;SelectedPoints&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bools</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="DataSetFilters.probe"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.probe.html#pyvista.DataSetFilters.probe">[docs]</a>    <span class="k">def</span> <span class="nf">probe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pass_cell_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pass_point_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">categorical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">locator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample data values at specified point locations.</span>

<span class="sd">        This uses :class:`vtk.vtkProbeFilter`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : pyvista.DataSet</span>
<span class="sd">            The points to probe values on to. This should be a PyVista mesh</span>
<span class="sd">            or something :func:`pyvista.wrap` can handle.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is</span>
<span class="sd">            in a cell of the input.  If not given, tolerance is</span>
<span class="sd">            automatically generated.</span>

<span class="sd">        pass_cell_arrays : bool, optional</span>
<span class="sd">            Preserve source mesh&#39;s original cell data arrays.</span>

<span class="sd">        pass_point_arrays : bool, optional</span>
<span class="sd">            Preserve source mesh&#39;s original point data arrays.</span>

<span class="sd">        categorical : bool, optional</span>
<span class="sd">            Control whether the source point data is to be treated as</span>
<span class="sd">            categorical. If the data is categorical, then the resultant data</span>
<span class="sd">            will be determined by a nearest neighbor interpolation scheme.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        locator : vtkAbstractCellLocator, optional</span>
<span class="sd">            Prototype cell locator to perform the ``FindCell()``</span>
<span class="sd">            operation.  This requires VTK 9.0.0 or newer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset containing the probed data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Probe the active scalars in ``grid`` at the points in ``mesh``.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = pv.Sphere(center=(4.5, 4.5, 4.5), radius=4.5)</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; result = grid.probe(mesh)</span>
<span class="sd">        &gt;&gt;&gt; &#39;Spatial Point Data&#39; in result.point_data</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">is_pyvista_dataset</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkProbeFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassCellArrays</span><span class="p">(</span><span class="n">pass_cell_arrays</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassPointArrays</span><span class="p">(</span><span class="n">pass_point_arrays</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCategoricalData</span><span class="p">(</span><span class="n">categorical</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeTolerance</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">locator</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">9</span><span class="p">,):</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s2">&quot;Cell locator requires VTK v9.0.0 or newer&quot;</span><span class="p">)</span>

            <span class="n">alg</span><span class="o">.</span><span class="n">SetCellLocatorPrototype</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Sampling Data Values at Specified Point Locations&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.sample"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.sample.html#pyvista.DataSetFilters.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pass_cell_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pass_point_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">categorical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample array data from a passed mesh onto this mesh.</span>

<span class="sd">        This uses :class:`vtk.vtkResampleWithDataSet`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : pyvista.DataSet</span>
<span class="sd">            The vtk data object to sample from - point and cell arrays from</span>
<span class="sd">            this object are sampled onto the nodes of the ``dataset`` mesh.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is</span>
<span class="sd">            in a cell of the input.  If not given, tolerance is</span>
<span class="sd">            automatically generated.</span>

<span class="sd">        pass_cell_arrays : bool, optional</span>
<span class="sd">            Preserve source mesh&#39;s original cell data arrays.</span>

<span class="sd">        pass_point_data : bool, optional</span>
<span class="sd">            Preserve source mesh&#39;s original point data arrays.</span>

<span class="sd">        categorical : bool, optional</span>
<span class="sd">            Control whether the source point data is to be treated as</span>
<span class="sd">            categorical. If the data is categorical, then the resultant data</span>
<span class="sd">            will be determined by a nearest neighbor interpolation scheme.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset containing resampled data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Resample data from another dataset onto a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere(center=(4.5, 4.5, 4.5), radius=4.5)</span>
<span class="sd">        &gt;&gt;&gt; data_to_probe = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; result = mesh.sample(data_to_probe)</span>
<span class="sd">        &gt;&gt;&gt; result.plot(scalars=&quot;Spatial Point Data&quot;)</span>

<span class="sd">        See :ref:`resampling_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">is_pyvista_dataset</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`target` must be a PyVista mesh type.&#39;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkResampleWithDataSet</span><span class="p">()</span>  <span class="c1"># Construct the ResampleWithDataSet object</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Set the Input data (actually the source i.e. where to sample from)</span>
        <span class="c1"># Set the Source data (actually the target, i.e. where to sample to)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassCellArrays</span><span class="p">(</span><span class="n">pass_cell_arrays</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassPointArrays</span><span class="p">(</span><span class="n">pass_point_data</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCategoricalData</span><span class="p">(</span><span class="n">categorical</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeTolerance</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Resampling array Data from a Passed Mesh onto Mesh&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.interpolate"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.interpolate.html#pyvista.DataSetFilters.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">,</span>
        <span class="n">sharpness</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;null_value&#39;</span><span class="p">,</span>
        <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">n_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pass_cell_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pass_point_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate values onto this mesh from a given dataset.</span>

<span class="sd">        The input dataset is typically a point cloud.</span>

<span class="sd">        This uses a Gaussian interpolation kernel. Use the ``sharpness`` and</span>
<span class="sd">        ``radius`` parameters to adjust this kernel. You can also switch this</span>
<span class="sd">        kernel to use an N closest points approach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : pyvista.DataSet</span>
<span class="sd">            The vtk data object to sample from. Point and cell arrays from</span>
<span class="sd">            this object are interpolated onto this mesh.</span>

<span class="sd">        sharpness : float, optional</span>
<span class="sd">            Set the sharpness (i.e., falloff) of the Gaussian</span>
<span class="sd">            kernel. By default ``sharpness=2``. As the sharpness</span>
<span class="sd">            increases the effects of distant points are reduced.</span>

<span class="sd">        radius : float, optional</span>
<span class="sd">            Specify the radius within which the basis points must lie.</span>

<span class="sd">        strategy : str, optional</span>
<span class="sd">            Specify a strategy to use when encountering a &quot;null&quot; point during</span>
<span class="sd">            the interpolation process. Null points occur when the local</span>
<span class="sd">            neighborhood (of nearby points to interpolate from) is empty. If</span>
<span class="sd">            the strategy is set to ``&#39;mask_points&#39;``, then an output array is</span>
<span class="sd">            created that marks points as being valid (=1) or null (invalid</span>
<span class="sd">            =0) (and the NullValue is set as well). If the strategy is set to</span>
<span class="sd">            ``&#39;null_value&#39;`` (this is the default), then the output data</span>
<span class="sd">            value(s) are set to the ``null_value`` (specified in the output</span>
<span class="sd">            point data). Finally, the strategy ``&#39;closest_point&#39;`` is to simply</span>
<span class="sd">            use the closest point to perform the interpolation.</span>

<span class="sd">        null_value : float, optional</span>
<span class="sd">            Specify the null point value. When a null point is encountered</span>
<span class="sd">            then all components of each null tuple are set to this value. By</span>
<span class="sd">            default the null value is set to zero.</span>

<span class="sd">        n_points : int, optional</span>
<span class="sd">            If given, specifies the number of the closest points used to form</span>
<span class="sd">            the interpolation basis. This will invalidate the radius argument</span>
<span class="sd">            in favor of an N closest points approach. This typically has poorer</span>
<span class="sd">            results.</span>

<span class="sd">        pass_cell_arrays : bool, optional</span>
<span class="sd">            Preserve input mesh&#39;s original cell data arrays.</span>

<span class="sd">        pass_point_data : bool, optional</span>
<span class="sd">            Preserve input mesh&#39;s original point data arrays.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Interpolated dataset.  Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Interpolate the values of 5 points onto a sample plane.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(7)</span>
<span class="sd">        &gt;&gt;&gt; point_cloud = np.random.random((5, 3))</span>
<span class="sd">        &gt;&gt;&gt; point_cloud[:, 2] = 0</span>
<span class="sd">        &gt;&gt;&gt; point_cloud -= point_cloud.mean(0)</span>
<span class="sd">        &gt;&gt;&gt; pdata = pyvista.PolyData(point_cloud)</span>
<span class="sd">        &gt;&gt;&gt; pdata[&#39;values&#39;] = np.random.random(5)</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; plane.clear_data()</span>
<span class="sd">        &gt;&gt;&gt; plane = plane.interpolate(pdata, sharpness=3)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(pdata, render_points_as_spheres=True, point_size=50)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(plane, style=&#39;wireframe&#39;, line_width=5)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`interpolate_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">is_pyvista_dataset</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`target` must be a PyVista mesh type.&#39;</span><span class="p">)</span>

        <span class="c1"># Must cast to UnstructuredGrid in some cases (e.g. vtkImageData/vtkRectilinearGrid)</span>
        <span class="c1"># I believe the locator and the interpolator call `GetPoints` and not all mesh types have that method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">pyvista</span><span class="o">.</span><span class="n">UniformGrid</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">RectilinearGrid</span><span class="p">)):</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">cast_to_unstructured_grid</span><span class="p">()</span>

        <span class="n">gaussian_kernel</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkGaussianKernel</span><span class="p">()</span>
        <span class="n">gaussian_kernel</span><span class="o">.</span><span class="n">SetSharpness</span><span class="p">(</span><span class="n">sharpness</span><span class="p">)</span>
        <span class="n">gaussian_kernel</span><span class="o">.</span><span class="n">SetRadius</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">gaussian_kernel</span><span class="o">.</span><span class="n">SetKernelFootprintToRadius</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n_points</span><span class="p">:</span>
            <span class="n">gaussian_kernel</span><span class="o">.</span><span class="n">SetNumberOfPoints</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
            <span class="n">gaussian_kernel</span><span class="o">.</span><span class="n">SetKernelFootprintToNClosest</span><span class="p">()</span>

        <span class="n">locator</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStaticPointLocator</span><span class="p">()</span>
        <span class="n">locator</span><span class="o">.</span><span class="n">SetDataSet</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">locator</span><span class="o">.</span><span class="n">BuildLocator</span><span class="p">()</span>

        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPointInterpolator</span><span class="p">()</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetKernel</span><span class="p">(</span><span class="n">gaussian_kernel</span><span class="p">)</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetLocator</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetNullValue</span><span class="p">(</span><span class="n">null_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;null_value&#39;</span><span class="p">:</span>
            <span class="n">interpolator</span><span class="o">.</span><span class="n">SetNullPointsStrategyToNullValue</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;mask_points&#39;</span><span class="p">:</span>
            <span class="n">interpolator</span><span class="o">.</span><span class="n">SetNullPointsStrategyToMaskPoints</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;closest_point&#39;</span><span class="p">:</span>
            <span class="n">interpolator</span><span class="o">.</span><span class="n">SetNullPointsStrategyToClosestPoint</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;strategy `</span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s1">` not supported.&#39;</span><span class="p">)</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetPassPointArrays</span><span class="p">(</span><span class="n">pass_point_data</span><span class="p">)</span>
        <span class="n">interpolator</span><span class="o">.</span><span class="n">SetPassCellArrays</span><span class="p">(</span><span class="n">pass_cell_arrays</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">interpolator</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Interpolating&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">interpolator</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.streamlines"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.streamlines.html#pyvista.DataSetFilters.streamlines">[docs]</a>    <span class="k">def</span> <span class="nf">streamlines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source_center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">start_position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_source</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">pointa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pointb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrate a vector field to generate streamlines.</span>

<span class="sd">        The default behavior uses a sphere as the source - set its</span>
<span class="sd">        location and radius via the ``source_center`` and</span>
<span class="sd">        ``source_radius`` keyword arguments.  ``n_points`` defines the</span>
<span class="sd">        number of starting points on the sphere surface.</span>
<span class="sd">        Alternatively, a line source can be used by specifying</span>
<span class="sd">        ``pointa`` and ``pointb``.  ``n_points`` again defines the</span>
<span class="sd">        number of points on the line.</span>

<span class="sd">        You can retrieve the source by specifying</span>
<span class="sd">        ``return_source=True``.</span>

<span class="sd">        Optional keyword parameters from</span>
<span class="sd">        :func:`pyvista.DataSetFilters.streamlines_from_source` can be</span>
<span class="sd">        used here to control the generation of streamlines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : str, optional</span>
<span class="sd">            The string name of the active vector field to integrate across.</span>

<span class="sd">        source_center : tuple(float), optional</span>
<span class="sd">            Length 3 tuple of floats defining the center of the source</span>
<span class="sd">            particles. Defaults to the center of the dataset.</span>

<span class="sd">        source_radius : float, optional</span>
<span class="sd">            Float radius of the source particle cloud. Defaults to one-tenth of</span>
<span class="sd">            the diagonal of the dataset&#39;s spatial extent.</span>

<span class="sd">        n_points : int, optional</span>
<span class="sd">            Number of particles present in source sphere or line.</span>

<span class="sd">        start_position : tuple(float), optional</span>
<span class="sd">            A single point.  This will override the sphere point source.</span>

<span class="sd">        return_source : bool, optional</span>
<span class="sd">            Return the source particles as :class:`pyvista.PolyData` as well as the</span>
<span class="sd">            streamlines. This will be the second value returned if ``True``.</span>

<span class="sd">        pointa, pointb : tuple(float), optional</span>
<span class="sd">            The coordinates of a start and end point for a line source. This</span>
<span class="sd">            will override the sphere and start_position point source.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :func:`pyvista.DataSetFilters.streamlines_from_source`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        streamlines : pyvista.PolyData</span>
<span class="sd">            This produces polylines as the output, with each cell</span>
<span class="sd">            (i.e., polyline) representing a streamline. The attribute values</span>
<span class="sd">            associated with each streamline are stored in the cell data, whereas</span>
<span class="sd">            those associated with streamline-points are stored in the point data.</span>

<span class="sd">        source : pyvista.PolyData</span>
<span class="sd">            The points of the source are the seed points for the streamlines.</span>
<span class="sd">            Only returned if ``return_source=True``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See the :ref:`streamlines_example` example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source_center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">if</span> <span class="n">source_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">10.0</span>

        <span class="c1"># A single point at start_position</span>
        <span class="k">if</span> <span class="n">start_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_center</span> <span class="o">=</span> <span class="n">start_position</span>
            <span class="n">source_radius</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">n_points</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pointa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pointb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pointa</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pointb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both pointa and pointb must be provided&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pointa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pointb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkLineSource</span><span class="p">()</span>
            <span class="n">source</span><span class="o">.</span><span class="n">SetPoint1</span><span class="p">(</span><span class="n">pointa</span><span class="p">)</span>
            <span class="n">source</span><span class="o">.</span><span class="n">SetPoint2</span><span class="p">(</span><span class="n">pointb</span><span class="p">)</span>
            <span class="n">source</span><span class="o">.</span><span class="n">SetResolution</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPointSource</span><span class="p">()</span>
            <span class="n">source</span><span class="o">.</span><span class="n">SetCenter</span><span class="p">(</span><span class="n">source_center</span><span class="p">)</span>
            <span class="n">source</span><span class="o">.</span><span class="n">SetRadius</span><span class="p">(</span><span class="n">source_radius</span><span class="p">)</span>
            <span class="n">source</span><span class="o">.</span><span class="n">SetNumberOfPoints</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
        <span class="n">source</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">input_source</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlines_from_source</span><span class="p">(</span>
            <span class="n">input_source</span><span class="p">,</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_source</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">input_source</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.streamlines_from_source"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.streamlines_from_source.html#pyvista.DataSetFilters.streamlines_from_source">[docs]</a>    <span class="k">def</span> <span class="nf">streamlines_from_source</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">integrator_type</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span>
        <span class="n">integration_direction</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span>
        <span class="n">surface_streamlines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">initial_step_length</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">step_unit</span><span class="o">=</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span>
        <span class="n">min_step_length</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">max_step_length</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
        <span class="n">terminal_speed</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span>
        <span class="n">max_error</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compute_vorticity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rotation_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">interpolator_type</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate streamlines of vectors from the points of a source mesh.</span>

<span class="sd">        The integration is performed using a specified integrator, by default</span>
<span class="sd">        Runge-Kutta2. This supports integration through any type of dataset.</span>
<span class="sd">        If the dataset contains 2D cells like polygons or triangles and the</span>
<span class="sd">        ``surface_streamlines`` parameter is used, the integration is constrained</span>
<span class="sd">        to lie on the surface defined by 2D cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source : pyvista.DataSet</span>
<span class="sd">            The points of the source provide the starting points of the</span>
<span class="sd">            streamlines.  This will override both sphere and line sources.</span>

<span class="sd">        vectors : str, optional</span>
<span class="sd">            The string name of the active vector field to integrate across.</span>

<span class="sd">        integrator_type : {45, 2, 4}, optional</span>
<span class="sd">            The integrator type to be used for streamline generation.</span>
<span class="sd">            The default is Runge-Kutta45. The recognized solvers are:</span>
<span class="sd">            RUNGE_KUTTA2 (``2``),  RUNGE_KUTTA4 (``4``), and RUNGE_KUTTA45</span>
<span class="sd">            (``45``). Options are ``2``, ``4``, or ``45``. Default is ``45``.</span>

<span class="sd">        integration_direction : str, optional</span>
<span class="sd">            Specify whether the streamline is integrated in the upstream or</span>
<span class="sd">            downstream directions (or both). Options are ``&#39;both&#39;``,</span>
<span class="sd">            ``&#39;backward&#39;``, or ``&#39;forward&#39;``.</span>

<span class="sd">        surface_streamlines : bool, optional</span>
<span class="sd">            Compute streamlines on a surface. Default ``False``.</span>

<span class="sd">        initial_step_length : float, optional</span>
<span class="sd">            Initial step size used for line integration, expressed ib length</span>
<span class="sd">            unitsL or cell length units (see ``step_unit`` parameter).</span>
<span class="sd">            either the starting size for an adaptive integrator, e.g., RK45, or</span>
<span class="sd">            the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4).</span>

<span class="sd">        step_unit : {&#39;cl&#39;, &#39;l&#39;}, optional</span>
<span class="sd">            Uniform integration step unit. The valid unit is now limited to</span>
<span class="sd">            only LENGTH_UNIT (``&#39;l&#39;``) and CELL_LENGTH_UNIT (``&#39;cl&#39;``).</span>
<span class="sd">            Default is CELL_LENGTH_UNIT: ``&#39;cl&#39;``.</span>

<span class="sd">        min_step_length : float, optional</span>
<span class="sd">            Minimum step size used for line integration, expressed in length or</span>
<span class="sd">            cell length units. Only valid for an adaptive integrator, e.g., RK45.</span>

<span class="sd">        max_step_length : float, optional</span>
<span class="sd">            Maximum step size used for line integration, expressed in length or</span>
<span class="sd">            cell length units. Only valid for an adaptive integrator, e.g., RK45.</span>

<span class="sd">        max_steps : int, optional</span>
<span class="sd">            Maximum number of steps for integrating a streamline.</span>
<span class="sd">            Defaults to ``2000``.</span>

<span class="sd">        terminal_speed : float, optional</span>
<span class="sd">            Terminal speed value, below which integration is terminated.</span>

<span class="sd">        max_error : float, optional</span>
<span class="sd">            Maximum error tolerated throughout streamline integration.</span>

<span class="sd">        max_time : float, optional</span>
<span class="sd">            Specify the maximum length of a streamline expressed in LENGTH_UNIT.</span>

<span class="sd">        compute_vorticity : bool, optional</span>
<span class="sd">            Vorticity computation at streamline points. Necessary for generating</span>
<span class="sd">            proper stream-ribbons using the ``vtkRibbonFilter``.</span>

<span class="sd">        rotation_scale : float, optional</span>
<span class="sd">            This can be used to scale the rate with which the streamribbons</span>
<span class="sd">            twist. The default is 1.</span>

<span class="sd">        interpolator_type : str, optional</span>
<span class="sd">            Set the type of the velocity field interpolator to locate cells</span>
<span class="sd">            during streamline integration either by points or cells.</span>
<span class="sd">            The cell locator is more robust then the point locator. Options</span>
<span class="sd">            are ``&#39;point&#39;`` or ``&#39;cell&#39;`` (abbreviations of ``&#39;p&#39;`` and ``&#39;c&#39;``</span>
<span class="sd">            are also supported).</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Streamlines. This produces polylines as the output, with</span>
<span class="sd">            each cell (i.e., polyline) representing a streamline. The</span>
<span class="sd">            attribute values associated with each streamline are</span>
<span class="sd">            stored in the cell data, whereas those associated with</span>
<span class="sd">            streamline-points are stored in the point data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See the :ref:`streamlines_example` example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integration_direction</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">integration_direction</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integration_direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">,</span> <span class="s1">&#39;forward&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Integration direction must be one of:</span><span class="se">\n</span><span class="s2"> &#39;backward&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;forward&#39;, or &#39;both&#39; - not &#39;</span><span class="si">{</span><span class="n">integration_direction</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">integrator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">45</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Integrator type must be one of `2`, `4`, or `45`.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interpolator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Interpolator type must be either &#39;cell&#39; or &#39;point&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step_unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;cl&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Step unit must be either &#39;l&#39; or &#39;cl&#39;&quot;</span><span class="p">)</span>
        <span class="n">step_unit</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;cl&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStreamTracer</span><span class="o">.</span><span class="n">CELL_LENGTH_UNIT</span><span class="p">,</span>
            <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStreamTracer</span><span class="o">.</span><span class="n">LENGTH_UNIT</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">step_unit</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">vectors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_range</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">max_time</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetLength</span><span class="p">()</span> <span class="o">/</span> <span class="n">max_velocity</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">DataSet</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;source must be a pyvista.DataSet&quot;</span><span class="p">)</span>

        <span class="c1"># vtk throws error with two Structured Grids</span>
        <span class="c1"># See: https://github.com/pyvista/pyvista/issues/1373</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">StructuredGrid</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">StructuredGrid</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast_to_unstructured_grid</span><span class="p">()</span>

        <span class="c1"># Build the algorithm</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStreamTracer</span><span class="p">()</span>
        <span class="c1"># Inputs</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

        <span class="c1"># general parameters</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeVorticity</span><span class="p">(</span><span class="n">compute_vorticity</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInitialIntegrationStep</span><span class="p">(</span><span class="n">initial_step_length</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegrationStepUnit</span><span class="p">(</span><span class="n">step_unit</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumError</span><span class="p">(</span><span class="n">max_error</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumIntegrationStep</span><span class="p">(</span><span class="n">max_step_length</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumNumberOfSteps</span><span class="p">(</span><span class="n">max_steps</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumPropagation</span><span class="p">(</span><span class="n">max_time</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMinimumIntegrationStep</span><span class="p">(</span><span class="n">min_step_length</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetRotationScale</span><span class="p">(</span><span class="n">rotation_scale</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSurfaceStreamlines</span><span class="p">(</span><span class="n">surface_streamlines</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTerminalSpeed</span><span class="p">(</span><span class="n">terminal_speed</span><span class="p">)</span>
        <span class="c1"># Model parameters</span>
        <span class="k">if</span> <span class="n">integration_direction</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegrationDirectionToForward</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">integration_direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;backward&#39;</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">]:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegrationDirectionToBackward</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegrationDirectionToBoth</span><span class="p">()</span>
        <span class="c1"># set integrator type</span>
        <span class="k">if</span> <span class="n">integrator_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegratorTypeToRungeKutta2</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">integrator_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegratorTypeToRungeKutta4</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegratorTypeToRungeKutta45</span><span class="p">()</span>
        <span class="c1"># set interpolator type</span>
        <span class="k">if</span> <span class="n">interpolator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">]:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetInterpolatorTypeToCellLocator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetInterpolatorTypeToDataSetPointLocator</span><span class="p">()</span>
        <span class="c1"># run the algorithm</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Generating Streamlines&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.streamlines_evenly_spaced_2D"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.streamlines_evenly_spaced_2D.html#pyvista.DataSetFilters.streamlines_evenly_spaced_2D">[docs]</a>    <span class="k">def</span> <span class="nf">streamlines_evenly_spaced_2D</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">integrator_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">step_length</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">step_unit</span><span class="o">=</span><span class="s1">&#39;cl&#39;</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
        <span class="n">terminal_speed</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span>
        <span class="n">interpolator_type</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
        <span class="n">separating_distance</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">separating_distance_ratio</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">closed_loop_maximum_distance</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">loop_angle</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">minimum_number_of_loop_points</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">compute_vorticity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate evenly spaced streamlines on a 2D dataset.</span>

<span class="sd">        This filter only supports datasets that lie on the xy plane, i.e. ``z=0``.</span>
<span class="sd">        Particular care must be used to choose a `separating_distance`</span>
<span class="sd">        that do not result in too much memory being utilized.  The</span>
<span class="sd">        default unit is cell length.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This filter is unstable for ``vtk&lt;9.0``.</span>
<span class="sd">            See `pyvista issue 1508 &lt;https://github.com/pyvista/pyvista/issues/1508&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : str, optional</span>
<span class="sd">            The string name of the active vector field to integrate across.</span>

<span class="sd">        start_position : sequence(float), optional</span>
<span class="sd">            The seed point for generating evenly spaced streamlines.</span>
<span class="sd">            If not supplied, a random position in the dataset is chosen.</span>

<span class="sd">        integrator_type : {2, 4}, optional</span>
<span class="sd">            The integrator type to be used for streamline generation.</span>
<span class="sd">            The default is Runge-Kutta2. The recognized solvers are:</span>
<span class="sd">            RUNGE_KUTTA2 (``2``) and RUNGE_KUTTA4 (``4``).</span>

<span class="sd">        step_length : float, optional</span>
<span class="sd">            Constant Step size used for line integration, expressed in length</span>
<span class="sd">            units or cell length units (see ``step_unit`` parameter).</span>

<span class="sd">        step_unit : {&#39;cl&#39;, &#39;l&#39;}, optional</span>
<span class="sd">            Uniform integration step unit. The valid unit is now limited to</span>
<span class="sd">            only LENGTH_UNIT (``&#39;l&#39;``) and CELL_LENGTH_UNIT (``&#39;cl&#39;``).</span>
<span class="sd">            Default is CELL_LENGTH_UNIT: ``&#39;cl&#39;``.</span>

<span class="sd">        max_steps : int, optional</span>
<span class="sd">            Maximum number of steps for integrating a streamline.</span>
<span class="sd">            Defaults to ``2000``.</span>

<span class="sd">        terminal_speed : float, optional</span>
<span class="sd">            Terminal speed value, below which integration is terminated.</span>

<span class="sd">        interpolator_type : str, optional</span>
<span class="sd">            Set the type of the velocity field interpolator to locate cells</span>
<span class="sd">            during streamline integration either by points or cells.</span>
<span class="sd">            The cell locator is more robust then the point locator. Options</span>
<span class="sd">            are ``&#39;point&#39;`` or ``&#39;cell&#39;`` (abbreviations of ``&#39;p&#39;`` and ``&#39;c&#39;``</span>
<span class="sd">            are also supported).</span>

<span class="sd">        separating_distance : float, optional</span>
<span class="sd">            The distance between streamlines expressed in ``step_unit``.</span>

<span class="sd">        separating_distance_ratio : float, optional</span>
<span class="sd">            Streamline integration is stopped if streamlines are closer than</span>
<span class="sd">            ``SeparatingDistance*SeparatingDistanceRatio`` to other streamlines.</span>

<span class="sd">        closed_loop_maximum_distance : float, optional</span>
<span class="sd">            The distance between points on a streamline to determine a</span>
<span class="sd">            closed loop.</span>

<span class="sd">        loop_angle : float, optional</span>
<span class="sd">            The maximum angle in degrees between points to determine a closed loop.</span>

<span class="sd">        minimum_number_of_loop_points : int, optional</span>
<span class="sd">            The minimum number of points before which a closed loop will</span>
<span class="sd">            be determined.</span>

<span class="sd">        compute_vorticity : bool, optional</span>
<span class="sd">            Vorticity computation at streamline points. Necessary for generating</span>
<span class="sd">            proper stream-ribbons using the ``vtkRibbonFilter``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            This produces polylines as the output, with each cell</span>
<span class="sd">            (i.e., polyline) representing a streamline. The attribute</span>
<span class="sd">            values associated with each streamline are stored in the</span>
<span class="sd">            cell data, whereas those associated with streamline-points</span>
<span class="sd">            are stored in the point data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Plot evenly spaced streamlines for cylinder in a crossflow.</span>
<span class="sd">        This dataset is a multiblock dataset, and the fluid velocity is in the</span>
<span class="sd">        first block.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.download_cylinder_crossflow()</span>
<span class="sd">        &gt;&gt;&gt; streams = mesh[0].streamlines_evenly_spaced_2D(start_position=(4, 0.1, 0.),</span>
<span class="sd">        ...                                                separating_distance=3,</span>
<span class="sd">        ...                                                separating_distance_ratio=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plotter = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = plotter.add_mesh(streams.tube(radius=0.02), scalars=&quot;vorticity_mag&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plotter.view_xy()</span>
<span class="sd">        &gt;&gt;&gt; plotter.show()</span>

<span class="sd">        See :ref:`2d_streamlines_example` for more examples using this filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">integrator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Integrator type must be one of `2` or `4`.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interpolator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Interpolator type must be either &#39;cell&#39; or &#39;point&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step_unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;cl&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Step unit must be either &#39;l&#39; or &#39;cl&#39;&quot;</span><span class="p">)</span>
        <span class="n">step_unit</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;cl&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStreamTracer</span><span class="o">.</span><span class="n">CELL_LENGTH_UNIT</span><span class="p">,</span>
            <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStreamTracer</span><span class="o">.</span><span class="n">LENGTH_UNIT</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">step_unit</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">vectors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">loop_angle</span> <span class="o">=</span> <span class="n">loop_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="c1"># Build the algorithm</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkEvenlySpacedStreamlines2D</span><span class="p">()</span>
        <span class="c1"># Inputs</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Seed for starting position</span>
        <span class="k">if</span> <span class="n">start_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetStartPosition</span><span class="p">(</span><span class="n">start_position</span><span class="p">)</span>

        <span class="c1"># Integrator controls</span>
        <span class="k">if</span> <span class="n">integrator_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegratorTypeToRungeKutta2</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegratorTypeToRungeKutta4</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInitialIntegrationStep</span><span class="p">(</span><span class="n">step_length</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetIntegrationStepUnit</span><span class="p">(</span><span class="n">step_unit</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumNumberOfSteps</span><span class="p">(</span><span class="n">max_steps</span><span class="p">)</span>

        <span class="c1"># Stopping criteria</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTerminalSpeed</span><span class="p">(</span><span class="n">terminal_speed</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetClosedLoopMaximumDistance</span><span class="p">(</span><span class="n">closed_loop_maximum_distance</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetLoopAngle</span><span class="p">(</span><span class="n">loop_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMinimumNumberOfLoopPoints</span><span class="p">(</span><span class="n">minimum_number_of_loop_points</span><span class="p">)</span>

        <span class="c1"># Separation criteria</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSeparatingDistance</span><span class="p">(</span><span class="n">separating_distance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">separating_distance_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetSeparatingDistanceRatio</span><span class="p">(</span><span class="n">separating_distance_ratio</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeVorticity</span><span class="p">(</span><span class="n">compute_vorticity</span><span class="p">)</span>

        <span class="c1"># Set interpolator type</span>
        <span class="k">if</span> <span class="n">interpolator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">]:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetInterpolatorTypeToCellLocator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetInterpolatorTypeToDataSetPointLocator</span><span class="p">()</span>

        <span class="c1"># Run the algorithm</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Generating Evenly Spaced Streamlines on a 2D Dataset&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.decimate_boundary"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.decimate_boundary.html#pyvista.DataSetFilters.decimate_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">decimate_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_reduction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a decimated version of a triangulation of the boundary.</span>

<span class="sd">        Only the outer surface of the input dataset will be considered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_reduction : float</span>
<span class="sd">            Fraction of the original mesh to remove. Default is ``0.5``</span>
<span class="sd">            TargetReduction is set to ``0.9``, this filter will try to reduce</span>
<span class="sd">            the data set to 10% of its original size and will remove 90%</span>
<span class="sd">            of the input triangles.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Decimated boundary.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See the :ref:`linked_views_example` example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_geometry</span><span class="p">(</span><span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
            <span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>
            <span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">target_reduction</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.sample_over_line"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.sample_over_line.html#pyvista.DataSetFilters.sample_over_line">[docs]</a>    <span class="k">def</span> <span class="nf">sample_over_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset onto a line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pointa : sequence</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        pointb : sequence</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide line into. Defaults to number of cells</span>
<span class="sd">            in the input mesh. Must be a positive integer.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is in a</span>
<span class="sd">            cell of the input.  If not given, tolerance is automatically generated.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Line object with sampled data from dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sample over a plane that is interpolating a point cloud.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(12)</span>
<span class="sd">        &gt;&gt;&gt; point_cloud = np.random.random((5, 3))</span>
<span class="sd">        &gt;&gt;&gt; point_cloud[:, 2] = 0</span>
<span class="sd">        &gt;&gt;&gt; point_cloud -= point_cloud.mean(0)</span>
<span class="sd">        &gt;&gt;&gt; pdata = pyvista.PolyData(point_cloud)</span>
<span class="sd">        &gt;&gt;&gt; pdata[&#39;values&#39;] = np.random.random(5)</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; plane.clear_data()</span>
<span class="sd">        &gt;&gt;&gt; plane = plane.interpolate(pdata, sharpness=3.5)</span>
<span class="sd">        &gt;&gt;&gt; sample = plane.sample_over_line((-0.5, -0.5, 0), (0.5, 0.5, 0))</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(pdata, render_points_as_spheres=True, point_size=50)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sample, scalars=&#39;values&#39;, line_width=10)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(plane, scalars=&#39;values&#39;, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
        <span class="c1"># Make a line and sample the dataset</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Line</span><span class="p">(</span><span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">sampled_line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sampled_line</span></div>

<div class="viewcode-block" id="DataSetFilters.plot_over_line"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.plot_over_line.html#pyvista.DataSetFilters.plot_over_line">[docs]</a>    <span class="k">def</span> <span class="nf">plot_over_line</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pointa</span><span class="p">,</span>
        <span class="n">pointb</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset along a high resolution line and plot.</span>

<span class="sd">        Plot the variables of interest in 2D using matplotlib where the</span>
<span class="sd">        X-axis is distance from Point A and the Y-axis is the variable</span>
<span class="sd">        of interest. Note that this filter returns ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pointa : sequence</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        pointb : sequence</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide line into. Defaults to number of cells</span>
<span class="sd">            in the input mesh. Must be a positive integer.</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            The string name of the variable in the input dataset to probe. The</span>
<span class="sd">            active scalar is used by default.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            The string title of the matplotlib figure.</span>

<span class="sd">        ylabel : str, optional</span>
<span class="sd">            The string label of the Y-axis. Defaults to variable name.</span>

<span class="sd">        figsize : tuple(int), optional</span>
<span class="sd">            The size of the new figure.</span>

<span class="sd">        figure : bool, optional</span>
<span class="sd">            Flag on whether or not to create a new figure.</span>

<span class="sd">        show : bool, optional</span>
<span class="sd">            Shows the matplotlib figure.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is in a</span>
<span class="sd">            cell of the input.  If not given, tolerance is automatically generated.</span>

<span class="sd">        fname : str, optional</span>
<span class="sd">            Save the figure this file name when set.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See the :ref:`plot_over_line_example` example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure matplotlib is available</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;matplotlib must be available to use this filter.&#39;</span><span class="p">)</span>

        <span class="c1"># Sample on line</span>
        <span class="n">sampled</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">sample_over_line</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span>

        <span class="c1"># Get variable of interest</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">sampled</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">sampled</span><span class="p">[</span><span class="s1">&#39;Distance&#39;</span><span class="p">]</span>

        <span class="c1"># Remainder is plotting</span>
        <span class="k">if</span> <span class="n">figure</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="c1"># Plot it in 2D</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Distance&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">scalars</span><span class="si">}</span><span class="s1"> Profile&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="DataSetFilters.sample_over_multiple_lines"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.sample_over_multiple_lines.html#pyvista.DataSetFilters.sample_over_multiple_lines">[docs]</a>    <span class="k">def</span> <span class="nf">sample_over_multiple_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset onto a multiple lines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : np.ndarray or list</span>
<span class="sd">            List of points defining multiple lines.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is in a</span>
<span class="sd">            cell of the input.  If not given, tolerance is automatically generated.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Line object with sampled data from dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sample over a plane that is interpolating a point cloud.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(12)</span>
<span class="sd">        &gt;&gt;&gt; point_cloud = np.random.random((5, 3))</span>
<span class="sd">        &gt;&gt;&gt; point_cloud[:, 2] = 0</span>
<span class="sd">        &gt;&gt;&gt; point_cloud -= point_cloud.mean(0)</span>
<span class="sd">        &gt;&gt;&gt; pdata = pyvista.PolyData(point_cloud)</span>
<span class="sd">        &gt;&gt;&gt; pdata[&#39;values&#39;] = np.random.random(5)</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; plane.clear_data()</span>
<span class="sd">        &gt;&gt;&gt; plane = plane.interpolate(pdata, sharpness=3.5)</span>
<span class="sd">        &gt;&gt;&gt; sample = plane.sample_over_multiple_lines([[-0.5, -0.5, 0], [0.5, -0.5, 0], [0.5, 0.5, 0]])</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(pdata, render_points_as_spheres=True, point_size=50)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sample, scalars=&#39;values&#39;, line_width=10)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(plane, scalars=&#39;values&#39;, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a multiple lines and sample the dataset</span>
        <span class="n">multiple_lines</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultipleLines</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="n">sampled_multiple_lines</span> <span class="o">=</span> <span class="n">multiple_lines</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">sampled_multiple_lines</span></div>

<div class="viewcode-block" id="DataSetFilters.sample_over_circular_arc"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.sample_over_circular_arc.html#pyvista.DataSetFilters.sample_over_circular_arc">[docs]</a>    <span class="k">def</span> <span class="nf">sample_over_circular_arc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset over a circular arc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pointa : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        pointb : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        center : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide circular arc into. Defaults to</span>
<span class="sd">            number of cells in the input mesh. Must be a positive</span>
<span class="sd">            integer.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is</span>
<span class="sd">            in a cell of the input.  If not given, tolerance is</span>
<span class="sd">            automatically generated.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Arc containing the sampled data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sample a dataset over a circular arc and plot it.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; uniform = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; uniform[&quot;height&quot;] = uniform.points[:, 2]</span>
<span class="sd">        &gt;&gt;&gt; pointa = [uniform.bounds[1], uniform.bounds[2], uniform.bounds[5]]</span>
<span class="sd">        &gt;&gt;&gt; pointb = [uniform.bounds[1], uniform.bounds[3], uniform.bounds[4]]</span>
<span class="sd">        &gt;&gt;&gt; center = [uniform.bounds[1], uniform.bounds[2], uniform.bounds[4]]</span>
<span class="sd">        &gt;&gt;&gt; sampled_arc = uniform.sample_over_circular_arc(pointa, pointb, center)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(uniform, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sampled_arc, line_width=10)</span>
<span class="sd">        &gt;&gt;&gt; pl.show_axes()</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
        <span class="c1"># Make a circular arc and sample the dataset</span>
        <span class="n">circular_arc</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">CircularArc</span><span class="p">(</span><span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">sampled_circular_arc</span> <span class="o">=</span> <span class="n">circular_arc</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">sampled_circular_arc</span></div>

<div class="viewcode-block" id="DataSetFilters.sample_over_circular_arc_normal"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.sample_over_circular_arc_normal.html#pyvista.DataSetFilters.sample_over_circular_arc_normal">[docs]</a>    <span class="k">def</span> <span class="nf">sample_over_circular_arc_normal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset over a circular arc defined by a normal and polar vector and plot it.</span>

<span class="sd">        The number of segments composing the polyline is controlled by</span>
<span class="sd">        setting the object resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide circular arc into. Defaults to</span>
<span class="sd">            number of cells in the input mesh. Must be a positive</span>
<span class="sd">            integer.</span>

<span class="sd">        normal : np.ndarray or list, optional</span>
<span class="sd">            The normal vector to the plane of the arc.  By default it</span>
<span class="sd">            points in the positive Z direction.</span>

<span class="sd">        polar : np.ndarray or list, optional</span>
<span class="sd">            Starting point of the arc in polar coordinates.  By</span>
<span class="sd">            default it is the unit vector in the positive x direction.</span>

<span class="sd">        angle : float, optional</span>
<span class="sd">            Arc length (in degrees), beginning at the polar vector.  The</span>
<span class="sd">            direction is counterclockwise.  By default it is 360.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is</span>
<span class="sd">            in a cell of the input.  If not given, tolerance is</span>
<span class="sd">            automatically generated.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Sampled Dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sample a dataset over a circular arc.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; uniform = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; uniform[&quot;height&quot;] = uniform.points[:, 2]</span>
<span class="sd">        &gt;&gt;&gt; normal = [0, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; polar = [0, 9, 0]</span>
<span class="sd">        &gt;&gt;&gt; center = [uniform.bounds[1], uniform.bounds[2], uniform.bounds[5]]</span>
<span class="sd">        &gt;&gt;&gt; arc = uniform.sample_over_circular_arc_normal(center, normal=normal,</span>
<span class="sd">        ...                                               polar=polar)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(uniform, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(arc, line_width=10)</span>
<span class="sd">        &gt;&gt;&gt; pl.show_axes()</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>
        <span class="c1"># Make a circular arc and sample the dataset</span>
        <span class="n">circular_arc</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">CircularArcFromNormal</span><span class="p">(</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="n">normal</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="n">polar</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">circular_arc</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.plot_over_circular_arc"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.plot_over_circular_arc.html#pyvista.DataSetFilters.plot_over_circular_arc">[docs]</a>    <span class="k">def</span> <span class="nf">plot_over_circular_arc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pointa</span><span class="p">,</span>
        <span class="n">pointb</span><span class="p">,</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset along a circular arc and plot it.</span>

<span class="sd">        Plot the variables of interest in 2D where the X-axis is</span>
<span class="sd">        distance from Point A and the Y-axis is the variable of</span>
<span class="sd">        interest. Note that this filter returns ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pointa : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        pointb : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        center : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide the circular arc into. Defaults</span>
<span class="sd">            to number of cells in the input mesh. Must be a positive</span>
<span class="sd">            integer.</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            The string name of the variable in the input dataset to</span>
<span class="sd">            probe. The active scalar is used by default.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            The string title of the ``matplotlib`` figure.</span>

<span class="sd">        ylabel : str, optional</span>
<span class="sd">            The string label of the Y-axis. Defaults to the variable name.</span>

<span class="sd">        figsize : tuple(int), optional</span>
<span class="sd">            The size of the new figure.</span>

<span class="sd">        figure : bool, optional</span>
<span class="sd">            Flag on whether or not to create a new figure.</span>

<span class="sd">        show : bool, optional</span>
<span class="sd">            Shows the ``matplotlib`` figure when ``True``.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is</span>
<span class="sd">            in a cell of the input.  If not given, tolerance is</span>
<span class="sd">            automatically generated.</span>

<span class="sd">        fname : str, optional</span>
<span class="sd">            Save the figure this file name when set.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sample a dataset along a high resolution circular arc and plot.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; a = [mesh.bounds[0], mesh.bounds[2], mesh.bounds[5]]</span>
<span class="sd">        &gt;&gt;&gt; b = [mesh.bounds[1], mesh.bounds[2], mesh.bounds[4]]</span>
<span class="sd">        &gt;&gt;&gt; center = [mesh.bounds[0], mesh.bounds[2], mesh.bounds[4]]</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot_over_circular_arc(a, b, center, resolution=1000, show=False)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure matplotlib is available</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;matplotlib must be installed to use this filter.&#39;</span><span class="p">)</span>

        <span class="c1"># Sample on circular arc</span>
        <span class="n">sampled</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">sample_over_circular_arc</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">pointa</span><span class="p">,</span> <span class="n">pointb</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span>

        <span class="c1"># Get variable of interest</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">sampled</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">sampled</span><span class="p">[</span><span class="s1">&#39;Distance&#39;</span><span class="p">]</span>

        <span class="c1"># create the matplotlib figure</span>
        <span class="k">if</span> <span class="n">figure</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="c1"># Plot it in 2D</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Distance&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">scalars</span><span class="si">}</span><span class="s1"> Profile&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="DataSetFilters.plot_over_circular_arc_normal"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.plot_over_circular_arc_normal.html#pyvista.DataSetFilters.plot_over_circular_arc_normal">[docs]</a>    <span class="k">def</span> <span class="nf">plot_over_circular_arc_normal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample a dataset along a resolution circular arc defined by a normal and polar vector and plot it.</span>

<span class="sd">        Plot the variables of interest in 2D where the X-axis is</span>
<span class="sd">        distance from Point A and the Y-axis is the variable of</span>
<span class="sd">        interest. Note that this filter returns ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : np.ndarray or list</span>
<span class="sd">            Location in ``[x, y, z]``.</span>

<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide circular arc into. Defaults to</span>
<span class="sd">            number of cells in the input mesh. Must be a positive</span>
<span class="sd">            integer.</span>

<span class="sd">        normal : np.ndarray or list, optional</span>
<span class="sd">            The normal vector to the plane of the arc.  By default it</span>
<span class="sd">            points in the positive Z direction.</span>

<span class="sd">        polar : np.ndarray or list, optional</span>
<span class="sd">            Starting point of the arc in polar coordinates.  By</span>
<span class="sd">            default it is the unit vector in the positive x direction.</span>

<span class="sd">        angle : float, optional</span>
<span class="sd">            Arc length (in degrees), beginning at the polar vector.  The</span>
<span class="sd">            direction is counterclockwise.  By default it is 360.</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            The string name of the variable in the input dataset to</span>
<span class="sd">            probe. The active scalar is used by default.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            The string title of the `matplotlib` figure.</span>

<span class="sd">        ylabel : str, optional</span>
<span class="sd">            The string label of the Y-axis. Defaults to variable name.</span>

<span class="sd">        figsize : tuple(int), optional</span>
<span class="sd">            The size of the new figure.</span>

<span class="sd">        figure : bool, optional</span>
<span class="sd">            Flag on whether or not to create a new figure.</span>

<span class="sd">        show : bool, optional</span>
<span class="sd">            Shows the matplotlib figure.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to compute whether a point in the source is</span>
<span class="sd">            in a cell of the input.  If not given, tolerance is</span>
<span class="sd">            automatically generated.</span>

<span class="sd">        fname : str, optional</span>
<span class="sd">            Save the figure this file name when set.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Sample a dataset along a high resolution circular arc and plot.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.load_uniform()</span>
<span class="sd">        &gt;&gt;&gt; normal = normal = [0, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; polar = [0, 9, 0]</span>
<span class="sd">        &gt;&gt;&gt; angle = 90</span>
<span class="sd">        &gt;&gt;&gt; center = [mesh.bounds[0], mesh.bounds[2], mesh.bounds[4]]</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot_over_circular_arc_normal(center, polar=polar, angle=angle)  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure matplotlib is available</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;matplotlib must be installed to use this filter.&#39;</span><span class="p">)</span>

        <span class="c1"># Sample on circular arc</span>
        <span class="n">sampled</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">sample_over_circular_arc_normal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span>

        <span class="c1"># Get variable of interest</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">sampled</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">sampled</span><span class="p">[</span><span class="s1">&#39;Distance&#39;</span><span class="p">]</span>

        <span class="c1"># create the matplotlib figure</span>
        <span class="k">if</span> <span class="n">figure</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="c1"># Plot it in 2D</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Distance&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">scalars</span><span class="si">}</span><span class="s1"> Profile&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_cells"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_cells.html#pyvista.DataSetFilters.extract_cells">[docs]</a>    <span class="k">def</span> <span class="nf">extract_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset of the grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : np.ndarray</span>
<span class="sd">            Numpy array of cell indices to be extracted.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            Subselected grid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; subset = grid.extract_cells(range(20))</span>
<span class="sd">        &gt;&gt;&gt; subset.n_cells</span>
<span class="sd">        20</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(grid, style=&#39;wireframe&#39;, line_width=5, color=&#39;black&#39;)</span>
<span class="sd">        &gt;&gt;&gt; actor = pl.add_mesh(subset, color=&#39;grey&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create selection objects</span>
        <span class="n">selectionNode</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="p">()</span>
        <span class="n">selectionNode</span><span class="o">.</span><span class="n">SetFieldType</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="o">.</span><span class="n">CELL</span><span class="p">)</span>
        <span class="n">selectionNode</span><span class="o">.</span><span class="n">SetContentType</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="o">.</span><span class="n">INDICES</span><span class="p">)</span>
        <span class="n">selectionNode</span><span class="o">.</span><span class="n">SetSelectionList</span><span class="p">(</span><span class="n">numpy_to_idarr</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>

        <span class="n">selection</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelection</span><span class="p">()</span>
        <span class="n">selection</span><span class="o">.</span><span class="n">AddNode</span><span class="p">(</span><span class="n">selectionNode</span><span class="p">)</span>

        <span class="c1"># extract</span>
        <span class="n">extract_sel</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkExtractSelection</span><span class="p">()</span>
        <span class="n">extract_sel</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">extract_sel</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">extract_sel</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extracting Cells&#39;</span><span class="p">)</span>
        <span class="n">subgrid</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">extract_sel</span><span class="p">)</span>

        <span class="c1"># extracts only in float32</span>
        <span class="k">if</span> <span class="n">subgrid</span><span class="o">.</span><span class="n">n_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">subgrid</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;vtkOriginalPointIds&#39;</span><span class="p">]</span>
                <span class="n">subgrid</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">subgrid</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_points"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_points.html#pyvista.DataSetFilters.extract_points">[docs]</a>    <span class="k">def</span> <span class="nf">extract_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">adjacent_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset of the grid (with cells) that contains any of the given point indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind : np.ndarray, list, or sequence</span>
<span class="sd">            Numpy array of point indices to be extracted.</span>
<span class="sd">        adjacent_cells : bool, optional</span>
<span class="sd">            If ``True``, extract the cells that contain at least one of</span>
<span class="sd">            the extracted points. If ``False``, extract the cells that</span>
<span class="sd">            contain exclusively points from the extracted points list.</span>
<span class="sd">            The default is ``True``.</span>
<span class="sd">        include_cells : bool, optional</span>
<span class="sd">            Specifies if the cells shall be returned or not. The default</span>
<span class="sd">            is ``True``.</span>
<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            Subselected grid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract all the points of a sphere with a Z coordinate greater than 0</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; extracted = sphere.extract_points(sphere.points[:, 2] &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; extracted.clear_data()  # clear for plotting</span>
<span class="sd">        &gt;&gt;&gt; extracted.plot()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create selection objects</span>
        <span class="n">selectionNode</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="p">()</span>
        <span class="n">selectionNode</span><span class="o">.</span><span class="n">SetFieldType</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="o">.</span><span class="n">POINT</span><span class="p">)</span>
        <span class="n">selectionNode</span><span class="o">.</span><span class="n">SetContentType</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="o">.</span><span class="n">INDICES</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_cells</span><span class="p">:</span>
            <span class="n">adjacent_cells</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adjacent_cells</span><span class="p">:</span>
            <span class="c1"># Build array of point indices to be removed.</span>
            <span class="n">ind_rem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            <span class="n">ind_rem</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">)[</span><span class="n">ind_rem</span><span class="p">]</span>
            <span class="c1"># Invert selection</span>
            <span class="n">selectionNode</span><span class="o">.</span><span class="n">GetProperties</span><span class="p">()</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="o">.</span><span class="n">INVERSE</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">selectionNode</span><span class="o">.</span><span class="n">SetSelectionList</span><span class="p">(</span><span class="n">numpy_to_idarr</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">include_cells</span><span class="p">:</span>
            <span class="n">selectionNode</span><span class="o">.</span><span class="n">GetProperties</span><span class="p">()</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelectionNode</span><span class="o">.</span><span class="n">CONTAINING_CELLS</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">selection</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSelection</span><span class="p">()</span>
        <span class="n">selection</span><span class="o">.</span><span class="n">AddNode</span><span class="p">(</span><span class="n">selectionNode</span><span class="p">)</span>

        <span class="c1"># extract</span>
        <span class="n">extract_sel</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkExtractSelection</span><span class="p">()</span>
        <span class="n">extract_sel</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">extract_sel</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">extract_sel</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extracting Points&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">extract_sel</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_surface"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_surface.html#pyvista.DataSetFilters.extract_surface">[docs]</a>    <span class="k">def</span> <span class="nf">extract_surface</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pass_pointid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pass_cellid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonlinear_subdivision</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract surface mesh of the grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pass_pointid : bool, optional</span>
<span class="sd">            Adds a point array ``&quot;vtkOriginalPointIds&quot;`` that</span>
<span class="sd">            idenfities which original points these surface points</span>
<span class="sd">            correspond to.</span>

<span class="sd">        pass_cellid : bool, optional</span>
<span class="sd">            Adds a cell array ``&quot;vtkOriginalPointIds&quot;`` that</span>
<span class="sd">            idenfities which original cells these surface cells</span>
<span class="sd">            correspond to.</span>

<span class="sd">        nonlinear_subdivision : int, optional</span>
<span class="sd">            If the input is an unstructured grid with nonlinear faces,</span>
<span class="sd">            this parameter determines how many times the face is</span>
<span class="sd">            subdivided into linear faces.</span>

<span class="sd">            If 0, the output is the equivalent of its linear</span>
<span class="sd">            counterpart (and the midpoints determining the nonlinear</span>
<span class="sd">            interpolation are discarded). If 1 (the default), the</span>
<span class="sd">            nonlinear face is triangulated based on the midpoints. If</span>
<span class="sd">            greater than 1, the triangulated pieces are recursively</span>
<span class="sd">            subdivided to reach the desired subdivision. Setting the</span>
<span class="sd">            value to greater than 1 may cause some point data to not</span>
<span class="sd">            be passed even if no nonlinear faces exist. This option</span>
<span class="sd">            has no effect if the input is not an unstructured grid.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Surface mesh of the grid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract the surface of an UnstructuredGrid.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_hexbeam()</span>
<span class="sd">        &gt;&gt;&gt; surf = grid.extract_surface()</span>
<span class="sd">        &gt;&gt;&gt; type(surf)</span>
<span class="sd">        &lt;class &#39;pyvista.core.pointset.PolyData&#39;&gt;</span>

<span class="sd">        See the :ref:`extract_surface_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">surf_filter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSetSurfaceFilter</span><span class="p">()</span>
        <span class="n">surf_filter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">surf_filter</span><span class="o">.</span><span class="n">SetPassThroughPointIds</span><span class="p">(</span><span class="n">pass_pointid</span><span class="p">)</span>
        <span class="n">surf_filter</span><span class="o">.</span><span class="n">SetPassThroughCellIds</span><span class="p">(</span><span class="n">pass_cellid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nonlinear_subdivision</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">surf_filter</span><span class="o">.</span><span class="n">SetNonlinearSubdivisionLevel</span><span class="p">(</span><span class="n">nonlinear_subdivision</span><span class="p">)</span>

        <span class="c1"># available in 9.0.2</span>
        <span class="c1"># surf_filter.SetDelegation(delegation)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">surf_filter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extracting Surface&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">surf_filter</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.surface_indices"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.surface_indices.html#pyvista.DataSetFilters.surface_indices">[docs]</a>    <span class="k">def</span> <span class="nf">surface_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the surface indices of a grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Indices of the surface points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Return the first 10 surface indices of an UnstructuredGrid.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; grid = examples.load_hexbeam()</span>
<span class="sd">        &gt;&gt;&gt; ind = grid.surface_indices()</span>
<span class="sd">        &gt;&gt;&gt; ind[:10]  # doctest:+SKIP</span>
<span class="sd">        pyvista_ndarray([ 0,  2, 36, 27,  7,  8, 81,  1, 18,  4])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pass_cellid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surf</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;vtkOriginalPointIds&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="DataSetFilters.extract_feature_edges"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.extract_feature_edges.html#pyvista.DataSetFilters.extract_feature_edges">[docs]</a>    <span class="k">def</span> <span class="nf">extract_feature_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">feature_angle</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">boundary_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">non_manifold_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">feature_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">manifold_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract edges from the surface of the mesh.</span>

<span class="sd">        If the given mesh is not PolyData, the external surface of the given</span>
<span class="sd">        mesh is extracted and used.</span>

<span class="sd">        From vtk documentation, the edges are one of the following:</span>

<span class="sd">            1) Boundary (used by one polygon) or a line cell.</span>
<span class="sd">            2) Non-manifold (used by three or more polygons).</span>
<span class="sd">            3) Feature edges (edges used by two triangles and whose</span>
<span class="sd">               dihedral angle &gt; feature_angle).</span>
<span class="sd">            4) Manifold edges (edges used by exactly two polygons).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        feature_angle : float, optional</span>
<span class="sd">            Feature angle (in degrees) used to detect sharp edges on</span>
<span class="sd">            the mesh. Used only when ``feature_edges=True``.  Defaults</span>
<span class="sd">            to 30 degrees.</span>

<span class="sd">        boundary_edges : bool, optional</span>
<span class="sd">            Extract the boundary edges. Defaults to ``True``.</span>

<span class="sd">        non_manifold_edges : bool, optional</span>
<span class="sd">            Extract non-manifold edges. Defaults to ``True``.</span>

<span class="sd">        feature_edges : bool, optional</span>
<span class="sd">            Extract edges exceeding ``feature_angle``.  Defaults to</span>
<span class="sd">            ``True``.</span>

<span class="sd">        manifold_edges : bool, optional</span>
<span class="sd">            Extract manifold edges. Defaults to ``True``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Extracted edges.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extract the edges from an unstructured grid.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hex_beam = pyvista.read(examples.hexbeamfile)</span>
<span class="sd">        &gt;&gt;&gt; feat_edges = hex_beam.extract_feature_edges()</span>
<span class="sd">        &gt;&gt;&gt; feat_edges.clear_data()  # clear array data for plotting</span>
<span class="sd">        &gt;&gt;&gt; feat_edges.plot(line_width=10)</span>

<span class="sd">        See the :ref:`extract_edges_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="n">featureEdges</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkFeatureEdges</span><span class="p">()</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="n">feature_angle</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetManifoldEdges</span><span class="p">(</span><span class="n">manifold_edges</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetNonManifoldEdges</span><span class="p">(</span><span class="n">non_manifold_edges</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetBoundaryEdges</span><span class="p">(</span><span class="n">boundary_edges</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetFeatureEdges</span><span class="p">(</span><span class="n">feature_edges</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetColoring</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">featureEdges</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extracting Feature Edges&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">featureEdges</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.merge"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.merge.html#pyvista.DataSetFilters.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">main_has_priority</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Join one or many other grids to this grid.</span>

<span class="sd">        Grid is updated in-place by default.</span>

<span class="sd">        Can be used to merge points of adjacent cells when no grids</span>
<span class="sd">        are input.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The ``+`` operator between two meshes uses this filter with</span>
<span class="sd">           the default parameters. When the target mesh is already a</span>
<span class="sd">           :class:`pyvista.UnstructuredGrid`, in-place merging via</span>
<span class="sd">           ``+=`` is similarly possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid : vtk.UnstructuredGrid or list of vtk.UnstructuredGrids</span>
<span class="sd">            Grids to merge to this grid.</span>

<span class="sd">        merge_points : bool, optional</span>
<span class="sd">            Points in exactly the same location will be merged between</span>
<span class="sd">            the two meshes. Warning: this can leave degenerate point data.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates grid inplace when True if the input type is an</span>
<span class="sd">            :class:`pyvista.UnstructuredGrid`.</span>

<span class="sd">        main_has_priority : bool, optional</span>
<span class="sd">            When this parameter is true and merge_points is true,</span>
<span class="sd">            the arrays of the merging grids will be overwritten</span>
<span class="sd">            by the original main mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGrid</span>
<span class="sd">            Merged grid.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When two or more grids are joined, the type and name of each</span>
<span class="sd">        array must match or the arrays will be ignored and not</span>
<span class="sd">        included in the final merged mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Merge three separate spheres into a single mesh.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere_a = pyvista.Sphere(center=(1, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; sphere_b = pyvista.Sphere(center=(0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; sphere_c = pyvista.Sphere(center=(0, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; merged = sphere_a.merge([sphere_b, sphere_c])</span>
<span class="sd">        &gt;&gt;&gt; merged.plot()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">append_filter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkAppendFilter</span><span class="p">()</span>
        <span class="n">append_filter</span><span class="o">.</span><span class="n">SetMergePoints</span><span class="p">(</span><span class="n">merge_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">main_has_priority</span><span class="p">:</span>
            <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">DataSet</span><span class="p">):</span>
            <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">)):</span>
            <span class="n">grids</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">main_has_priority</span><span class="p">:</span>
            <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">append_filter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Merging&#39;</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">append_filter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">merged</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> cannot be overridden by output.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine this mesh with another into a :class:`pyvista.UnstructuredGrid`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge another mesh into this one if possible.</span>

<span class="sd">        &quot;If possible&quot; means that ``self`` is a :class:`pyvista.UnstructuredGrid`.</span>
<span class="sd">        Otherwise we have to return a new object, and the attempted in-place</span>
<span class="sd">        merge will raise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;In-place merge only possible if the target mesh &#39;</span>
                <span class="s1">&#39;is an UnstructuredGrid.</span><span class="se">\n</span><span class="s1">Please use `mesh + other_mesh` &#39;</span>
                <span class="s1">&#39;instead, which returns a new UnstructuredGrid.&#39;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">merged</span>

<div class="viewcode-block" id="DataSetFilters.compute_cell_quality"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.compute_cell_quality.html#pyvista.DataSetFilters.compute_cell_quality">[docs]</a>    <span class="k">def</span> <span class="nf">compute_cell_quality</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">quality_measure</span><span class="o">=</span><span class="s1">&#39;scaled_jacobian&#39;</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a function of (geometric) quality for each cell of a mesh.</span>

<span class="sd">        The per-cell quality is added to the mesh&#39;s cell data, in an</span>
<span class="sd">        array named ``&quot;CellQuality&quot;``. Cell types not supported by this</span>
<span class="sd">        filter or undefined quality of supported cell types will have an</span>
<span class="sd">        entry of -1.</span>

<span class="sd">        Defaults to computing the scaled Jacobian.</span>

<span class="sd">        Options for cell quality measure:</span>

<span class="sd">        - ``&#39;area&#39;``</span>
<span class="sd">        - ``&#39;aspect_beta&#39;``</span>
<span class="sd">        - ``&#39;aspect_frobenius&#39;``</span>
<span class="sd">        - ``&#39;aspect_gamma&#39;``</span>
<span class="sd">        - ``&#39;aspect_ratio&#39;``</span>
<span class="sd">        - ``&#39;collapse_ratio&#39;``</span>
<span class="sd">        - ``&#39;condition&#39;``</span>
<span class="sd">        - ``&#39;diagonal&#39;``</span>
<span class="sd">        - ``&#39;dimension&#39;``</span>
<span class="sd">        - ``&#39;distortion&#39;``</span>
<span class="sd">        - ``&#39;jacobian&#39;``</span>
<span class="sd">        - ``&#39;max_angle&#39;``</span>
<span class="sd">        - ``&#39;max_aspect_frobenius&#39;``</span>
<span class="sd">        - ``&#39;max_edge_ratio&#39;``</span>
<span class="sd">        - ``&#39;med_aspect_frobenius&#39;``</span>
<span class="sd">        - ``&#39;min_angle&#39;``</span>
<span class="sd">        - ``&#39;oddy&#39;``</span>
<span class="sd">        - ``&#39;radius_ratio&#39;``</span>
<span class="sd">        - ``&#39;relative_size_squared&#39;``</span>
<span class="sd">        - ``&#39;scaled_jacobian&#39;``</span>
<span class="sd">        - ``&#39;shape&#39;``</span>
<span class="sd">        - ``&#39;shape_and_size&#39;``</span>
<span class="sd">        - ``&#39;shear&#39;``</span>
<span class="sd">        - ``&#39;shear_and_size&#39;``</span>
<span class="sd">        - ``&#39;skew&#39;``</span>
<span class="sd">        - ``&#39;stretch&#39;``</span>
<span class="sd">        - ``&#39;taper&#39;``</span>
<span class="sd">        - ``&#39;volume&#39;``</span>
<span class="sd">        - ``&#39;warpage&#39;``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quality_measure : str</span>
<span class="sd">            The cell quality measure to use.</span>

<span class="sd">        null_value : float</span>
<span class="sd">            Float value for undefined quality. Undefined quality are qualities</span>
<span class="sd">            that could be addressed by this filter but is not well defined for</span>
<span class="sd">            the particular geometry of cell in question, e.g. a volume query</span>
<span class="sd">            for a triangle. Undefined quality will always be undefined.</span>
<span class="sd">            The default value is -1.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with the computed mesh quality in the</span>
<span class="sd">            ``cell_data`` as the ``&quot;CellQuality&quot;`` array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute and plot the minimum angle of a sample sphere mesh.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(theta_resolution=20, phi_resolution=20)</span>
<span class="sd">        &gt;&gt;&gt; cqual = sphere.compute_cell_quality(&#39;min_angle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cqual.plot(show_edges=True)</span>

<span class="sd">        See the :ref:`mesh_quality_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCellQuality</span><span class="p">()</span>
        <span class="n">possible_measure_setters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;area&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToArea&#39;</span><span class="p">,</span>
            <span class="s1">&#39;aspect_beta&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToAspectBeta&#39;</span><span class="p">,</span>
            <span class="s1">&#39;aspect_frobenius&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToAspectFrobenius&#39;</span><span class="p">,</span>
            <span class="s1">&#39;aspect_gamma&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToAspectGamma&#39;</span><span class="p">,</span>
            <span class="s1">&#39;aspect_ratio&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToAspectRatio&#39;</span><span class="p">,</span>
            <span class="s1">&#39;collapse_ratio&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToCollapseRatio&#39;</span><span class="p">,</span>
            <span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToCondition&#39;</span><span class="p">,</span>
            <span class="s1">&#39;diagonal&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToDiagonal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;dimension&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToDimension&#39;</span><span class="p">,</span>
            <span class="s1">&#39;distortion&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToDistortion&#39;</span><span class="p">,</span>
            <span class="s1">&#39;jacobian&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToJacobian&#39;</span><span class="p">,</span>
            <span class="s1">&#39;max_angle&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToMaxAngle&#39;</span><span class="p">,</span>
            <span class="s1">&#39;max_aspect_frobenius&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToMaxAspectFrobenius&#39;</span><span class="p">,</span>
            <span class="s1">&#39;max_edge_ratio&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToMaxEdgeRatio&#39;</span><span class="p">,</span>
            <span class="s1">&#39;med_aspect_frobenius&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToMedAspectFrobenius&#39;</span><span class="p">,</span>
            <span class="s1">&#39;min_angle&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToMinAngle&#39;</span><span class="p">,</span>
            <span class="s1">&#39;oddy&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToOddy&#39;</span><span class="p">,</span>
            <span class="s1">&#39;radius_ratio&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToRadiusRatio&#39;</span><span class="p">,</span>
            <span class="s1">&#39;relative_size_squared&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToRelativeSizeSquared&#39;</span><span class="p">,</span>
            <span class="s1">&#39;scaled_jacobian&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToScaledJacobian&#39;</span><span class="p">,</span>
            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToShape&#39;</span><span class="p">,</span>
            <span class="s1">&#39;shape_and_size&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToShapeAndSize&#39;</span><span class="p">,</span>
            <span class="s1">&#39;shear&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToShear&#39;</span><span class="p">,</span>
            <span class="s1">&#39;shear_and_size&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToShearAndSize&#39;</span><span class="p">,</span>
            <span class="s1">&#39;skew&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToSkew&#39;</span><span class="p">,</span>
            <span class="s1">&#39;stretch&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToStretch&#39;</span><span class="p">,</span>
            <span class="s1">&#39;taper&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToTaper&#39;</span><span class="p">,</span>
            <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToVolume&#39;</span><span class="p">,</span>
            <span class="s1">&#39;warpage&#39;</span><span class="p">:</span> <span class="s1">&#39;SetQualityMeasureToWarpage&#39;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># we need to check if these quality measures exist as VTK API changes</span>
        <span class="n">measure_setters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">possible_measure_setters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">setter_candidate</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">setter_candidate</span><span class="p">:</span>
                <span class="n">measure_setters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">setter_candidate</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Set user specified quality measure</span>
            <span class="n">measure_setters</span><span class="p">[</span><span class="n">quality_measure</span><span class="p">]()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="n">options</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">measure_setters</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Cell quality type (</span><span class="si">{</span><span class="n">quality_measure</span><span class="si">}</span><span class="s1">) not available. Options are: </span><span class="si">{</span><span class="n">options</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetUndefinedQuality</span><span class="p">(</span><span class="n">null_value</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Cell Quality&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.compute_derivative"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.compute_derivative.html#pyvista.DataSetFilters.compute_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">compute_derivative</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">divergence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vorticity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">qcriterion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">faster</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute derivative-based quantities of point/cell scalar field.</span>

<span class="sd">        Utilize ``vtkGradientFilter`` to compute derivative-based quantities,</span>
<span class="sd">        such as gradient, divergence, vorticity, and Q-criterion, of the</span>
<span class="sd">        selected point or cell scalar field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars : str, optional</span>
<span class="sd">            String name of the scalars array to use when computing the</span>
<span class="sd">            derivative quantities.  Defaults to the active scalars in</span>
<span class="sd">            the dataset.</span>

<span class="sd">        gradient : bool, str, optional</span>
<span class="sd">            Calculate gradient. If a string is passed, the string will be used</span>
<span class="sd">            for the resulting array name. Otherwise, array name will be</span>
<span class="sd">            ``&#39;gradient&#39;``. Default ``True``.</span>

<span class="sd">        divergence : bool, str, optional</span>
<span class="sd">            Calculate divergence. If a string is passed, the string will be</span>
<span class="sd">            used for the resulting array name. Otherwise, array name will be</span>
<span class="sd">            ``&#39;divergence&#39;``. Default ``None``.</span>

<span class="sd">        vorticity : bool, str, optional</span>
<span class="sd">            Calculate vorticity. If a string is passed, the string will be used</span>
<span class="sd">            for the resulting array name. Otherwise, array name will be</span>
<span class="sd">            ``&#39;vorticity&#39;``. Default ``None``.</span>

<span class="sd">        qcriterion : bool, str, optional</span>
<span class="sd">            Calculate qcriterion. If a string is passed, the string will be</span>
<span class="sd">            used for the resulting array name. Otherwise, array name will be</span>
<span class="sd">            ``&#39;qcriterion&#39;``. Default ``None``.</span>

<span class="sd">        faster : bool, optional</span>
<span class="sd">            Use faster algorithm for computing derivative quantities. Result is</span>
<span class="sd">            less accurate and performs fewer derivative calculations,</span>
<span class="sd">            increasing computation speed. The error will feature smoothing of</span>
<span class="sd">            the output and possibly errors at boundaries. Option has no effect</span>
<span class="sd">            if DataSet is not UnstructuredGrid. Default ``False``.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            Data type preference. Either ``&#39;point&#39;`` or ``&#39;cell&#39;``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with calculated derivative.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, plot the random hills dataset with the active elevation</span>
<span class="sd">        scalars.  These scalars will be used for the derivative</span>
<span class="sd">        calculations.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; hills.plot(smooth_shading=True)</span>

<span class="sd">        Compute and plot the gradient of the active scalars.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; deriv = hills.compute_derivative()</span>
<span class="sd">        &gt;&gt;&gt; deriv.plot(scalars=&#39;gradient&#39;)</span>

<span class="sd">        See the :ref:`gradients_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkGradientFilter</span><span class="p">()</span>
        <span class="c1"># Check if scalars array given</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pyvista</span><span class="o">.</span><span class="n">set_default_active_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_info</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;scalars array must be given as a string name&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="n">gradient</span><span class="p">,</span> <span class="n">divergence</span><span class="p">,</span> <span class="n">vorticity</span><span class="p">,</span> <span class="n">qcriterion</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;must set at least one of gradient, divergence, vorticity, or qcriterion&#39;</span>
            <span class="p">)</span>

            <span class="c1"># bool(non-empty string/True) == True, bool(None/False) == False</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeGradient</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">gradient</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">gradient</span> <span class="o">=</span> <span class="s1">&#39;gradient&#39;</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetResultArrayName</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeDivergence</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">divergence</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divergence</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">divergence</span> <span class="o">=</span> <span class="s1">&#39;divergence&#39;</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetDivergenceArrayName</span><span class="p">(</span><span class="n">divergence</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeVorticity</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">vorticity</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vorticity</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">vorticity</span> <span class="o">=</span> <span class="s1">&#39;vorticity&#39;</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetVorticityArrayName</span><span class="p">(</span><span class="n">vorticity</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetComputeQCriterion</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">qcriterion</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qcriterion</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">qcriterion</span> <span class="o">=</span> <span class="s1">&#39;qcriterion&#39;</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetQCriterionArrayName</span><span class="p">(</span><span class="n">qcriterion</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetFasterApproximation</span><span class="p">(</span><span class="n">faster</span><span class="p">)</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">get_array_association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>
        <span class="c1"># args: (idx, port, connection, field, name)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scalars</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Derivative&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.shrink"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.shrink.html#pyvista.DataSetFilters.shrink">[docs]</a>    <span class="k">def</span> <span class="nf">shrink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shrink_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shrink the individual faces of a mesh.</span>

<span class="sd">        This filter shrinks the individual faces of a mesh rather than</span>
<span class="sd">        scaling the entire mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shrink_factor : float, optional</span>
<span class="sd">            Fraction of shrink for each cell.  Defaults to 1.0, which</span>
<span class="sd">            does not modify the faces.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with shrunk faces.  Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, plot the original cube.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Cube()</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True, line_width=5)</span>

<span class="sd">        Now, plot the mesh with shrunk faces.</span>

<span class="sd">        &gt;&gt;&gt; shrunk = mesh.shrink(0.5)</span>
<span class="sd">        &gt;&gt;&gt; shrunk.clear_data()  # cleans up plot</span>
<span class="sd">        &gt;&gt;&gt; shrunk.plot(show_edges=True, line_width=5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">shrink_factor</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`shrink_factor` should be between 0.0 and 1.0&#39;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkShrinkFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetShrinkFactor</span><span class="p">(</span><span class="n">shrink_factor</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Shrinking Mesh&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.tessellate"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.tessellate.html#pyvista.DataSetFilters.tessellate">[docs]</a>    <span class="k">def</span> <span class="nf">tessellate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_n_subdivide</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">merge_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tessellate a mesh.</span>

<span class="sd">        This filter approximates nonlinear FEM-like elements with linear</span>
<span class="sd">        simplices. The output mesh will have geometry and any fields specified</span>
<span class="sd">        as attributes in the input mesh&#39;s point data. The attribute&#39;s copy</span>
<span class="sd">        flags are honored, except for normals.</span>

<span class="sd">        For more details see `vtkTessellatorFilter &lt;https://vtk.org/doc/nightly/html/classvtkTessellatorFilter.html#details&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_n_subdivide : int, optional</span>
<span class="sd">            Maximum number of subdivisions.</span>
<span class="sd">            Defaults to ``3``.</span>

<span class="sd">        merge_points : bool, optional</span>
<span class="sd">            The adaptive tessellation will output vertices that are not shared among cells,</span>
<span class="sd">            even where they should be. This can be corrected to some extent.</span>
<span class="sd">            Defaults to ``True``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Dataset with tessellated mesh.  Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, plot the high order FEM-like elements.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.array(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         [0.0, 0.0, 0.0],</span>
<span class="sd">        ...         [2.0, 0.0, 0.0],</span>
<span class="sd">        ...         [1.0, 2.0, 0.0],</span>
<span class="sd">        ...         [1.0, 0.5, 0.0],</span>
<span class="sd">        ...         [1.5, 1.5, 0.0],</span>
<span class="sd">        ...         [0.5, 1.5, 0.0],</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; cells = np.array([6, 0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; cell_types = np.array([69])</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.UnstructuredGrid(cells, cell_types, points)</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True, line_width=5)</span>

<span class="sd">        Now, plot the tessellated mesh.</span>

<span class="sd">        &gt;&gt;&gt; tessellated = mesh.tessellate()</span>
<span class="sd">        &gt;&gt;&gt; tessellated.clear_data()  # cleans up plot</span>
<span class="sd">        &gt;&gt;&gt; tessellated.plot(show_edges=True, line_width=5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tessellate filter is not supported for PolyData objects.&#39;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTessellatorFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMergePoints</span><span class="p">(</span><span class="n">merge_points</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumNumberOfSubdivisions</span><span class="p">(</span><span class="n">max_n_subdivide</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Tessellating Mesh&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.transform"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.transform.html#pyvista.DataSetFilters.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDataSet</span><span class="p">,</span>
        <span class="n">trans</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkMatrix4x4</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTransform</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform this mesh with a 4x4 transform.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            When using ``transform_all_input_vectors=True``, there is</span>
<span class="sd">            no distinction in VTK between vectors and arrays with</span>
<span class="sd">            three components.  This may be an issue if you have scalar</span>
<span class="sd">            data with three components (e.g. RGB data).  This will be</span>
<span class="sd">            improperly transformed as if it was vector data rather</span>
<span class="sd">            than scalar data.  One possible (albeit ugly) workaround</span>
<span class="sd">            is to store the three components as separate scalar</span>
<span class="sd">            arrays.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            In general, transformations give non-integer results. This</span>
<span class="sd">            method converts integer-typed vector data to float before</span>
<span class="sd">            performing the transformation. This applies to the points</span>
<span class="sd">            array, as well as any vector-valued data that is affected</span>
<span class="sd">            by the transformation. To prevent subtle bugs arising from</span>
<span class="sd">            in-place transformations truncating the result to integers,</span>
<span class="sd">            this conversion always applies to the input mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trans : vtk.vtkMatrix4x4, vtk.vtkTransform, or numpy.ndarray</span>
<span class="sd">            Accepts a vtk transformation object or a 4x4</span>
<span class="sd">            transformation matrix.</span>

<span class="sd">        transform_all_input_vectors : bool, optional</span>
<span class="sd">            When ``True``, all arrays with three components are</span>
<span class="sd">            transformed. Otherwise, only the normals and vectors are</span>
<span class="sd">            transformed.  See the warning for more details.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            When ``True``, modifies the dataset inplace.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Transformed dataset.  Return type matches input unless</span>
<span class="sd">            input dataset is a :class:`pyvista.UniformGrid`, in which</span>
<span class="sd">            case the output datatype is a :class:`pyvista.StructuredGrid`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Translate a mesh by ``(50, 100, 200)``.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.load_airplane()</span>

<span class="sd">        Here a 4x4 :class:`numpy.ndarray` is used, but</span>
<span class="sd">        ``vtk.vtkMatrix4x4`` and ``vtk.vtkTransform`` are also</span>
<span class="sd">        accepted.</span>

<span class="sd">        &gt;&gt;&gt; transform_matrix = np.array([[1, 0, 0, 50],</span>
<span class="sd">        ...                              [0, 1, 0, 100],</span>
<span class="sd">        ...                              [0, 0, 1, 200],</span>
<span class="sd">        ...                              [0, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; transformed = mesh.transform(transform_matrix)</span>
<span class="sd">        &gt;&gt;&gt; transformed.plot(show_edges=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot transform a </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s1"> inplace&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkMatrix4x4</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTransform</span><span class="p">()</span>
            <span class="n">t</span><span class="o">.</span><span class="n">SetMatrix</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTransform</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">GetMatrix</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Transformation array must be 4x4&#39;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">vtkmatrix_from_array</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTransform</span><span class="p">()</span>
            <span class="n">t</span><span class="o">.</span><span class="n">SetMatrix</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Input transform must be either:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">vtk.vtkMatrix4x4</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">vtk.vtkTransform</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">4x4 np.ndarray</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">GetElement</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transform element (3,3), the inverse scale term, is zero&quot;</span><span class="p">)</span>

        <span class="c1"># vtkTransformFilter truncates the result if the input is an integer type</span>
        <span class="c1"># so convert input points and relevant vectors to float</span>
        <span class="c1"># (creating a new copy would be harmful much more often)</span>
        <span class="n">converted_ints</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">converted_ints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">transform_all_input_vectors</span><span class="p">:</span>
            <span class="c1"># all vector-shaped data will be transformed</span>
            <span class="n">point_vectors</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">cell_vectors</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cells</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we&#39;ll only transform active vectors and normals</span>
            <span class="n">point_vectors</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_vectors_name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_normals_name</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">cell_vectors</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">active_vectors_name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">active_normals_name</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="c1"># dynamically convert each self.point_data[name] etc. to float32</span>
        <span class="n">all_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">point_vectors</span><span class="p">,</span> <span class="n">cell_vectors</span><span class="p">]</span>
        <span class="n">all_dataset_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">vector_names</span><span class="p">,</span> <span class="n">dataset_attrs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_vectors</span><span class="p">,</span> <span class="n">all_dataset_attrs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">vector_name</span> <span class="ow">in</span> <span class="n">vector_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vector_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">vector_arr</span> <span class="o">=</span> <span class="n">dataset_attrs</span><span class="p">[</span><span class="n">vector_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">vector_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                    <span class="n">dataset_attrs</span><span class="p">[</span><span class="n">vector_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="n">converted_ints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">converted_ints</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Integer points, vector and normal data (if any) of the input mesh &#39;</span>
                <span class="s1">&#39;have been converted to ``np.float32``. This is necessary in order &#39;</span>
                <span class="s1">&#39;to transform properly.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># vtkTransformFilter doesn&#39;t respect active scalars.  We need to track this</span>
        <span class="n">active_point_scalars_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_scalars_name</span>
        <span class="n">active_cell_scalars_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">active_scalars_name</span>

        <span class="c1"># vtkTransformFilter sometimes doesn&#39;t transform all vector arrays</span>
        <span class="c1"># when there are active point/cell scalars. Use this workaround</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_scalars_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTransformFilter</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">SetTransform</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;SetTransformAllInputVectors&#39;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">SetTransformAllInputVectors</span><span class="p">(</span><span class="n">transform_all_input_vectors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># In VTK 8.1.2 and earlier, vtkTransformFilter does not</span>
            <span class="c1"># support the transformation of all input vectors.</span>
            <span class="c1"># Raise an error if the user requested for input vectors</span>
            <span class="c1"># to be transformed and it is not supported</span>
            <span class="k">if</span> <span class="n">transform_all_input_vectors</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span>
                    <span class="s1">&#39;The installed version of VTK does not support &#39;</span>
                    <span class="s1">&#39;transformation of all input vectors.&#39;</span>
                <span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Transforming&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">_get_output</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># make the previously active scalars active again</span>
        <span class="k">if</span> <span class="n">active_point_scalars_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_scalars_name</span> <span class="o">=</span> <span class="n">active_point_scalars_name</span>
            <span class="n">res</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">active_scalars_name</span> <span class="o">=</span> <span class="n">active_point_scalars_name</span>
        <span class="k">if</span> <span class="n">active_cell_scalars_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">active_scalars_name</span> <span class="o">=</span> <span class="n">active_cell_scalars_name</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">active_scalars_name</span> <span class="o">=</span> <span class="n">active_cell_scalars_name</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># The output from the transform filter contains a shallow copy</span>
        <span class="c1"># of the original dataset except for the point arrays.  Here</span>
        <span class="c1"># we perform a copy so the two are completely unlinked.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">StructuredGrid</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">output</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="DataSetFilters.reflect"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.reflect.html#pyvista.DataSetFilters.reflect">[docs]</a>    <span class="k">def</span> <span class="nf">reflect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">normal</span><span class="p">,</span>
        <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reflect a dataset across a plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normal : tuple(float)</span>
<span class="sd">            Normal direction for reflection.</span>

<span class="sd">        point : tuple(float), optional</span>
<span class="sd">            Point which, along with ``normal``, defines the reflection</span>
<span class="sd">            plane. If not specified, this is the origin.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            When ``True``, modifies the dataset inplace.</span>

<span class="sd">        transform_all_input_vectors : bool, optional</span>
<span class="sd">            When ``True``, all input vectors are transformed. Otherwise,</span>
<span class="sd">            only the points, normals and active vectors are transformed.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            Reflected dataset.  Return type matches input.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.load_airplane()</span>
<span class="sd">        &gt;&gt;&gt; mesh = mesh.reflect((0, 0, 1), point=(0, 0, -100))</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True)</span>

<span class="sd">        See the :ref:`ref_reflect_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">reflection</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">t</span><span class="p">,</span>
            <span class="n">transform_all_input_vectors</span><span class="o">=</span><span class="n">transform_all_input_vectors</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataSetFilters.integrate_data"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.DataSetFilters.integrate_data.html#pyvista.DataSetFilters.integrate_data">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrate point and cell data.</span>

<span class="sd">        Area or volume is also provided in point data.</span>

<span class="sd">        This filter uses the VTK `vtkIntegrateAttributes</span>
<span class="sd">        &lt;https://vtk.org/doc/nightly/html/classvtkIntegrateAttributes.html&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.UnstructuredGird</span>
<span class="sd">            Mesh with 1 point and 1 vertex cell with integrated data in point and cell data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Integrate data on a sphere mesh.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(theta_resolution=100, phi_resolution=100)</span>
<span class="sd">        &gt;&gt;&gt; sphere.point_data[&quot;data&quot;] = 2 * np.ones(sphere.n_points)</span>
<span class="sd">        &gt;&gt;&gt; integrated = sphere.integrate_data()</span>

<span class="sd">        There is only 1 point and cell, so access the only value.</span>

<span class="sd">        &gt;&gt;&gt; integrated[&quot;Area&quot;][0]</span>
<span class="sd">        3.14</span>
<span class="sd">        &gt;&gt;&gt; integrated[&quot;data&quot;][0]</span>
<span class="sd">        6.28</span>

<span class="sd">        See the :ref:`integrate_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkIntegrateAttributes</span><span class="p">()</span>
        <span class="nb">filter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="nb">filter</span><span class="o">.</span><span class="n">SetDivideAllCellDataByVolume</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Integrating Variables&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span></div></div>
</pre></div>

              </article>
              

              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2017-2023, The PyVista Developers.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>
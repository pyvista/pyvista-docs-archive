
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyvista.core.filters.poly_data &#8212; PyVista 0.35.2 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/no_search_highlight.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/summary.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
    <img src="../../../../_static/pyvista_logo_sm.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../../_static/pyvista_logo_sm.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../getting-started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user-guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../examples/index.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../api/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../extras/index.html">
  Extras
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        0.35  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables _modules/pyvista/core/filters/poly_data and {'json_url': 'https://docs.pyvista.org/versions.json', 'version_match': '0.35'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "_modules/pyvista/core/filters/poly_data.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://docs.pyvista.org/versions.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "_modules/pyvista/core/filters/poly_data.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 0.35.2 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "0.35") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://slack.pyvista.org" rel="noopener" target="_blank" title="Slack Community"><span><i class="fab fa-slack"></i></span>
            <label class="sr-only">Slack Community</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/discussions" rel="noopener" target="_blank" title="Support"><span><i class="fa fa-comment fa-fw"></i></span>
            <label class="sr-only">Support</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pyvista/pyvista/blob/main/CONTRIBUTING.rst" rel="noopener" target="_blank" title="Contributing"><span><i class="fa fa-gavel fa-fw"></i></span>
            <label class="sr-only">Contributing</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://doi.org/10.21105/joss.01450" rel="noopener" target="_blank" title="The Paper"><span><i class="fa fa-file-text fa-fw"></i></span>
            <label class="sr-only">The Paper</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for pyvista.core.filters.poly_data</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Filters module with a class to manage filters/algorithms for polydata datasets.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pyvista</span>
<span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NORMALS</span><span class="p">,</span>
    <span class="n">_vtk</span><span class="p">,</span>
    <span class="n">abstract_class</span><span class="p">,</span>
    <span class="n">assert_empty_kwargs</span><span class="p">,</span>
    <span class="n">generate_plane</span><span class="p">,</span>
    <span class="n">get_array_association</span><span class="p">,</span>
    <span class="n">vtk_id_list_to_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyvista.core.errors</span> <span class="kn">import</span> <span class="n">DeprecationError</span><span class="p">,</span> <span class="n">NotAllTrianglesError</span><span class="p">,</span> <span class="n">VTKVersionError</span>
<span class="kn">from</span> <span class="nn">pyvista.core.filters</span> <span class="kn">import</span> <span class="n">_get_output</span><span class="p">,</span> <span class="n">_update_alg</span>
<span class="kn">from</span> <span class="nn">pyvista.core.filters.data_set</span> <span class="kn">import</span> <span class="n">DataSetFilters</span>
<span class="kn">from</span> <span class="nn">pyvista.utilities.misc</span> <span class="kn">import</span> <span class="n">PyvistaFutureWarning</span>


<div class="viewcode-block" id="PolyDataFilters"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.html#pyvista.PolyDataFilters">[docs]</a><span class="nd">@abstract_class</span>
<span class="k">class</span> <span class="nc">PolyDataFilters</span><span class="p">(</span><span class="n">DataSetFilters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An internal class to manage filters/algorithms for polydata datasets.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PolyDataFilters.edge_mask"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.edge_mask.html#pyvista.PolyDataFilters.edge_mask">[docs]</a>    <span class="k">def</span> <span class="nf">edge_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a mask of the points of a surface mesh that has a surface angle greater than angle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float</span>
<span class="sd">            Angle to consider an edge.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Mask of points with an angle greater than ``angle``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Plot the mask of points that exceed 45 degrees.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Cube().triangulate().subdivide(4)</span>
<span class="sd">        &gt;&gt;&gt; mask = mesh.edge_mask(45)</span>
<span class="sd">        &gt;&gt;&gt; mask  # doctest:+SKIP</span>
<span class="sd">        array([ True,  True,  True, ..., False, False, False])</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(scalars=mask)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poly_data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly_data</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">poly_data</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">poly_data</span><span class="p">)</span>
        <span class="n">poly_data</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;point_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">poly_data</span><span class="o">.</span><span class="n">n_points</span><span class="p">)</span>
        <span class="n">featureEdges</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkFeatureEdges</span><span class="p">()</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">poly_data</span><span class="p">)</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">FeatureEdgesOn</span><span class="p">()</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">BoundaryEdgesOff</span><span class="p">()</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">NonManifoldEdgesOff</span><span class="p">()</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">ManifoldEdgesOff</span><span class="p">()</span>
        <span class="n">featureEdges</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">featureEdges</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Edges&#39;</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">featureEdges</span><span class="p">)</span>
        <span class="n">orig_id</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">point_array</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="s1">&#39;point_ind&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">poly_data</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;point_ind&#39;</span><span class="p">],</span> <span class="n">orig_id</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">btype</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform boolean operation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_mesh</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input mesh must be PolyData.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other_mesh</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Make sure both the input and output are triangulated.&quot;</span><span class="p">)</span>

        <span class="n">bfilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkBooleanOperationPolyDataFilter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
            <span class="n">bfilter</span><span class="o">.</span><span class="n">SetOperationToUnion</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;intersection&#39;</span><span class="p">:</span>
            <span class="n">bfilter</span><span class="o">.</span><span class="n">SetOperationToIntersection</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;difference&#39;</span><span class="p">:</span>
            <span class="n">bfilter</span><span class="o">.</span><span class="n">SetOperationToDifference</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid btype </span><span class="si">{</span><span class="n">btype</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">bfilter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">bfilter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">)</span>
        <span class="n">bfilter</span><span class="o">.</span><span class="n">ReorientDifferenceCellsOn</span><span class="p">()</span>  <span class="c1"># this is already default</span>
        <span class="n">bfilter</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">bfilter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Performing Boolean Operation&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">bfilter</span><span class="p">)</span>

<div class="viewcode-block" id="PolyDataFilters.boolean_cut"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.boolean_cut.html#pyvista.PolyDataFilters.boolean_cut">[docs]</a>    <span class="k">def</span> <span class="nf">boolean_cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cut two meshes.</span>

<span class="sd">        .. deprecated:: 0.32.0</span>
<span class="sd">           Use :func:`PolyDataFilters.boolean_difference` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">DeprecationError</span><span class="p">(</span>
            <span class="s1">&#39;``boolean_cut`` has been deprecated.  Please use ``boolean_difference``.&#39;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.boolean_add"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.boolean_add.html#pyvista.PolyDataFilters.boolean_add">[docs]</a>    <span class="k">def</span> <span class="nf">boolean_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge two meshes together.</span>

<span class="sd">        .. deprecated:: 0.32.0</span>
<span class="sd">           Use :func:`PolyDataFilters.merge` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">DeprecationError</span><span class="p">(</span><span class="s1">&#39;``boolean_add`` has been deprecated.  &#39;</span> <span class="s1">&#39;Please use ``merge``.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.boolean_union"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.boolean_union.html#pyvista.PolyDataFilters.boolean_union">[docs]</a>    <span class="k">def</span> <span class="nf">boolean_union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a boolean union operation on two meshes.</span>

<span class="sd">        Essentially, boolean union, difference, and intersection are</span>
<span class="sd">        all the same operation. Just different parts of the objects</span>
<span class="sd">        are kept at the end.</span>

<span class="sd">        The union of two manifold meshes ``A`` and ``B`` is the mesh</span>
<span class="sd">        which is in ``A``, in ``B``, or in both ``A`` and ``B``.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If your boolean operations don&#39;t react the way you think they</span>
<span class="sd">           should (i.e. the wrong parts disappear), one of your meshes</span>
<span class="sd">           probably has its normals pointing inward. Use</span>
<span class="sd">           :func:`PolyDataFilters.plot_normals` to visualize the</span>
<span class="sd">           normals.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The behavior of this filter varies from the</span>
<span class="sd">           :func:`PolyDataFilters.merge` filter.  This filter attempts</span>
<span class="sd">           to create a manifold mesh and will not include internal</span>
<span class="sd">           surfaces when two meshes overlap.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Both meshes must be composed of all triangles.  Check with</span>
<span class="sd">           :attr:`PolyData.is_all_triangles` and convert with</span>
<span class="sd">           :func:`PolyDataFilters.triangulate`.</span>

<span class="sd">        .. versionchanged:: 0.32.0</span>
<span class="sd">           Behavior changed to match default VTK behavior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_mesh : pyvista.PolyData</span>
<span class="sd">            Mesh operating on the source mesh.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to determine when a point&#39;s absolute</span>
<span class="sd">            distance is considered to be zero.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The result of the boolean operation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Demonstrate a boolean union with two spheres.  Note how the</span>
<span class="sd">        final mesh includes both spheres.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere_a = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere_b = pyvista.Sphere(center=(0.5, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; result = sphere_a.boolean_union(sphere_b)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere_a, color=&#39;r&#39;, style=&#39;wireframe&#39;, line_width=3)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere_b, color=&#39;b&#39;, style=&#39;wireframe&#39;, line_width=3)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(result, color=&#39;tan&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.camera_position = &#39;xz&#39;</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`boolean_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boolean</span><span class="p">(</span><span class="s1">&#39;union&#39;</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.boolean_intersection"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.boolean_intersection.html#pyvista.PolyDataFilters.boolean_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">boolean_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a boolean intersection operation on two meshes.</span>

<span class="sd">        Essentially, boolean union, difference, and intersection are</span>
<span class="sd">        all the same operation. Just different parts of the objects</span>
<span class="sd">        are kept at the end.</span>

<span class="sd">        The intersection of two manifold meshes ``A`` and ``B`` is the mesh</span>
<span class="sd">        which is the volume of ``A`` that is also in ``B``.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If your boolean operations don&#39;t react the way you think they</span>
<span class="sd">           should (i.e. the wrong parts disappear), one of your meshes</span>
<span class="sd">           probably has its normals pointing inward. Use</span>
<span class="sd">           :func:`PolyDataFilters.plot_normals` to visualize the</span>
<span class="sd">           normals.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This method returns the &quot;volume&quot; intersection between two</span>
<span class="sd">           meshes whereas the :func:`PolyDataFilters.intersection`</span>
<span class="sd">           filter returns the surface intersection between two meshes</span>
<span class="sd">           (which often resolves as a line).</span>


<span class="sd">        .. note::</span>
<span class="sd">           Both meshes must be composed of all triangles.  Check with</span>
<span class="sd">           :attr:`PolyData.is_all_triangles` and convert with</span>
<span class="sd">           :func:`PolyDataFilters.triangulate`.</span>

<span class="sd">        .. versionadded:: 0.32.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_mesh : pyvista.PolyData</span>
<span class="sd">            Mesh operating on the source mesh.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to determine when a point&#39;s absolute</span>
<span class="sd">            distance is considered to be zero.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The result of the boolean operation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Demonstrate a boolean intersection with two spheres.  Note how</span>
<span class="sd">        the final mesh only includes the intersection of the two.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere_a = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere_b = pyvista.Sphere(center=(0.5, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; result = sphere_a.boolean_intersection(sphere_b)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere_a, color=&#39;r&#39;, style=&#39;wireframe&#39;, line_width=3)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere_b, color=&#39;b&#39;, style=&#39;wireframe&#39;, line_width=3)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(result, color=&#39;tan&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.camera_position = &#39;xz&#39;</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`boolean_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boolean</span><span class="p">(</span><span class="s1">&#39;intersection&#39;</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.boolean_difference"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.boolean_difference.html#pyvista.PolyDataFilters.boolean_difference">[docs]</a>    <span class="k">def</span> <span class="nf">boolean_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a boolean difference operation between two meshes.</span>

<span class="sd">        Essentially, boolean union, difference, and intersection are</span>
<span class="sd">        all the same operation. Just different parts of the objects</span>
<span class="sd">        are kept at the end.</span>

<span class="sd">        The difference of two manifold meshes ``A`` and ``B`` is the</span>
<span class="sd">        volume of the mesh in ``A`` not belonging to ``B``.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If your boolean operations don&#39;t react the way you think they</span>
<span class="sd">           should (i.e. the wrong parts disappear), one of your meshes</span>
<span class="sd">           probably has its normals pointing inward. Use</span>
<span class="sd">           :func:`PolyDataFilters.plot_normals` to visualize the</span>
<span class="sd">           normals.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Both meshes must be composed of all triangles.  Check with</span>
<span class="sd">           :attr:`PolyData.is_all_triangles` and convert with</span>
<span class="sd">           :func:`PolyDataFilters.triangulate`.</span>

<span class="sd">        .. versionchanged:: 0.32.0</span>
<span class="sd">           Behavior changed to match default VTK behavior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_mesh : pyvista.PolyData</span>
<span class="sd">            Mesh operating on the source mesh.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance used to determine when a point&#39;s absolute</span>
<span class="sd">            distance is considered to be zero.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The result of the boolean operation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Demonstrate a boolean difference with two spheres.  Note how</span>
<span class="sd">        the final mesh only includes ``sphere_a``.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere_a = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere_b = pyvista.Sphere(center=(0.5, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; result = sphere_a.boolean_difference(sphere_b)</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere_a, color=&#39;r&#39;, style=&#39;wireframe&#39;, line_width=3)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(sphere_b, color=&#39;b&#39;, style=&#39;wireframe&#39;, line_width=3)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(result, color=&#39;tan&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.camera_position = &#39;xz&#39;</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`boolean_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boolean</span><span class="p">(</span><span class="s1">&#39;difference&#39;</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge these two meshes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge another mesh into this one if possible.</span>

<span class="sd">        &quot;If possible&quot; means that ``dataset`` is also a :class:`PolyData`.</span>
<span class="sd">        Otherwise we have to return a :class:`pyvista.UnstructuredGrid`,</span>
<span class="sd">        so the in-place merge attempt will raise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;In-place merge only possible if the other mesh &#39;</span>
                <span class="s1">&#39;is also a PolyData.</span><span class="se">\n</span><span class="s1">Please use `mesh + other_mesh` &#39;</span>
                <span class="s1">&#39;instead, which returns a new UnstructuredGrid.&#39;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">merged</span>

<div class="viewcode-block" id="PolyDataFilters.merge"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.merge.html#pyvista.PolyDataFilters.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">merge_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">main_has_priority</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge this mesh with one or more datasets.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The behavior of this filter varies from the</span>
<span class="sd">           :func:`PolyDataFilters.boolean_union` filter.  This filter</span>
<span class="sd">           does not attempt to create a manifold mesh and will include</span>
<span class="sd">           internal surfaces when two meshes overlap.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The ``+`` operator between two meshes uses this filter with</span>
<span class="sd">           the default parameters. When the other mesh is also a</span>
<span class="sd">           :class:`pyvista.PolyData`, in-place merging via ``+=`` is</span>
<span class="sd">           similarly possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : pyvista.DataSet</span>
<span class="sd">            PyVista dataset to merge this mesh with.</span>

<span class="sd">        merge_points : bool, optional</span>
<span class="sd">            Merge equivalent points when ``True``.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates grid inplace when ``True`` if the input type is a</span>
<span class="sd">            :class:`pyvista.PolyData`. For other input meshes the</span>
<span class="sd">            result is a :class:`pyvista.UnstructuredGrid` which makes</span>
<span class="sd">            in-place operation impossible.</span>

<span class="sd">        main_has_priority : bool, optional</span>
<span class="sd">            When this parameter is ``True`` and ``merge_points=True``,</span>
<span class="sd">            the arrays of the merging grids will be overwritten</span>
<span class="sd">            by the original main mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.DataSet</span>
<span class="sd">            :class:`pyvista.PolyData` if ``dataset`` is a</span>
<span class="sd">            :class:`pyvista.PolyData`, otherwise a</span>
<span class="sd">            :class:`pyvista.UnstructuredGrid`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere_a = pyvista.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere_b = pyvista.Sphere(center=(0.5, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; merged = sphere_a.merge(sphere_b)</span>
<span class="sd">        &gt;&gt;&gt; merged.plot(style=&#39;wireframe&#39;, color=&#39;tan&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if dataset or datasets are not polydata</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">MultiBlock</span><span class="p">)):</span>
            <span class="n">not_pd</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_pd</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">)</span>

        <span class="c1"># use dataset merge if not polydata</span>
        <span class="k">if</span> <span class="n">not_pd</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">dataset</span><span class="p">,</span>
                <span class="n">merge_points</span><span class="o">=</span><span class="n">merge_points</span><span class="p">,</span>
                <span class="n">main_has_priority</span><span class="o">=</span><span class="n">main_has_priority</span><span class="p">,</span>
                <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">append_filter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">_vtk</span><span class="o">.</span><span class="n">vtkAppendPolyData</span><span class="p">()</span>

        <span class="c1"># note: unlike DataSetFilters.merge, we must put the</span>
        <span class="c1"># &quot;to be preserved&quot; dataset last due to the call to clean()</span>
        <span class="k">if</span> <span class="n">main_has_priority</span><span class="p">:</span>
            <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">DataSet</span><span class="p">):</span>
            <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
                <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">main_has_priority</span><span class="p">:</span>
            <span class="n">append_filter</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">append_filter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Merging&#39;</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">append_filter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">merge_points</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span>
                <span class="n">lines_to_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">polys_to_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strips_to_polys</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">merged</span></div>

<div class="viewcode-block" id="PolyDataFilters.intersection"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.intersection.html#pyvista.PolyDataFilters.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">split_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split_second</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the intersection between two meshes.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This method returns the surface intersection from two meshes</span>
<span class="sd">           (which often resolves as a line), whereas the</span>
<span class="sd">           :func:`PolyDataFilters.boolean_intersection` filter returns</span>
<span class="sd">           the &quot;volume&quot; intersection between two closed (manifold)</span>
<span class="sd">           meshes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh : pyvista.PolyData</span>
<span class="sd">            The mesh to intersect with.</span>

<span class="sd">        split_first : bool, optional</span>
<span class="sd">            If ``True``, return the first input mesh split by the</span>
<span class="sd">            intersection with the second input mesh.</span>

<span class="sd">        split_second : bool, optional</span>
<span class="sd">            If ``True``, return the second input mesh split by the</span>
<span class="sd">            intersection with the first input mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The intersection line.</span>

<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The first mesh split along the intersection. Returns the</span>
<span class="sd">            original first mesh if ``split_first=False``.</span>

<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The second mesh split along the intersection. Returns the</span>
<span class="sd">            original second mesh if ``split_second=False``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Intersect two spheres, returning the intersection and both spheres</span>
<span class="sd">        which have new points/cells along the intersection line.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; s1 = pv.Sphere(phi_resolution=15, theta_resolution=15)</span>
<span class="sd">        &gt;&gt;&gt; s2 = s1.copy()</span>
<span class="sd">        &gt;&gt;&gt; s2.points += np.array([0.25, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; intersection, s1_split, s2_split = s1.intersection(s2)</span>
<span class="sd">        &gt;&gt;&gt; pl = pv.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(s1, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(s2, style=&#39;wireframe&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(intersection, color=&#39;r&#39;, line_width=10)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        The mesh splitting takes additional time and can be turned</span>
<span class="sd">        off for either mesh individually.</span>

<span class="sd">        &gt;&gt;&gt; intersection, _, s2_split = s1.intersection(s2,</span>
<span class="sd">        ...                                             split_first=False,</span>
<span class="sd">        ...                                             split_second=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intfilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkIntersectionPolyDataFilter</span><span class="p">()</span>
        <span class="n">intfilter</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">intfilter</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
        <span class="n">intfilter</span><span class="o">.</span><span class="n">SetComputeIntersectionPointArray</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">intfilter</span><span class="o">.</span><span class="n">SetSplitFirstOutput</span><span class="p">(</span><span class="n">split_first</span><span class="p">)</span>
        <span class="n">intfilter</span><span class="o">.</span><span class="n">SetSplitSecondOutput</span><span class="p">(</span><span class="n">split_second</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">intfilter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing the intersection between two meshes&#39;</span><span class="p">)</span>

        <span class="n">intersection</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">intfilter</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">intfilter</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">intfilter</span><span class="p">,</span> <span class="n">oport</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">intersection</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span></div>

<div class="viewcode-block" id="PolyDataFilters.curvature"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.curvature.html#pyvista.PolyDataFilters.curvature">[docs]</a>    <span class="k">def</span> <span class="nf">curvature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curv_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the pointwise curvature of a mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curv_type : str, optional</span>
<span class="sd">            Curvature type.  One of the following:</span>

<span class="sd">            * ``&quot;mean&quot;``</span>
<span class="sd">            * ``&quot;gaussian&quot;``</span>
<span class="sd">            * ``&quot;maximum&quot;``</span>
<span class="sd">            * ``&quot;minimum&quot;``</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress. Default</span>
<span class="sd">            ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of curvature values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the mean curvature of the hills example mesh.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; curv = hills.curvature()</span>
<span class="sd">        &gt;&gt;&gt; curv   # doctest:+SKIP</span>
<span class="sd">        array([0.20587616, 0.06747695, ..., 0.11781171, 0.15988467])</span>

<span class="sd">        Plot it.</span>

<span class="sd">        &gt;&gt;&gt; hills.plot(scalars=curv)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curv_type</span> <span class="o">=</span> <span class="n">curv_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># Create curve filter and compute curvature</span>
        <span class="n">curvefilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCurvatures</span><span class="p">()</span>
        <span class="n">curvefilter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curv_type</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="n">curvefilter</span><span class="o">.</span><span class="n">SetCurvatureTypeToMean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">curv_type</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">curvefilter</span><span class="o">.</span><span class="n">SetCurvatureTypeToGaussian</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">curv_type</span> <span class="o">==</span> <span class="s1">&#39;maximum&#39;</span><span class="p">:</span>
            <span class="n">curvefilter</span><span class="o">.</span><span class="n">SetCurvatureTypeToMaximum</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">curv_type</span> <span class="o">==</span> <span class="s1">&#39;minimum&#39;</span><span class="p">:</span>
            <span class="n">curvefilter</span><span class="o">.</span><span class="n">SetCurvatureTypeToMinimum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;``curv_type`` must be either &quot;Mean&quot;, &quot;Gaussian&quot;, &quot;Maximum&quot;, or &quot;Minimum&quot;.&#39;</span>
            <span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">curvefilter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Curvature&#39;</span><span class="p">)</span>

        <span class="c1"># Compute and return curvature</span>
        <span class="n">curv</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">curvefilter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">curv</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">GetScalars</span><span class="p">())</span></div>

<div class="viewcode-block" id="PolyDataFilters.plot_curvature"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.plot_curvature.html#pyvista.PolyDataFilters.plot_curvature">[docs]</a>    <span class="k">def</span> <span class="nf">plot_curvature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curv_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the curvature.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curv_type : str, optional</span>
<span class="sd">            One of the following strings indicating curvature type:</span>

<span class="sd">            * ``&#39;Mean&#39;``</span>
<span class="sd">            * ``&#39;Gaussian&#39;``</span>
<span class="sd">            * ``&#39;Maximum&#39;``</span>
<span class="sd">            * ``&#39;Minimum&#39;``</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            See :func:`pyvista.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.CameraPosition</span>
<span class="sd">            List of camera position, focal point, and view up.</span>
<span class="sd">            Returned when ``return_cpos`` is ``True``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Plot the Gaussian curvature of an example mesh.  Override the</span>
<span class="sd">        default scalar bar range as the mesh edges report high</span>
<span class="sd">        curvature.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; hills.plot_curvature(curv_type=&#39;gaussian&#39;, smooth_shading=True,</span>
<span class="sd">        ...                      clim=[0, 1])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;scalar_bar_args&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">curv_type</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s1"> Curvature&#39;</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">scalars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">curvature</span><span class="p">(</span><span class="n">curv_type</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.triangulate"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.triangulate.html#pyvista.PolyDataFilters.triangulate">[docs]</a>    <span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an all triangle mesh.</span>

<span class="sd">        More complex polygons will be broken down into triangles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to update the mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh containing only triangles.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate a mesh with quadrilateral faces.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane()</span>
<span class="sd">        &gt;&gt;&gt; plane.point_data.clear()</span>
<span class="sd">        &gt;&gt;&gt; plane.plot(show_edges=True, line_width=5)</span>

<span class="sd">        Convert it to an all triangle mesh.</span>

<span class="sd">        &gt;&gt;&gt; mesh = plane.triangulate()</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True, line_width=5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trifilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTriangleFilter</span><span class="p">()</span>
        <span class="n">trifilter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">trifilter</span><span class="o">.</span><span class="n">PassVertsOff</span><span class="p">()</span>
        <span class="n">trifilter</span><span class="o">.</span><span class="n">PassLinesOff</span><span class="p">()</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">trifilter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Triangle Mesh&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">trifilter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.smooth"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.smooth.html#pyvista.PolyDataFilters.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">relaxation_factor</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">convergence</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">edge_angle</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">feature_angle</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span>
        <span class="n">boundary_smoothing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">feature_smoothing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust point coordinates using Laplacian smoothing.</span>

<span class="sd">        The effect is to &quot;relax&quot; the mesh, making the cells better shaped and</span>
<span class="sd">        the vertices more evenly distributed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter : int, optional</span>
<span class="sd">            Number of iterations for Laplacian smoothing.</span>

<span class="sd">        relaxation_factor : float, optional</span>
<span class="sd">            Relaxation factor controls the amount of displacement in a single</span>
<span class="sd">            iteration. Generally a lower relaxation factor and higher number of</span>
<span class="sd">            iterations is numerically more stable.</span>

<span class="sd">        convergence : float, optional</span>
<span class="sd">            Convergence criterion for the iteration process. Smaller numbers</span>
<span class="sd">            result in more smoothing iterations. Range from (0 to 1).</span>

<span class="sd">        edge_angle : float, optional</span>
<span class="sd">            Edge angle to control smoothing along edges (either interior or boundary).</span>

<span class="sd">        feature_angle : float, optional</span>
<span class="sd">            Feature angle for sharp edge identification.</span>

<span class="sd">        boundary_smoothing : bool, optional</span>
<span class="sd">            Flag to control smoothing of boundary edges. When ``True``,</span>
<span class="sd">            boundary edges remain fixed. Default ``True``.</span>

<span class="sd">        feature_smoothing : bool, optional</span>
<span class="sd">            Flag to control smoothing of feature edges.  When ``True``,</span>
<span class="sd">            boundary edges remain fixed as defined by ``feature_angle`` and</span>
<span class="sd">            ``edge_angle``. Default ``False``.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Smoothed mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Smooth the edges of an all triangular cube</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; cube = pv.Cube().triangulate().subdivide(5)</span>
<span class="sd">        &gt;&gt;&gt; smooth_cube = cube.smooth(1000, feature_smoothing=False)</span>
<span class="sd">        &gt;&gt;&gt; n_edge_cells = cube.extract_feature_edges().n_cells</span>
<span class="sd">        &gt;&gt;&gt; n_smooth_cells = smooth_cube.extract_feature_edges().n_cells</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Sharp Edges on Cube:        {n_edge_cells}&#39;</span>
<span class="sd">        &#39;Sharp Edges on Cube:        384&#39;</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Sharp Edges on Smooth Cube: {n_smooth_cells}&#39;</span>
<span class="sd">        &#39;Sharp Edges on Smooth Cube: 12&#39;</span>
<span class="sd">        &gt;&gt;&gt; smooth_cube.plot()</span>

<span class="sd">        See :ref:`surface_smoothing_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSmoothPolyDataFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNumberOfIterations</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetConvergence</span><span class="p">(</span><span class="n">convergence</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetFeatureEdgeSmoothing</span><span class="p">(</span><span class="n">feature_smoothing</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="n">feature_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetEdgeAngle</span><span class="p">(</span><span class="n">edge_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetBoundarySmoothing</span><span class="p">(</span><span class="n">boundary_smoothing</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetRelaxationFactor</span><span class="p">(</span><span class="n">relaxation_factor</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Smoothing Mesh&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.smooth_taubin"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.smooth_taubin.html#pyvista.PolyDataFilters.smooth_taubin">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_taubin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">pass_band</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">edge_angle</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">feature_angle</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span>
        <span class="n">boundary_smoothing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">feature_smoothing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">non_manifold_smoothing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Smooth a PolyData DataSet with Taubin smoothing.</span>

<span class="sd">        This filter allows you to smooth the mesh as in the Laplacian smoothing</span>
<span class="sd">        implementation in :func:`smooth() &lt;PolyDataFilters.smooth&gt;`. However,</span>
<span class="sd">        unlike Laplacian smoothing the surface does not &quot;shrink&quot; since this</span>
<span class="sd">        filter relies on an alternative approach to smoothing. This filter is</span>
<span class="sd">        more akin to a low pass filter where undesirable high frequency features</span>
<span class="sd">        are removed.</span>

<span class="sd">        This PyVista filter uses the VTK `vtkWindowedSincPolyDataFilter</span>
<span class="sd">        &lt;https://vtk.org/doc/nightly/html/classvtkWindowedSincPolyDataFilter.html&gt;`_</span>
<span class="sd">        filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter : int, optional</span>
<span class="sd">            This is the degree of the polynomial used to approximate the</span>
<span class="sd">            windowed sync function. This is generally much less than the number</span>
<span class="sd">            needed by :func:`smooth() &lt;PolyDataFilters.smooth&gt;`.</span>

<span class="sd">        pass_band : float, optional</span>
<span class="sd">            The passband value for the windowed sinc filter. This should be</span>
<span class="sd">            between 0 and 2, where lower values cause more smoothing.</span>

<span class="sd">        edge_angle : float, optional</span>
<span class="sd">            Edge angle to control smoothing along edges (either interior or</span>
<span class="sd">            boundary).</span>

<span class="sd">        feature_angle : float, optional</span>
<span class="sd">            Feature angle for sharp edge identification.</span>

<span class="sd">        boundary_smoothing : bool, optional</span>
<span class="sd">            Flag to control smoothing of boundary edges. When ``True``,</span>
<span class="sd">            boundary edges remain fixed. Default ``True``.</span>

<span class="sd">        feature_smoothing : bool, optional</span>
<span class="sd">            Flag to control smoothing of feature edges.  When ``True``,</span>
<span class="sd">            boundary edges remain fixed as defined by ``feature_angle`` and</span>
<span class="sd">            ``edge_angle``. Default ``False``.</span>

<span class="sd">        non_manifold_smoothing : bool, optional</span>
<span class="sd">            Smooth non-manifold points, default ``False``.</span>

<span class="sd">        normalize_coordinates : bool, optional</span>
<span class="sd">            Flag to control coordinate normalization. To improve the</span>
<span class="sd">            numerical stability of the solution and minimize the scaling of the</span>
<span class="sd">            translation effects, the algorithm can translate and scale the</span>
<span class="sd">            position coordinates to within the unit cube ``[-1, 1]``, perform the</span>
<span class="sd">            smoothing, and translate and scale the position coordinates back to</span>
<span class="sd">            the original coordinate frame. This defaults to ``False``.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Smoothed mesh.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For maximum performance, do not enable ``feature_smoothing`` or</span>
<span class="sd">        ``boundary_smoothing``. ``feature_smoothing`` is especially expensive.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        See `Optimal Surface Smoothing as Filter Design</span>
<span class="sd">        &lt;https://dl.acm.org/doi/pdf/10.1145/218380.218473&gt;` for details</span>
<span class="sd">        regarding the implementation of Taubin smoothing.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Smooth the example bone mesh. Here, it&#39;s necessary to subdivide the</span>
<span class="sd">        mesh to increase the number of faces as the original mesh is so coarse.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.download_foot_bones().subdivide(2)</span>
<span class="sd">        &gt;&gt;&gt; smoothed_mesh = mesh.smooth_taubin()</span>
<span class="sd">        &gt;&gt;&gt; pl = pv.Plotter(shape=(1, 2))</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(mesh)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_text(&#39;Original Mesh&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.subplot(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(smoothed_mesh)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_text(&#39;Smoothed Mesh&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`surface_smoothing_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkWindowedSincPolyDataFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNumberOfIterations</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetFeatureEdgeSmoothing</span><span class="p">(</span><span class="n">feature_smoothing</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNonManifoldSmoothing</span><span class="p">(</span><span class="n">non_manifold_smoothing</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="n">feature_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetEdgeAngle</span><span class="p">(</span><span class="n">edge_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetBoundarySmoothing</span><span class="p">(</span><span class="n">boundary_smoothing</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassBand</span><span class="p">(</span><span class="n">pass_band</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNormalizeCoordinates</span><span class="p">(</span><span class="n">normalize_coordinates</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Smoothing Mesh using Taubin Smoothing&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.decimate_pro"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.decimate_pro.html#pyvista.PolyDataFilters.decimate_pro">[docs]</a>    <span class="k">def</span> <span class="nf">decimate_pro</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reduction</span><span class="p">,</span>
        <span class="n">feature_angle</span><span class="o">=</span><span class="mf">45.0</span><span class="p">,</span>
        <span class="n">split_angle</span><span class="o">=</span><span class="mf">75.0</span><span class="p">,</span>
        <span class="n">splitting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pre_split_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">boundary_vertex_deletion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce the number of triangles in a triangular mesh.</span>

<span class="sd">        It forms a good approximation to the original geometry. Based</span>
<span class="sd">        on the algorithm originally described in &quot;Decimation of</span>
<span class="sd">        Triangle Meshes&quot;, Proc Siggraph 92</span>
<span class="sd">        (https://doi.org/10.1145/133994.134010).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduction : float</span>
<span class="sd">            Reduction factor. A value of 0.9 will leave 10% of the</span>
<span class="sd">            original number of vertices.</span>

<span class="sd">        feature_angle : float, optional</span>
<span class="sd">            Angle used to define what an edge is (i.e., if the surface</span>
<span class="sd">            normal between two adjacent triangles is &gt;= ``feature_angle``,</span>
<span class="sd">            an edge exists).</span>

<span class="sd">        split_angle : float, optional</span>
<span class="sd">            Angle used to control the splitting of the mesh. A split</span>
<span class="sd">            line exists when the surface normals between two edge</span>
<span class="sd">            connected triangles are &gt;= ``split_angle``.</span>

<span class="sd">        splitting : bool, optional</span>
<span class="sd">            Controls the splitting of the mesh at corners, along</span>
<span class="sd">            edges, at non-manifold points, or anywhere else a split is</span>
<span class="sd">            required. Turning splitting off will better preserve the</span>
<span class="sd">            original topology of the mesh, but may not necessarily</span>
<span class="sd">            give the exact requested decimation.</span>

<span class="sd">        pre_split_mesh : bool, optional</span>
<span class="sd">            Separates the mesh into semi-planar patches, which are</span>
<span class="sd">            disconnected from each other. This can give superior</span>
<span class="sd">            results in some cases. If ``pre_split_mesh`` is set to</span>
<span class="sd">            ``True``, the mesh is split with the specified</span>
<span class="sd">            ``split_angle``. Otherwise mesh splitting is deferred as</span>
<span class="sd">            long as possible.</span>

<span class="sd">        preserve_topology : bool, optional</span>
<span class="sd">            Controls topology preservation. If on, mesh splitting and</span>
<span class="sd">            hole elimination will not occur. This may limit the</span>
<span class="sd">            maximum reduction that may be achieved.</span>

<span class="sd">        boundary_vertex_deletion : bool, optional</span>
<span class="sd">            Allow deletion of vertices on the boundary of the mesh.</span>
<span class="sd">            Defaults to ``True``. Turning this off may limit the</span>
<span class="sd">            maximum reduction that may be achieved.</span>

<span class="sd">        max_degree : float, optional</span>
<span class="sd">            The maximum vertex degree. If the number of triangles</span>
<span class="sd">            connected to a vertex exceeds ``max_degree``, then the</span>
<span class="sd">            vertex will be split. The complexity of the triangulation</span>
<span class="sd">            algorithm is proportional to ``max_degree**2``. Setting ``max_degree``</span>
<span class="sd">            small can improve the performance of the algorithm.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to update the mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Decimated mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Decimate a sphere.  First plot the sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(phi_resolution=60, theta_resolution=60)</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot(show_edges=True, line_width=2)</span>

<span class="sd">        Now decimate it and plot it.</span>

<span class="sd">        &gt;&gt;&gt; decimated = sphere.decimate_pro(0.75)</span>
<span class="sd">        &gt;&gt;&gt; decimated.plot(show_edges=True, line_width=2)</span>

<span class="sd">        See :ref:`decimate_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Input mesh for decimation must be all triangles.&quot;</span><span class="p">)</span>

        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDecimatePro</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTargetReduction</span><span class="p">(</span><span class="n">reduction</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPreserveTopology</span><span class="p">(</span><span class="n">preserve_topology</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="n">feature_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSplitting</span><span class="p">(</span><span class="n">splitting</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetSplitAngle</span><span class="p">(</span><span class="n">split_angle</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPreSplitMesh</span><span class="p">(</span><span class="n">pre_split_mesh</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetBoundaryVertexDeletion</span><span class="p">(</span><span class="n">boundary_vertex_deletion</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetDegree</span><span class="p">(</span><span class="n">max_degree</span><span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Decimating Mesh&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.tube"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.tube.html#pyvista.PolyDataFilters.tube">[docs]</a>    <span class="k">def</span> <span class="nf">tube</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">capping</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">n_sides</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">radius_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a tube around each input line.</span>

<span class="sd">        The radius of the tube can be set to linearly vary with a</span>
<span class="sd">        scalar value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radius : float</span>
<span class="sd">            Minimum tube radius (minimum because the tube radius may</span>
<span class="sd">            vary).</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            Scalars array by which the radius varies.</span>

<span class="sd">        capping : bool, optional</span>
<span class="sd">            Turn on/off whether to cap the ends with polygons. Default</span>
<span class="sd">            ``True``.</span>

<span class="sd">        n_sides : int, optional</span>
<span class="sd">            Set the number of sides for the tube. Minimum of 3.</span>

<span class="sd">        radius_factor : float, optional</span>
<span class="sd">            Maximum tube radius in terms of a multiple of the minimum</span>
<span class="sd">            radius.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            The field preference when searching for the scalars array by</span>
<span class="sd">            name.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to update the mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Tube-filtered mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a single line to a tube.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; line = pv.Line()</span>
<span class="sd">        &gt;&gt;&gt; tube = line.tube(radius=0.02)</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Line Cells: {line.n_cells}&#39;</span>
<span class="sd">        &#39;Line Cells: 1&#39;</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Tube Cells: {tube.n_cells}&#39;</span>
<span class="sd">        &#39;Tube Cells: 22&#39;</span>
<span class="sd">        &gt;&gt;&gt; tube.plot(color=&#39;tan&#39;)</span>

<span class="sd">        See :ref:`ref_create_spline` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poly_data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly_data</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">):</span>
            <span class="n">poly_data</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">poly_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_sides</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">n_sides</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">tube</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTubeFilter</span><span class="p">()</span>
        <span class="n">tube</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="n">poly_data</span><span class="p">)</span>
        <span class="c1"># User Defined Parameters</span>
        <span class="n">tube</span><span class="o">.</span><span class="n">SetCapping</span><span class="p">(</span><span class="n">capping</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tube</span><span class="o">.</span><span class="n">SetRadius</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="n">tube</span><span class="o">.</span><span class="n">SetNumberOfSides</span><span class="p">(</span><span class="n">n_sides</span><span class="p">)</span>
        <span class="n">tube</span><span class="o">.</span><span class="n">SetRadiusFactor</span><span class="p">(</span><span class="n">radius_factor</span><span class="p">)</span>
        <span class="c1"># Check if scalars array given</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;scalars array must be given as a string name&#39;</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">poly_data</span><span class="o">.</span><span class="n">get_array_association</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>
            <span class="c1"># args: (idx, port, connection, field, name)</span>
            <span class="n">tube</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scalars</span><span class="p">)</span>
            <span class="n">tube</span><span class="o">.</span><span class="n">SetVaryRadiusToVaryRadiusByScalar</span><span class="p">()</span>
        <span class="c1"># Apply the filter</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">tube</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Creating Tube&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">tube</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">poly_data</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">poly_data</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.subdivide"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.subdivide.html#pyvista.PolyDataFilters.subdivide">[docs]</a>    <span class="k">def</span> <span class="nf">subdivide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">subfilter</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Increase the number of triangles in a single, connected triangular mesh.</span>

<span class="sd">        Uses one of the following vtk subdivision filters to subdivide a mesh:</span>

<span class="sd">        * ``vtkButterflySubdivisionFilter``</span>
<span class="sd">        * ``vtkLoopSubdivisionFilter``</span>
<span class="sd">        * ``vtkLinearSubdivisionFilter``</span>

<span class="sd">        Linear subdivision results in the fastest mesh subdivision,</span>
<span class="sd">        but it does not smooth mesh edges, but rather splits each</span>
<span class="sd">        triangle into 4 smaller triangles.</span>

<span class="sd">        Butterfly and loop subdivision perform smoothing when</span>
<span class="sd">        dividing, and may introduce artifacts into the mesh when</span>
<span class="sd">        dividing.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Subdivision filter sometimes fails for multiple part</span>
<span class="sd">           meshes.  The input should be one connected mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsub : int</span>
<span class="sd">            Number of subdivisions.  Each subdivision creates 4 new</span>
<span class="sd">            triangles, so the number of resulting triangles is</span>
<span class="sd">            ``nface*4**nsub`` where ``nface`` is the current number of</span>
<span class="sd">            faces.</span>

<span class="sd">        subfilter : str, optional</span>
<span class="sd">            Can be one of the following:</span>

<span class="sd">            * ``&#39;butterfly&#39;``</span>
<span class="sd">            * ``&#39;loop&#39;``</span>
<span class="sd">            * ``&#39;linear&#39;``</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place. Default ``False``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Subdivided mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, create an example coarse sphere mesh and plot it.</span>

<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.Sphere(phi_resolution=10, theta_resolution=10)</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        Subdivide the sphere mesh using linear subdivision.</span>

<span class="sd">        &gt;&gt;&gt; submesh = mesh.subdivide(1, &#39;linear&#39;)</span>
<span class="sd">        &gt;&gt;&gt; submesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        Subdivide the sphere mesh using loop subdivision.</span>

<span class="sd">        &gt;&gt;&gt; submesh = mesh.subdivide(1, &#39;loop&#39;)</span>
<span class="sd">        &gt;&gt;&gt; submesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        Subdivide the sphere mesh using butterfly subdivision.</span>

<span class="sd">        &gt;&gt;&gt; submesh = mesh.subdivide(1, &#39;butterfly&#39;)</span>
<span class="sd">        &gt;&gt;&gt; submesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Input mesh for subdivision must be all triangles.&quot;</span><span class="p">)</span>

        <span class="n">subfilter</span> <span class="o">=</span> <span class="n">subfilter</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">subfilter</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">sfilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkLinearSubdivisionFilter</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">subfilter</span> <span class="o">==</span> <span class="s1">&#39;butterfly&#39;</span><span class="p">:</span>
            <span class="n">sfilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkButterflySubdivisionFilter</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">subfilter</span> <span class="o">==</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
            <span class="n">sfilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkLoopSubdivisionFilter</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Subdivision filter must be one of the following: &quot;</span>
                <span class="s2">&quot;&#39;butterfly&#39;, &#39;loop&#39;, or &#39;linear&#39;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Subdivide</span>
        <span class="n">sfilter</span><span class="o">.</span><span class="n">SetNumberOfSubdivisions</span><span class="p">(</span><span class="n">nsub</span><span class="p">)</span>
        <span class="n">sfilter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">sfilter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Subdividing Mesh&#39;</span><span class="p">)</span>

        <span class="n">submesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">sfilter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">submesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">submesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.subdivide_adaptive"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.subdivide_adaptive.html#pyvista.PolyDataFilters.subdivide_adaptive">[docs]</a>    <span class="k">def</span> <span class="nf">subdivide_adaptive</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_edge_len</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tri_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_n_tris</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_n_passes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Increase the number of triangles in a triangular mesh based on edge and/or area metrics.</span>

<span class="sd">        This filter uses a simple case-based, multi-pass approach to</span>
<span class="sd">        repeatedly subdivide the input triangle mesh to meet the area</span>
<span class="sd">        and/or edge length criteria. New points may be inserted only</span>
<span class="sd">        on edges; depending on the number of edges to be subdivided a</span>
<span class="sd">        different number of triangles are inserted ranging from two</span>
<span class="sd">        (i.e., two triangles replace the original one) to four.</span>

<span class="sd">        Point and cell data is treated as follows: The cell data from</span>
<span class="sd">        a parent triangle is assigned to its subdivided</span>
<span class="sd">        children. Point data is interpolated along edges as the edges</span>
<span class="sd">        are subdivided.</span>

<span class="sd">        This filter retains mesh watertightness if the mesh was</span>
<span class="sd">        originally watertight; and the area and max triangles criteria</span>
<span class="sd">        are not used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_edge_len : float, optional</span>
<span class="sd">            The maximum edge length that a triangle may have. Edges</span>
<span class="sd">            longer than this value are split in half and the</span>
<span class="sd">            associated triangles are modified accordingly.</span>

<span class="sd">        max_tri_area : float, optional</span>
<span class="sd">            The maximum area that a triangle may have. Triangles</span>
<span class="sd">            larger than this value are subdivided to meet this</span>
<span class="sd">            threshold. Note that if this criterion is used it may</span>
<span class="sd">            produce non-watertight meshes as a result.</span>

<span class="sd">        max_n_tris : int, optional</span>
<span class="sd">            The maximum number of triangles that can be created. If</span>
<span class="sd">            the limit is hit, it may result in premature termination</span>
<span class="sd">            of the algorithm and the results may be less than</span>
<span class="sd">            satisfactory (for example non-watertight meshes may be</span>
<span class="sd">            created). By default, the limit is set to a very large</span>
<span class="sd">            number (i.e., no effective limit).</span>

<span class="sd">        max_n_passes : int, optional</span>
<span class="sd">            The maximum number of passes (i.e., levels of</span>
<span class="sd">            subdivision). If the limit is hit, then the subdivision</span>
<span class="sd">            process stops and additional passes (needed to meet other</span>
<span class="sd">            criteria) are aborted. The default limit is set to a very</span>
<span class="sd">            large number (i.e., no effective limit).</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Subdivided mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, load the example airplane mesh and plot it.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = pyvista.PolyData(examples.planefile)</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        Subdivide the mesh</span>

<span class="sd">        &gt;&gt;&gt; submesh = mesh.subdivide_adaptive(max_n_passes=2)</span>
<span class="sd">        &gt;&gt;&gt; submesh.plot(show_edges=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Input mesh for subdivision must be all triangles.&quot;</span><span class="p">)</span>

        <span class="n">sfilter</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkAdaptiveSubdivisionFilter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_edge_len</span><span class="p">:</span>
            <span class="n">sfilter</span><span class="o">.</span><span class="n">SetMaximumEdgeLength</span><span class="p">(</span><span class="n">max_edge_len</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_tri_area</span><span class="p">:</span>
            <span class="n">sfilter</span><span class="o">.</span><span class="n">SetMaximumTriangleArea</span><span class="p">(</span><span class="n">max_tri_area</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_n_tris</span><span class="p">:</span>
            <span class="n">sfilter</span><span class="o">.</span><span class="n">SetMaximumNumberOfTriangles</span><span class="p">(</span><span class="n">max_n_tris</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_n_passes</span><span class="p">:</span>
            <span class="n">sfilter</span><span class="o">.</span><span class="n">SetMaximumNumberOfPasses</span><span class="p">(</span><span class="n">max_n_passes</span><span class="p">)</span>

        <span class="n">sfilter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">sfilter</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Adaptively Subdividing Mesh&#39;</span><span class="p">)</span>
        <span class="n">submesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">sfilter</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">submesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">submesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.decimate"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.decimate.html#pyvista.PolyDataFilters.decimate">[docs]</a>    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_reduction</span><span class="p">,</span>
        <span class="n">volume_preservation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">attribute_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">vectors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">normals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tcoords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tensors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">scalars_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">vectors_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">normals_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">tcoords_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">tensors_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce the number of triangles in a triangular mesh using ``vtkQuadricDecimation``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_reduction : float</span>
<span class="sd">            Fraction of the original mesh to remove.</span>
<span class="sd">            If ``target_reduction`` is set to 0.9, this filter will try</span>
<span class="sd">            to reduce the data set to 10% of its original size and will</span>
<span class="sd">            remove 90% of the input triangles.</span>

<span class="sd">        volume_preservation : bool, optional</span>
<span class="sd">            Decide whether to activate volume preservation which greatly</span>
<span class="sd">            reduces errors in triangle normal direction. If ``False``,</span>
<span class="sd">            volume preservation is disabled and if ``attribute_error``</span>
<span class="sd">            is active, these errors can be large. Defaults to ``False``.</span>

<span class="sd">        attribute_error : bool, optional</span>
<span class="sd">            Decide whether to include data attributes in the error</span>
<span class="sd">            metric. If ``False``, then only geometric error is used to</span>
<span class="sd">            control the decimation. Defaults to ``False``. If ``True``,</span>
<span class="sd">            the following flags are used to specify which attributes</span>
<span class="sd">            are to be included in the error calculation.</span>

<span class="sd">        scalars : bool, optional</span>
<span class="sd">            If attribute errors are to be included in the metric (i.e.,</span>
<span class="sd">            ``attribute_error`` is ``True``), then these flags control</span>
<span class="sd">            which attributes are to be included in the error</span>
<span class="sd">            calculation. Defaults to ``True``.</span>

<span class="sd">        vectors : bool, optional</span>
<span class="sd">            See ``scalars`` parameter. Defaults to ``True``.</span>

<span class="sd">        normals : bool, optional</span>
<span class="sd">            See ``scalars`` parameter. Defaults to ``False``.</span>

<span class="sd">        tcoords : bool, optional</span>
<span class="sd">            See ``scalars`` parameter. Defaults to ``True``.</span>

<span class="sd">        tensors : bool, optional</span>
<span class="sd">            See ``scalars`` parameter. Defaults to ``True``.</span>

<span class="sd">        scalars_weight : float, optional</span>
<span class="sd">            The scaling weight contribution of the scalar attribute.</span>
<span class="sd">            These values are used to weight the contribution of the</span>
<span class="sd">            attributes towards the error metric. Defaults to 0.1.</span>

<span class="sd">        vectors_weight : float, optional</span>
<span class="sd">            See ``scalars_weight`` parameter. Defaults to 0.1.</span>

<span class="sd">        normals_weight : float, optional</span>
<span class="sd">            See ``scalars_weight`` parameter. Defaults to 0.1.</span>

<span class="sd">        tcoords_weight : float, optional</span>
<span class="sd">            See ``scalars_weight`` parameter. Defaults to 0.1.</span>

<span class="sd">        tensors_weight : float, optional</span>
<span class="sd">            See ``scalars_weight`` parameter. Defaults to 0.1.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to update the mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Decimated mesh.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you encounter a segmentation fault or other error,</span>
<span class="sd">        consider using :func:`pyvista.clean` to remove any invalid</span>
<span class="sd">        cells before using this filter.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Decimate a sphere.  First plot the sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; sphere = pyvista.Sphere(phi_resolution=60, theta_resolution=60)</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot(show_edges=True, line_width=2)</span>

<span class="sd">        Now decimate it by 75% and plot it.</span>

<span class="sd">        &gt;&gt;&gt; decimated = sphere.decimate(0.75)</span>
<span class="sd">        &gt;&gt;&gt; decimated.plot(show_edges=True, line_width=2)</span>

<span class="sd">        See :ref:`decimate_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Input mesh for decimation must be all triangles.&quot;</span><span class="p">)</span>

        <span class="c1"># create decimation filter</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkQuadricDecimation</span><span class="p">()</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetVolumePreservation</span><span class="p">(</span><span class="n">volume_preservation</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetAttributeErrorMetric</span><span class="p">(</span><span class="n">attribute_error</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetScalarsAttribute</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetVectorsAttribute</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNormalsAttribute</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTCoordsAttribute</span><span class="p">(</span><span class="n">tcoords</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTensorsAttribute</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetScalarsWeight</span><span class="p">(</span><span class="n">scalars_weight</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetVectorsWeight</span><span class="p">(</span><span class="n">vectors_weight</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNormalsWeight</span><span class="p">(</span><span class="n">normals_weight</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTCoordsWeight</span><span class="p">(</span><span class="n">tcoords_weight</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTensorsWeight</span><span class="p">(</span><span class="n">tensors_weight</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTargetReduction</span><span class="p">(</span><span class="n">target_reduction</span><span class="p">)</span>

        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Decimating Mesh&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.compute_normals"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.compute_normals.html#pyvista.PolyDataFilters.compute_normals">[docs]</a>    <span class="k">def</span> <span class="nf">compute_normals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cell_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">point_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">split_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">flip_normals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">consistent_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">auto_orient_normals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">non_manifold_traversal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">feature_angle</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute point and/or cell normals for a mesh.</span>

<span class="sd">        The filter can reorder polygons to insure consistent</span>
<span class="sd">        orientation across polygon neighbors. Sharp edges can be split</span>
<span class="sd">        and points duplicated with separate normals to give crisp</span>
<span class="sd">        (rendered) surface definition. It is also possible to globally</span>
<span class="sd">        flip the normal orientation.</span>

<span class="sd">        The algorithm works by determining normals for each polygon</span>
<span class="sd">        and then averaging them at shared points. When sharp edges are</span>
<span class="sd">        present, the edges are split and new points generated to</span>
<span class="sd">        prevent blurry edges (due to Phong shading).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cell_normals : bool, optional</span>
<span class="sd">            Calculation of cell normals. Defaults to ``True``.</span>

<span class="sd">        point_normals : bool, optional</span>
<span class="sd">            Calculation of point normals. Defaults to ``True``.</span>

<span class="sd">        split_vertices : bool, optional</span>
<span class="sd">            Splitting of sharp edges. Defaults to ``False``. Indices to the</span>
<span class="sd">            original points are tracked in the ``&quot;pyvistaOriginalPointIds&quot;``</span>
<span class="sd">            array.</span>

<span class="sd">        flip_normals : bool, optional</span>
<span class="sd">            Set global flipping of normal orientation. Flipping</span>
<span class="sd">            modifies both the normal direction and the order of a</span>
<span class="sd">            cell&#39;s points. Defaults to ``False``.</span>

<span class="sd">        consistent_normals : bool, optional</span>
<span class="sd">            Enforcement of consistent polygon ordering. Defaults to ``True``.</span>

<span class="sd">        auto_orient_normals : bool, optional</span>
<span class="sd">            Turn on/off the automatic determination of correct normal</span>
<span class="sd">            orientation. NOTE: This assumes a completely closed</span>
<span class="sd">            surface (i.e. no boundary edges) and no non-manifold</span>
<span class="sd">            edges. If these constraints do not hold, all bets are</span>
<span class="sd">            off. This option adds some computational complexity, and</span>
<span class="sd">            is useful if you do not want to have to inspect the</span>
<span class="sd">            rendered image to determine whether to turn on the</span>
<span class="sd">            ``flip_normals`` flag.  However, this flag can work with</span>
<span class="sd">            the ``flip_normals`` flag, and if both are set, all the</span>
<span class="sd">            normals in the output will point &quot;inward&quot;. Defaults to</span>
<span class="sd">            ``False``.</span>

<span class="sd">        non_manifold_traversal : bool, optional</span>
<span class="sd">            Turn on/off traversal across non-manifold edges. Changing</span>
<span class="sd">            this may prevent problems where the consistency of</span>
<span class="sd">            polygonal ordering is corrupted due to topological</span>
<span class="sd">            loops. Defaults to ``True``.</span>

<span class="sd">        feature_angle : float, optional</span>
<span class="sd">            The angle that defines a sharp edge. If the difference in</span>
<span class="sd">            angle across neighboring polygons is greater than this</span>
<span class="sd">            value, the shared edge is considered &quot;sharp&quot;. Defaults to</span>
<span class="sd">            30.0.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place. Defaults to ``False``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Updated mesh with cell and point normals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Previous arrays named ``&quot;Normals&quot;`` will be overwritten.</span>

<span class="sd">        Normals are computed only for polygons and triangle</span>
<span class="sd">        strips. Normals are not computed for lines or vertices.</span>

<span class="sd">        Triangle strips are broken up into triangle polygons. You may</span>
<span class="sd">        want to restrip the triangles.</span>

<span class="sd">        It may be easier to run</span>
<span class="sd">        :func:`pyvista.PolyData.point_normals` or</span>
<span class="sd">        :func:`pyvista.PolyData.cell_normals` if you would just</span>
<span class="sd">        like the array of point or cell normals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute the point normals of the surface of a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere = sphere.compute_normals(cell_normals=False)</span>
<span class="sd">        &gt;&gt;&gt; normals = sphere[&#39;Normals&#39;]</span>
<span class="sd">        &gt;&gt;&gt; normals.shape</span>
<span class="sd">        (842, 3)</span>

<span class="sd">        Alternatively, create a new mesh when computing the normals</span>
<span class="sd">        and compute both cell and point normals.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere_with_norm = sphere.compute_normals()</span>
<span class="sd">        &gt;&gt;&gt; sphere_with_norm.point_data[&#39;Normals&#39;].shape</span>
<span class="sd">        (842, 3)</span>
<span class="sd">        &gt;&gt;&gt; sphere_with_norm.cell_data[&#39;Normals&#39;].shape</span>
<span class="sd">        (1680, 3)</span>

<span class="sd">        See :ref:`surface_normal_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># track original point indices</span>
        <span class="k">if</span> <span class="n">split_vertices</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pyvista</span><span class="o">.</span><span class="n">ID_TYPE</span><span class="p">),</span> <span class="s1">&#39;pyvistaOriginalPointIds&#39;</span>
            <span class="p">)</span>

        <span class="n">normal</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPolyDataNormals</span><span class="p">()</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetComputeCellNormals</span><span class="p">(</span><span class="n">cell_normals</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetComputePointNormals</span><span class="p">(</span><span class="n">point_normals</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetSplitting</span><span class="p">(</span><span class="n">split_vertices</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetFlipNormals</span><span class="p">(</span><span class="n">flip_normals</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetConsistency</span><span class="p">(</span><span class="n">consistent_normals</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetAutoOrientNormals</span><span class="p">(</span><span class="n">auto_orient_normals</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetNonManifoldTraversal</span><span class="p">(</span><span class="n">non_manifold_traversal</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="n">feature_angle</span><span class="p">)</span>
        <span class="n">normal</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing Normals&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">point_normals</span><span class="p">:</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">SetActiveNormals</span><span class="p">(</span><span class="s1">&#39;Normals&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell_normals</span><span class="p">:</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">GetCellData</span><span class="p">()</span><span class="o">.</span><span class="n">SetActiveNormals</span><span class="p">(</span><span class="s1">&#39;Normals&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.clip_closed_surface"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.clip_closed_surface.html#pyvista.PolyDataFilters.clip_closed_surface">[docs]</a>    <span class="k">def</span> <span class="nf">clip_closed_surface</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip a closed polydata surface with a plane.</span>

<span class="sd">        This currently only supports one plane but could be</span>
<span class="sd">        implemented to handle a plane collection.</span>

<span class="sd">        It will produce a new closed surface by creating new polygonal</span>
<span class="sd">        faces where the input data was clipped.</span>

<span class="sd">        Non-manifold surfaces should not be used as input for this</span>
<span class="sd">        filter.  The input surface should have no open edges, and must</span>
<span class="sd">        not have any edges that are shared by more than two faces. In</span>
<span class="sd">        addition, the input surface should not self-intersect, meaning</span>
<span class="sd">        that the faces of the surface should only touch at their</span>
<span class="sd">        edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normal : str, list, optional</span>
<span class="sd">            Plane normal to clip with.  Plane is centered at</span>
<span class="sd">            ``origin``.  Normal can be either a 3 member list</span>
<span class="sd">            (e.g. ``[0, 0, 1]``) or one of the following strings:</span>
<span class="sd">            ``&#39;x&#39;``, ``&#39;y&#39;``, ``&#39;z&#39;``, ``&#39;-x&#39;``, ``&#39;-y&#39;``, or</span>
<span class="sd">            ``&#39;-z&#39;``.</span>

<span class="sd">        origin : list, optional</span>
<span class="sd">            Coordinate of the origin (e.g. ``[1, 0, 0]``).  Defaults</span>
<span class="sd">            to the center of the mesh.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance for creating new points while clipping.  If</span>
<span class="sd">            the tolerance is too small, then degenerate triangles</span>
<span class="sd">            might be produced.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place. Defaults to ``False``.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The clipped mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Clip a sphere in the X direction centered at the origin.  This</span>
<span class="sd">        will leave behind half a sphere in the positive X direction.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; clipped_mesh = sphere.clip_closed_surface(&#39;-z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; clipped_mesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        Clip the sphere at the XY plane and leave behind half the</span>
<span class="sd">        sphere in the positive Z direction.  Shift the clip upwards to</span>
<span class="sd">        leave a smaller mesh behind.</span>

<span class="sd">        &gt;&gt;&gt; clipped_mesh = sphere.clip_closed_surface(&#39;z&#39;, origin=[0, 0, 0.3])</span>
<span class="sd">        &gt;&gt;&gt; clipped_mesh.plot(show_edges=True, line_width=3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verify it is manifold</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_open_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This surface appears to be non-manifold.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">NORMALS</span><span class="p">[</span><span class="n">normal</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="c1"># find center of data if origin not specified</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>

        <span class="c1"># create the plane for clipping</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">generate_plane</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPlaneCollection</span><span class="p">()</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">AddItem</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>

        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkClipClosedSurface</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateFaces</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetClippingPlanes</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Clipping Closed Surface&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="PolyDataFilters.fill_holes"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.fill_holes.html#pyvista.PolyDataFilters.fill_holes">[docs]</a>    <span class="k">def</span> <span class="nf">fill_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hole_size</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill holes in a pyvista.PolyData or vtk.vtkPolyData object.</span>

<span class="sd">        Holes are identified by locating boundary edges, linking them</span>
<span class="sd">        together into loops, and then triangulating the resulting</span>
<span class="sd">        loops. Note that you can specify an approximate limit to the</span>
<span class="sd">        size of the hole that can be filled.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           This method is known to segfault.  Use at your own risk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hole_size : float</span>
<span class="sd">            Specifies the maximum hole size to fill. This is</span>
<span class="sd">            represented as a radius to the bounding circumsphere</span>
<span class="sd">            containing the hole. Note that this is an approximate</span>
<span class="sd">            area; the actual area cannot be computed without first</span>
<span class="sd">            triangulating the hole.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Return new mesh or overwrite input.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh with holes filled if ``inplace=False``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a partial sphere with a hole and then fill it.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere_with_hole = pv.Sphere(end_theta=330)</span>
<span class="sd">        &gt;&gt;&gt; sphere = sphere_with_hole.fill_holes(1000)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; edges = sphere.extract_feature_edges(feature_edges=False,</span>
<span class="sd">        ...                                      manifold_edges=False)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; assert edges.n_cells == 0  # doctest:+SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;pyvista.PolyData.fill_holes is known to segfault. Use at your own risk&#39;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkFillHolesFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetHoleSize</span><span class="p">(</span><span class="n">hole_size</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Filling Holes&#39;</span><span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.clean"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.clean.html#pyvista.PolyDataFilters.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">point_merging</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lines_to_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polys_to_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strips_to_polys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean the mesh.</span>

<span class="sd">        This merges duplicate points, removes unused points, and/or</span>
<span class="sd">        removes degenerate cells.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point_merging : bool, optional</span>
<span class="sd">            Enables point merging.  ``True`` by default.</span>

<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Set merging tolerance.  When enabled merging is set to</span>
<span class="sd">            absolute distance. If ``absolute`` is ``False``, then the</span>
<span class="sd">            merging tolerance is a fraction of the bounding box</span>
<span class="sd">            length. The alias ``merge_tol`` is also excepted.</span>

<span class="sd">        lines_to_points : bool, optional</span>
<span class="sd">            Enable or disable the conversion of degenerate lines to</span>
<span class="sd">            points.  Enabled by default.</span>

<span class="sd">        polys_to_lines : bool, optional</span>
<span class="sd">            Enable or disable the conversion of degenerate polys to</span>
<span class="sd">            lines.  Enabled by default.</span>

<span class="sd">        strips_to_polys : bool, optional</span>
<span class="sd">            Enable or disable the conversion of degenerate strips to</span>
<span class="sd">            polys.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place. Default ``False``.</span>

<span class="sd">        absolute : bool, optional</span>
<span class="sd">            Control if ``tolerance`` is an absolute distance or a</span>
<span class="sd">            fraction.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Accepts for ``merge_tol`` to replace the ``tolerance``</span>
<span class="sd">            keyword argument.  This may be deprecated in future.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Cleaned mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a mesh with a degenerate face and then clean it,</span>
<span class="sd">        removing the degenerate face</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[0, 0, 0], [0, 1, 0], [1, 0, 0]], dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; faces = np.array([3, 0, 1, 2, 3, 0, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mesh = pv.PolyData(points, faces)</span>
<span class="sd">        &gt;&gt;&gt; mout = mesh.clean()</span>
<span class="sd">        &gt;&gt;&gt; mout.faces  # doctest:+SKIP</span>
<span class="sd">        array([3, 0, 1, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;merge_tol&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">assert_empty_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCleanPolyData</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPointMerging</span><span class="p">(</span><span class="n">point_merging</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetConvertLinesToPoints</span><span class="p">(</span><span class="n">lines_to_points</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetConvertPolysToLines</span><span class="p">(</span><span class="n">polys_to_lines</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetConvertStripsToPolys</span><span class="p">(</span><span class="n">strips_to_polys</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">absolute</span><span class="p">:</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">ToleranceIsAbsoluteOn</span><span class="p">()</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">SetAbsoluteTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Cleaning&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>

        <span class="c1"># Check output so no segfaults occur</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">n_points</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Clean tolerance is too high. Empty mesh returned.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PolyDataFilters.geodesic"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.geodesic.html#pyvista.PolyDataFilters.geodesic">[docs]</a>    <span class="k">def</span> <span class="nf">geodesic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the geodesic path between two vertices using Dijkstra&#39;s algorithm.</span>

<span class="sd">        This will add an array titled ``&#39;vtkOriginalPointIds&#39;`` of the input</span>
<span class="sd">        mesh&#39;s point ids to the output mesh. The default behavior of the</span>
<span class="sd">        underlying ``vtkDijkstraGraphGeodesicPath`` filter is that the</span>
<span class="sd">        geodesic path is reversed in the resulting mesh. This is overridden</span>
<span class="sd">        in PyVista by default.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_vertex : int</span>
<span class="sd">            Vertex index indicating the start point of the geodesic segment.</span>

<span class="sd">        end_vertex : int</span>
<span class="sd">            Vertex index indicating the end point of the geodesic segment.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether the input mesh should be replaced with the path. The</span>
<span class="sd">            geodesic path is always returned.</span>

<span class="sd">        keep_order : bool, optional</span>
<span class="sd">            If ``True``, the points of the returned path are guaranteed</span>
<span class="sd">            to start with the start vertex (as opposed to the end vertex).</span>

<span class="sd">            .. versionadded:: 0.32.0</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            ``PolyData`` object consisting of the line segment between the</span>
<span class="sd">            two given vertices. If ``inplace`` is ``True`` this is the</span>
<span class="sd">            same object as the input mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Plot the path between two points on the random hills mesh.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; path = hills.geodesic(560, 5820)</span>
<span class="sd">        &gt;&gt;&gt; pl = pv.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(hills)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(path, line_width=5, color=&#39;k&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`geodesic_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start_vertex</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">end_vertex</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Invalid point indices.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Input mesh for geodesic path must be all triangles.&quot;</span><span class="p">)</span>

        <span class="n">dijkstra</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDijkstraGraphGeodesicPath</span><span class="p">()</span>
        <span class="n">dijkstra</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">dijkstra</span><span class="o">.</span><span class="n">SetStartVertex</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>
        <span class="n">dijkstra</span><span class="o">.</span><span class="n">SetEndVertex</span><span class="p">(</span><span class="n">end_vertex</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">dijkstra</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Calculating the Geodesic Path&#39;</span><span class="p">)</span>
        <span class="n">original_ids</span> <span class="o">=</span> <span class="n">vtk_id_list_to_array</span><span class="p">(</span><span class="n">dijkstra</span><span class="o">.</span><span class="n">GetIdList</span><span class="p">())</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">dijkstra</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;vtkOriginalPointIds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_ids</span>

        <span class="c1"># Do not copy textures from input</span>
        <span class="n">output</span><span class="o">.</span><span class="n">clear_textures</span><span class="p">()</span>

        <span class="c1"># ensure proper order if requested</span>
        <span class="k">if</span> <span class="n">keep_order</span> <span class="ow">and</span> <span class="n">original_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_vertex</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">points</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;vtkOriginalPointIds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s2">&quot;vtkOriginalPointIds&quot;</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PolyDataFilters.geodesic_distance"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.geodesic_distance.html#pyvista.PolyDataFilters.geodesic_distance">[docs]</a>    <span class="k">def</span> <span class="nf">geodesic_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the geodesic distance between two vertices using Dijkstra&#39;s algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_vertex : int</span>
<span class="sd">            Vertex index indicating the start point of the geodesic segment.</span>

<span class="sd">        end_vertex : int</span>
<span class="sd">            Vertex index indicating the end point of the geodesic segment.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Length of the geodesic segment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; length = sphere.geodesic_distance(0, 100)</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Length is {length:.3f}&#39;</span>
<span class="sd">        &#39;Length is 0.812&#39;</span>

<span class="sd">        See :ref:`geodesic_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">,</span> <span class="n">end_vertex</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">compute_cell_sizes</span><span class="p">(</span>
            <span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span>
        <span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;Length&#39;</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">path</span>
        <span class="k">del</span> <span class="n">sizes</span>
        <span class="k">return</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="PolyDataFilters.ray_trace"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.ray_trace.html#pyvista.PolyDataFilters.ray_trace">[docs]</a>    <span class="k">def</span> <span class="nf">ray_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">end_point</span><span class="p">,</span> <span class="n">first_point</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">off_screen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a single ray trace calculation.</span>

<span class="sd">        This requires a mesh and a line segment defined by an origin</span>
<span class="sd">        and end_point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin : np.ndarray or list</span>
<span class="sd">            Start of the line segment.</span>

<span class="sd">        end_point : np.ndarray or list</span>
<span class="sd">            End of the line segment.</span>

<span class="sd">        first_point : bool, optional</span>
<span class="sd">            Returns intersection of first point only.</span>

<span class="sd">        plot : bool, optional</span>
<span class="sd">            Whether to plot the ray trace results.</span>

<span class="sd">        off_screen : bool, optional</span>
<span class="sd">            Plots off screen when ``plot=True``.  Used for unit testing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intersection_points : numpy.ndarray</span>
<span class="sd">            Location of the intersection points.  Empty array if no</span>
<span class="sd">            intersections.</span>

<span class="sd">        intersection_cells : numpy.ndarray</span>
<span class="sd">            Indices of the intersection cells.  Empty array if no</span>
<span class="sd">            intersections.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute the intersection between a ray from the origin to</span>
<span class="sd">        ``[1, 0, 0]`` and a sphere with radius 0.5 centered at the</span>
<span class="sd">        origin.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; point, cell = sphere.ray_trace([0, 0, 0], [1, 0, 0], first_point=True)</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Intersected at {point[0]:.3f} {point[1]:.3f} {point[2]:.3f}&#39;</span>
<span class="sd">        &#39;Intersected at 0.499 0.000 0.000&#39;</span>

<span class="sd">        Show a plot of the ray trace.</span>

<span class="sd">        &gt;&gt;&gt; point, cell = sphere.ray_trace([0, 0, 0], [1, 0, 0], plot=True)</span>

<span class="sd">        See :ref:`ray_trace_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkPoints</span><span class="p">()</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkIdList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obbTree</span><span class="o">.</span><span class="n">IntersectWithLine</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">origin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end_point</span><span class="p">),</span> <span class="n">points</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">)</span>

        <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">first_point</span> <span class="ow">and</span> <span class="n">intersection_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">intersection_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">intersection_cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">intersection_points</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">first_point</span><span class="p">:</span>
                <span class="n">ncells</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncells</span> <span class="o">=</span> <span class="n">cell_ids</span><span class="o">.</span><span class="n">GetNumberOfIds</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncells</span><span class="p">):</span>
                <span class="n">intersection_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_ids</span><span class="o">.</span><span class="n">GetId</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">intersection_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intersection_cells</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">off_screen</span><span class="o">=</span><span class="n">off_screen</span><span class="p">)</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Test Mesh&#39;</span><span class="p">)</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">origin</span><span class="p">,</span> <span class="n">end_point</span><span class="p">])</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ray Segment&#39;</span><span class="p">)</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">intersection_points</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">point_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Intersection Points&#39;</span><span class="p">)</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_legend</span><span class="p">()</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_axes</span><span class="p">()</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">intersection_points</span><span class="p">,</span> <span class="n">intersection_cells</span></div>

<div class="viewcode-block" id="PolyDataFilters.multi_ray_trace"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.multi_ray_trace.html#pyvista.PolyDataFilters.multi_ray_trace">[docs]</a>    <span class="k">def</span> <span class="nf">multi_ray_trace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">origins</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">first_point</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">retry</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform multiple ray trace calculations.</span>

<span class="sd">        This requires a mesh with only triangular faces, an array of</span>
<span class="sd">        origin points and an equal sized array of direction vectors to</span>
<span class="sd">        trace along.</span>

<span class="sd">        The embree library used for vectorization of the ray traces is</span>
<span class="sd">        known to occasionally return no intersections where the VTK</span>
<span class="sd">        implementation would return an intersection.  If the result</span>
<span class="sd">        appears to be missing some intersection points, set</span>
<span class="sd">        ``retry=True`` to run a second pass over rays that returned no</span>
<span class="sd">        intersections, using :func:`PolyDataFilters.ray_trace`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origins : sequence</span>
<span class="sd">            Starting point for each trace.</span>

<span class="sd">        directions : sequence</span>
<span class="sd">            Direction vector for each trace.</span>

<span class="sd">        first_point : bool, optional</span>
<span class="sd">            Returns intersection of first point only.</span>

<span class="sd">        retry : bool, optional</span>
<span class="sd">            Will retry rays that return no intersections using</span>
<span class="sd">            :func:`PolyDataFilters.ray_trace`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intersection_points : numpy.ndarray</span>
<span class="sd">            Location of the intersection points.  Empty array if no</span>
<span class="sd">            intersections.</span>

<span class="sd">        intersection_rays : numpy.ndarray</span>
<span class="sd">            Indices of the ray for each intersection point. Empty array if no</span>
<span class="sd">            intersections.</span>

<span class="sd">        intersection_cells : numpy.ndarray</span>
<span class="sd">            Indices of the intersection cells.  Empty array if no</span>
<span class="sd">            intersections.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute the intersection between rays from the origin in</span>
<span class="sd">        directions ``[1, 0, 0]``, ``[0, 1, 0]`` and ``[0, 0, 1]``, and</span>
<span class="sd">        a sphere with radius 0.5 centered at the origin</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; points, rays, cells = sphere.multi_ray_trace([[0, 0, 0]]*3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]], first_point=True)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; string = &quot;, &quot;.join([f&quot;({point[0]:.3f}, {point[1]:.3f}, {point[2]:.3f})&quot; for point in points]) # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Rays intersected at {string}&#39; # doctest:+SKIP</span>
<span class="sd">        &#39;Rays intersected at (0.499, 0.000, 0.000), (0.000, 0.497, 0.000), (0.000, 0.000, 0.500)&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s2">&quot;Input mesh for multi_ray_trace must be all triangles.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pyembree</span>  <span class="c1"># noqa</span>
            <span class="kn">import</span> <span class="nn">rtree</span>  <span class="c1"># noqa</span>
            <span class="kn">import</span> <span class="nn">trimesh</span>  <span class="c1"># noqa</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;To use multi_ray_trace please install trimesh, rtree and pyembree with:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">conda install trimesh rtree pyembree&quot;</span>
            <span class="p">)</span>

        <span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">origins</span><span class="p">)</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>
        <span class="n">faces_as_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_faces</span><span class="p">,</span> <span class="mi">4</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">tmesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">faces_as_array</span><span class="p">)</span>
        <span class="n">locations</span><span class="p">,</span> <span class="n">index_ray</span><span class="p">,</span> <span class="n">index_tri</span> <span class="o">=</span> <span class="n">tmesh</span><span class="o">.</span><span class="n">ray</span><span class="o">.</span><span class="n">intersects_location</span><span class="p">(</span>
            <span class="n">origins</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">multiple_hits</span><span class="o">=</span><span class="ow">not</span> <span class="n">first_point</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">retry</span><span class="p">:</span>
            <span class="c1"># gather intersecting rays in lists</span>
            <span class="n">loc_lst</span><span class="p">,</span> <span class="n">ray_lst</span><span class="p">,</span> <span class="n">tri_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">locations</span><span class="p">,</span> <span class="n">index_ray</span><span class="p">,</span> <span class="n">index_tri</span><span class="p">]]</span>

            <span class="c1"># find indices that trimesh failed on</span>
            <span class="n">all_ray_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">origins</span><span class="p">))</span>
            <span class="n">retry_ray_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_ray_indices</span><span class="p">,</span> <span class="n">index_ray</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># compute ray points for all failed rays at once</span>
            <span class="n">origins_retry</span> <span class="o">=</span> <span class="n">origins</span><span class="p">[</span><span class="n">retry_ray_indices</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># shape (n_retry, 3)</span>
            <span class="n">directions_retry</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="n">retry_ray_indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">unit_directions</span> <span class="o">=</span> <span class="n">directions_retry</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">directions_retry</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">second_points</span> <span class="o">=</span> <span class="n">origins_retry</span> <span class="o">+</span> <span class="n">unit_directions</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>  <span class="c1"># shape (n_retry, 3)</span>

            <span class="k">for</span> <span class="n">id_r</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">second_point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">retry_ray_indices</span><span class="p">,</span> <span class="n">origins_retry</span><span class="p">,</span> <span class="n">second_points</span><span class="p">):</span>
                <span class="n">locs</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_trace</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">second_point</span><span class="p">,</span> <span class="n">first_point</span><span class="o">=</span><span class="n">first_point</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">locs</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">first_point</span><span class="p">:</span>
                        <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                    <span class="n">ray_lst</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">id_r</span><span class="p">]</span> <span class="o">*</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                    <span class="n">tri_lst</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                    <span class="n">loc_lst</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

            <span class="c1"># sort result arrays by ray index</span>
            <span class="n">index_ray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ray_lst</span><span class="p">)</span>
            <span class="n">sorting_inds</span> <span class="o">=</span> <span class="n">index_ray</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
            <span class="n">index_ray</span> <span class="o">=</span> <span class="n">index_ray</span><span class="p">[</span><span class="n">sorting_inds</span><span class="p">]</span>
            <span class="n">index_tri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tri_lst</span><span class="p">)[</span><span class="n">sorting_inds</span><span class="p">]</span>
            <span class="n">locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc_lst</span><span class="p">)[</span><span class="n">sorting_inds</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">locations</span><span class="p">,</span> <span class="n">index_ray</span><span class="p">,</span> <span class="n">index_tri</span></div>

<div class="viewcode-block" id="PolyDataFilters.plot_boundaries"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.plot_boundaries.html#pyvista.PolyDataFilters.plot_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">plot_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot boundaries of a mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_color : color_like, optional</span>
<span class="sd">            The color of the edges when they are added to the plotter.</span>

<span class="sd">        line_width : int, optional</span>
<span class="sd">            Width of the boundary lines.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            All additional keyword arguments will be passed to</span>
<span class="sd">            :func:`pyvista.BasePlotter.add_mesh`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.CameraPosition</span>
<span class="sd">            List of camera position, focal point, and view up.</span>
<span class="sd">            Returned when ``return_cpos`` is ``True``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; hills = examples.load_random_hills()</span>
<span class="sd">        &gt;&gt;&gt; hills.plot_boundaries(line_width=10)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">DataSetFilters</span><span class="o">.</span><span class="n">extract_feature_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>

        <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span>
            <span class="n">off_screen</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;off_screen&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">notebook</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;notebook&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span>
            <span class="n">edges</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;wireframe&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Edges&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span>
        <span class="p">)</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mesh&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">add_legend</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="PolyDataFilters.plot_normals"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.plot_normals.html#pyvista.PolyDataFilters.plot_normals">[docs]</a>    <span class="k">def</span> <span class="nf">plot_normals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">show_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the point normals of a mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show_mesh : bool, optional</span>
<span class="sd">            Plot the mesh itself.  Defaults to ``True``.</span>

<span class="sd">        mag : float, optional</span>
<span class="sd">            Size magnitude of the normal arrows.  Defaults to 1.0.</span>

<span class="sd">        flip : bool, optional</span>
<span class="sd">            Flip the normal direction when ``True``.  Default</span>
<span class="sd">            ``False``.</span>

<span class="sd">        use_every : int, optional</span>
<span class="sd">            Display every nth normal.  By default every normal is</span>
<span class="sd">            displayed.  Display every 10th normal by setting this</span>
<span class="sd">            parameter to 10.</span>

<span class="sd">        faces : bool, optional</span>
<span class="sd">            Plot face normals instead of the default point normals.</span>

<span class="sd">        color : color_like, optional</span>
<span class="sd">            Color of the arrows.  Defaults to</span>
<span class="sd">            :attr:`pyvista.themes.DefaultTheme.edge_color`.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            All additional keyword arguments will be passed to</span>
<span class="sd">            :func:`pyvista.BasePlotter.add_mesh`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.CameraPosition</span>
<span class="sd">            List of camera position, focal point, and view up.</span>
<span class="sd">            Returned when ``return_cpos`` is ``True``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Plot the point normals of a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere(phi_resolution=10, theta_resolution=10)</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot_normals(mag=0.1, show_edges=True)</span>

<span class="sd">        Plot the face normals of a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere(phi_resolution=10, theta_resolution=10)</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot_normals(mag=0.1, faces=True, show_edges=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span>
            <span class="n">off_screen</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;off_screen&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">notebook</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;notebook&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">show_mesh</span><span class="p">:</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">color</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">default_color</span><span class="o">=</span><span class="n">pyvista</span><span class="o">.</span><span class="n">global_theme</span><span class="o">.</span><span class="n">edge_color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">faces</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_centers</span><span class="p">()</span><span class="o">.</span><span class="n">points</span><span class="p">[::</span><span class="n">use_every</span><span class="p">]</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_normals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[::</span><span class="n">use_every</span><span class="p">]</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_normals</span>

        <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>
            <span class="n">normals</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">plotter</span><span class="o">.</span><span class="n">add_arrows</span><span class="p">(</span>
            <span class="n">centers</span><span class="p">,</span> <span class="n">normals</span><span class="p">[::</span><span class="n">use_every</span><span class="p">],</span> <span class="n">mag</span><span class="o">=</span><span class="n">mag</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">show_scalar_bar</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="PolyDataFilters.remove_points"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.remove_points.html#pyvista.PolyDataFilters.remove_points">[docs]</a>    <span class="k">def</span> <span class="nf">remove_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">keep_scalars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rebuild a mesh by removing points.</span>

<span class="sd">        Only valid for all-triangle meshes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remove : np.ndarray</span>
<span class="sd">            If remove is a bool array, points that are ``True`` will</span>
<span class="sd">            be removed.  Otherwise, it is treated as a list of</span>
<span class="sd">            indices.</span>

<span class="sd">        mode : str, optional</span>
<span class="sd">            When ``&#39;all&#39;``, only faces containing all points flagged</span>
<span class="sd">            for removal will be removed.  Default ``&#39;any&#39;``.</span>

<span class="sd">        keep_scalars : bool, optional</span>
<span class="sd">            When ``True``, point and cell scalars will be passed on to</span>
<span class="sd">            the new mesh.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Updates mesh in-place.  Defaults to ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh without the points flagged for removal.</span>

<span class="sd">        numpy.ndarray</span>
<span class="sd">            Indices of new points relative to the original mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Remove the first 100 points from a sphere.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; reduced_sphere, ridx = sphere.remove_points(range(100, 250))</span>
<span class="sd">        &gt;&gt;&gt; reduced_sphere.plot(show_edges=True, line_width=3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>

        <span class="c1"># np.asarray will eat anything, so we have to weed out bogus inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">remove</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Remove must be either a mask or an integer array-like&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remove</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remove</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mask different size than n_points&#39;</span><span class="p">)</span>
            <span class="n">remove_mask</span> <span class="o">=</span> <span class="n">remove</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remove_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">remove_mask</span><span class="p">[</span><span class="n">remove</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span>

        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">vmask</span> <span class="o">=</span> <span class="n">remove_mask</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">fmask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">vmask</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fmask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">vmask</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Regenerate face and point arrays</span>
        <span class="n">uni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">fmask</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">uni</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">nfaces</span> <span class="o">=</span> <span class="n">fmask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nfaces</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pyvista</span><span class="o">.</span><span class="n">ID_TYPE</span><span class="p">)</span>
        <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">uni</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">nfaces</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">newmesh</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">new_points</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ridx</span> <span class="o">=</span> <span class="n">uni</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Add scalars back to mesh if requested</span>
        <span class="k">if</span> <span class="n">keep_scalars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">:</span>
                <span class="n">newmesh</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">ridx</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">newmesh</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">fmask</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unable to pass cell key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> onto reduced mesh&#39;</span><span class="p">)</span>

        <span class="c1"># Return vtk surface and reverse indexing array</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">newmesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ridx</span>
        <span class="k">return</span> <span class="n">newmesh</span><span class="p">,</span> <span class="n">ridx</span></div>

<div class="viewcode-block" id="PolyDataFilters.flip_normals"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.flip_normals.html#pyvista.PolyDataFilters.flip_normals">[docs]</a>    <span class="k">def</span> <span class="nf">flip_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip normals of a triangular mesh by reversing the point ordering.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Flip the normals of a sphere and plot the normals before and</span>
<span class="sd">        after the flip.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot_normals(mag=0.1)</span>
<span class="sd">        &gt;&gt;&gt; sphere.flip_normals()</span>
<span class="sd">        &gt;&gt;&gt; sphere.plot_normals(mag=0.1, opacity=0.5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAllTrianglesError</span><span class="p">(</span><span class="s1">&#39;Can only flip normals on an all triangle mesh.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>
            <span class="c1"># use new connectivity API</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity_array</span>

            <span class="c1"># swap first and last point index in-place</span>
            <span class="c1"># See: https://stackoverflow.com/a/33362288/3369879</span>
            <span class="n">f</span><span class="p">[::</span><span class="mi">3</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">],</span> <span class="n">f</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
            <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">f</span></div>

<div class="viewcode-block" id="PolyDataFilters.delaunay_2d"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.delaunay_2d.html#pyvista.PolyDataFilters.delaunay_2d">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">bound</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a 2D Delaunay filter along the best fitting plane.</span>

<span class="sd">        This filter can be used to generate a 2d surface from a set of</span>
<span class="sd">        points on a plane.  If you want to create a surface from a</span>
<span class="sd">        point cloud, see :func:`pyvista.PolyDataFilters.reconstruct_surface`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            Specify a tolerance to control discarding of closely</span>
<span class="sd">            spaced points. This tolerance is specified as a fraction</span>
<span class="sd">            of the diagonal length of the bounding box of the points.</span>
<span class="sd">            Defaults to ``1e-05``.</span>

<span class="sd">        alpha : float, optional</span>
<span class="sd">            Specify alpha (or distance) value to control output of</span>
<span class="sd">            this filter. For a non-zero alpha value, only edges or</span>
<span class="sd">            triangles contained within a sphere centered at mesh</span>
<span class="sd">            vertices will be output. Otherwise, only triangles will be</span>
<span class="sd">            output. Defaults to ``0.0``.</span>

<span class="sd">        offset : float, optional</span>
<span class="sd">            Specify a multiplier to control the size of the initial,</span>
<span class="sd">            bounding Delaunay triangulation. Defaults to ``1.0``.</span>

<span class="sd">        bound : bool, optional</span>
<span class="sd">            Boolean controls whether bounding triangulation points</span>
<span class="sd">            and associated triangles are included in the</span>
<span class="sd">            output. These are introduced as an initial triangulation</span>
<span class="sd">            to begin the triangulation process. This feature is nice</span>
<span class="sd">            for debugging output. Default ``False``.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, overwrite this mesh with the triangulated</span>
<span class="sd">            mesh. Default ``False``.</span>

<span class="sd">        edge_source : pyvista.PolyData, optional</span>
<span class="sd">            Specify the source object used to specify constrained</span>
<span class="sd">            edges and loops. If set, and lines/polygons are defined, a</span>
<span class="sd">            constrained triangulation is created. The lines/polygons</span>
<span class="sd">            are assumed to reference points in the input point set</span>
<span class="sd">            (i.e. point ids are identical in the input and</span>
<span class="sd">            source).</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress. Default</span>
<span class="sd">            ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh from the 2D delaunay filter.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        First, generate 30 points on circle and plot them.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; points = pyvista.Polygon(n_sides=30).points</span>
<span class="sd">        &gt;&gt;&gt; circle = pyvista.PolyData(points)</span>
<span class="sd">        &gt;&gt;&gt; circle.plot(show_edges=True, point_size=15)</span>

<span class="sd">        Use :func:`delaunay_2d` to fill the interior of the circle.</span>

<span class="sd">        &gt;&gt;&gt; filled_circle = circle.delaunay_2d()</span>
<span class="sd">        &gt;&gt;&gt; filled_circle.plot(show_edges=True, line_width=5)</span>

<span class="sd">        See :ref:`triangulated_surface` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkDelaunay2D</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetProjectionPlaneMode</span><span class="p">(</span><span class="n">_vtk</span><span class="o">.</span><span class="n">VTK_BEST_FITTING_PLANE</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetAlpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetBoundingTriangulation</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetSourceData</span><span class="p">(</span><span class="n">edge_source</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing 2D Triangulation&#39;</span><span class="p">)</span>

        <span class="c1"># Sometimes lines are given in the output. The</span>
        <span class="c1"># `.triangulate()` filter cleans those</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.compute_arc_length"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.compute_arc_length.html#pyvista.PolyDataFilters.compute_arc_length">[docs]</a>    <span class="k">def</span> <span class="nf">compute_arc_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the arc length over the length of the probed line.</span>

<span class="sd">        It adds a new point-data array named ``&quot;arc_length&quot;`` with the</span>
<span class="sd">        computed arc length for each of the polylines in the</span>
<span class="sd">        input. For all other cell types, the arc length is set to 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress. Default</span>
<span class="sd">            ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Arc length of the length of the probed line.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; path = sphere.geodesic(0, 100)</span>
<span class="sd">        &gt;&gt;&gt; length = path.compute_arc_length()[&#39;arc_length&#39;][-1]</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Length is {length:.3f}&#39;</span>
<span class="sd">        &#39;Length is 0.812&#39;</span>

<span class="sd">        This is identical to the geodesic_distance.</span>

<span class="sd">        &gt;&gt;&gt; length = sphere.geodesic_distance(0, 100)</span>
<span class="sd">        &gt;&gt;&gt; f&#39;Length is {length:.3f}&#39;</span>
<span class="sd">        &#39;Length is 0.812&#39;</span>

<span class="sd">        You can also plot the arc_length.</span>

<span class="sd">        &gt;&gt;&gt; arc = path.compute_arc_length()</span>
<span class="sd">        &gt;&gt;&gt; arc.plot(scalars=&quot;arc_length&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkAppendArcLength</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing the Arc Length&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.project_points_to_plane"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.project_points_to_plane.html#pyvista.PolyDataFilters.project_points_to_plane">[docs]</a>    <span class="k">def</span> <span class="nf">project_points_to_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project points of this mesh to a plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin : numpy.ndarray or collections.abc.Sequence, optional</span>
<span class="sd">            Plane origin.  Defaults to the approximate center of the</span>
<span class="sd">            input mesh minus half the length of the input mesh in the</span>
<span class="sd">            direction of the normal.</span>

<span class="sd">        normal : numpy.ndarray or collections.abc.Sequence, optional</span>
<span class="sd">            Plane normal.  Defaults to +Z, i.e. ``[0, 0, 1]``.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to overwrite the original mesh with the projected</span>
<span class="sd">            points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            The points of this mesh projected onto a plane.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Flatten a sphere to the XY plane.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; sphere = pv.Sphere()</span>
<span class="sd">        &gt;&gt;&gt; projected = sphere.project_points_to_plane()</span>
<span class="sd">        &gt;&gt;&gt; projected.plot(show_edges=True, line_width=3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Normal must be a length three vector&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># choose what mesh to use</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Make plane</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">generate_plane</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="c1"># Perform projection in place on the copied mesh</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">plane</span><span class="o">.</span><span class="n">ProjectPoint</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PolyDataFilters.ribbon"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.ribbon.html#pyvista.PolyDataFilters.ribbon">[docs]</a>    <span class="k">def</span> <span class="nf">ribbon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">angle</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">factor</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tcoords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">preference</span><span class="o">=</span><span class="s1">&#39;points&#39;</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ribbon of the lines in this dataset.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If there are no lines in the input dataset, then the output</span>
<span class="sd">           will be an empty :class:`pyvista.PolyData` mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        width : float, optional</span>
<span class="sd">            Set the &quot;half&quot; width of the ribbon. If the width is</span>
<span class="sd">            allowed to vary, this is the minimum width. The default is</span>
<span class="sd">            10% the length.</span>

<span class="sd">        scalars : str, optional</span>
<span class="sd">            String name of the scalars array to use to vary the ribbon</span>
<span class="sd">            width.  This is only used if a scalars array is specified.</span>

<span class="sd">        angle : float, optional</span>
<span class="sd">            Angle in degrees of the offset angle of the ribbon from</span>
<span class="sd">            the line normal. The default is 0.0.</span>

<span class="sd">        factor : float, optional</span>
<span class="sd">            Set the maximum ribbon width in terms of a multiple of the</span>
<span class="sd">            minimum width. The default is 2.0.</span>

<span class="sd">        normal : tuple(float), optional</span>
<span class="sd">            Normal to use as default.</span>

<span class="sd">        tcoords : bool, str, optional</span>
<span class="sd">            If ``True``, generate texture coordinates along the</span>
<span class="sd">            ribbon. This can also be specified to generate the texture</span>
<span class="sd">            coordinates with either ``&#39;length&#39;`` or ``&#39;normalized&#39;``.</span>

<span class="sd">        preference : str, optional</span>
<span class="sd">            The field preference when searching for the scalars array by</span>
<span class="sd">            name.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Ribbon mesh.  Empty if there are no lines in the input dataset.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a line to a ribbon and plot it.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; n = 1000</span>
<span class="sd">        &gt;&gt;&gt; theta = np.linspace(-10 * np.pi, 10 * np.pi, n)</span>
<span class="sd">        &gt;&gt;&gt; z = np.linspace(-2, 2, n)</span>
<span class="sd">        &gt;&gt;&gt; r = z**2 + 1</span>
<span class="sd">        &gt;&gt;&gt; x = r * np.sin(theta)</span>
<span class="sd">        &gt;&gt;&gt; y = r * np.cos(theta)</span>
<span class="sd">        &gt;&gt;&gt; points = np.column_stack((x, y, z))</span>
<span class="sd">        &gt;&gt;&gt; pdata = pyvista.PolyData(points)</span>
<span class="sd">        &gt;&gt;&gt; pdata.lines = np.hstack((n, range(n)))</span>
<span class="sd">        &gt;&gt;&gt; pdata[&#39;distance&#39;] = range(n)</span>
<span class="sd">        &gt;&gt;&gt; ribbon = pdata.ribbon(width=0.2)</span>
<span class="sd">        &gt;&gt;&gt; ribbon.plot(show_scalar_bar=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">get_array_association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">preference</span><span class="o">=</span><span class="n">preference</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mf">0.1</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkRibbonFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetWidth</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetUseDefaultNormal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetDefaultNormal</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetAngle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetVaryWidth</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetInputArrayToProcess</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scalars</span>
            <span class="p">)</span>  <span class="c1"># args: (idx, port, connection, field, name)</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetWidthFactor</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetVaryWidth</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tcoords</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateTCoords</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tcoords</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tcoords</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
                    <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateTCoordsToUseLength</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">tcoords</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;normalized&#39;</span><span class="p">:</span>
                    <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateTCoordsToNormalizedLength</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateTCoordsToUseLength</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateTCoordsToOff</span><span class="p">()</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Creating a Ribbon&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.extrude"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.extrude.html#pyvista.PolyDataFilters.extrude">[docs]</a>    <span class="k">def</span> <span class="nf">extrude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">capping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sweep polygonal data creating a &quot;skirt&quot; from free edges.</span>

<span class="sd">        This will create a line from vertices.</span>

<span class="sd">        This takes polygonal data as input and generates polygonal</span>
<span class="sd">        data on output. The input dataset is swept according to some</span>
<span class="sd">        extrusion function and creates new polygonal primitives. These</span>
<span class="sd">        primitives form a &quot;skirt&quot; or swept surface. For example,</span>
<span class="sd">        sweeping a line results in a quadrilateral, and sweeping a</span>
<span class="sd">        triangle creates a &quot;wedge&quot;.</span>

<span class="sd">        The skirt is generated by locating certain topological</span>
<span class="sd">        features. Free edges (edges of polygons or triangle strips</span>
<span class="sd">        only used by one polygon or triangle strips) generate</span>
<span class="sd">        surfaces. This is true also of lines or polylines. Vertices</span>
<span class="sd">        generate lines.</span>

<span class="sd">        .. versionchanged:: 0.32.0</span>
<span class="sd">           The ``capping`` keyword was added with a default of ``False``.</span>
<span class="sd">           The previously used VTK default corresponds to ``capping=True``.</span>
<span class="sd">           In a future version the default will be changed to ``True`` to</span>
<span class="sd">           match the behavior of the underlying VTK filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : numpy.ndarray or sequence</span>
<span class="sd">            Direction and length to extrude the mesh in.</span>

<span class="sd">        capping : bool, optional</span>
<span class="sd">            Control if the sweep of a 2D object is capped. The default is</span>
<span class="sd">            ``False``, which differs from VTK&#39;s default.</span>

<span class="sd">            .. warning::</span>
<span class="sd">               The ``capping`` keyword was added in version 0.32.0 with a</span>
<span class="sd">               default value of ``False``. In a future version this default</span>
<span class="sd">               will be changed to ``True`` to match the behavior of the</span>
<span class="sd">               underlying VTK filter. It is recommended to explicitly pass</span>
<span class="sd">               a value for this keyword argument to prevent future changes</span>
<span class="sd">               in behavior and warnings.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Overwrites the original mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Extruded mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extrude a half circle arc.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; arc = pyvista.CircularArc([-1, 0, 0], [1, 0, 0], [0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; mesh = arc.extrude([0, 0, 1], capping=False)</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(color=&#39;tan&#39;)</span>

<span class="sd">        Extrude and cap an 8 sided polygon.</span>

<span class="sd">        &gt;&gt;&gt; poly = pyvista.Polygon(n_sides=8)</span>
<span class="sd">        &gt;&gt;&gt; mesh = poly.extrude((0, 0, 1.5), capping=True)</span>
<span class="sd">        &gt;&gt;&gt; mesh.plot(line_width=5, show_edges=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">capping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capping</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The default value of the ``capping`` keyword argument will change in &#39;</span>
                <span class="s1">&#39;a future version to ``True`` to match the behavior of VTK. We recommend &#39;</span>
                <span class="s1">&#39;passing the keyword explicitly to prevent future surprises.&#39;</span><span class="p">,</span>
                <span class="n">PyvistaFutureWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkLinearExtrusionFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetExtrusionTypeToVectorExtrusion</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetVector</span><span class="p">(</span><span class="o">*</span><span class="n">vector</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCapping</span><span class="p">(</span><span class="n">capping</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extruding&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PolyDataFilters.extrude_rotate"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.extrude_rotate.html#pyvista.PolyDataFilters.extrude_rotate">[docs]</a>    <span class="k">def</span> <span class="nf">extrude_rotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dradius</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">angle</span><span class="o">=</span><span class="mf">360.0</span><span class="p">,</span>
        <span class="n">capping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rotation_axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sweep polygonal data creating &quot;skirt&quot; from free edges and lines, and lines from vertices.</span>

<span class="sd">        This takes polygonal data as input and generates polygonal</span>
<span class="sd">        data on output. The input dataset is swept around the axis</span>
<span class="sd">        to create new polygonal primitives. These primitives form a</span>
<span class="sd">        &quot;skirt&quot; or swept surface. For example, sweeping a line results</span>
<span class="sd">        in a cylindrical shell, and sweeping a circle creates a torus.</span>

<span class="sd">        There are a number of control parameters for this filter.  You</span>
<span class="sd">        can control whether the sweep of a 2D object (i.e., polygon or</span>
<span class="sd">        triangle strip) is capped with the generating geometry via the</span>
<span class="sd">        ``capping`` parameter. Also, you can control the angle of</span>
<span class="sd">        rotation, and whether translation along the axis is</span>
<span class="sd">        performed along with the rotation.  (Translation is useful for</span>
<span class="sd">        creating &quot;springs&quot;.) You also can adjust the radius of the</span>
<span class="sd">        generating geometry with the ``dradius`` parameter.</span>

<span class="sd">        The skirt is generated by locating certain topological</span>
<span class="sd">        features. Free edges (edges of polygons or triangle strips</span>
<span class="sd">        only used by one polygon or triangle strips) generate</span>
<span class="sd">        surfaces. This is true also of lines or polylines. Vertices</span>
<span class="sd">        generate lines.</span>

<span class="sd">        This filter can be used to model axisymmetric objects like</span>
<span class="sd">        cylinders, bottles, and wine glasses; or translational</span>
<span class="sd">        rotational symmetric objects like springs or corkscrews.</span>

<span class="sd">        .. versionchanged:: 0.32.0</span>
<span class="sd">           The ``capping`` keyword was added with a default of ``False``.</span>
<span class="sd">           The previously used VTK default corresponds to ``capping=True``.</span>
<span class="sd">           In a future version the default will be changed to ``True`` to</span>
<span class="sd">           match the behavior of the underlying VTK filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            Number of pieces to divide line into.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Overwrites the original mesh inplace.</span>

<span class="sd">        translation : float, optional</span>
<span class="sd">            Total amount of translation along the axis.</span>

<span class="sd">        dradius : float, optional</span>
<span class="sd">            Change in radius during sweep process.</span>

<span class="sd">        angle : float, optional</span>
<span class="sd">            The angle of rotation in degrees.</span>

<span class="sd">        capping : bool, optional</span>
<span class="sd">            Control if the sweep of a 2D object is capped. The default is</span>
<span class="sd">            ``False``, which differs from VTK&#39;s default.</span>

<span class="sd">            .. warning::</span>
<span class="sd">               The ``capping`` keyword was added in version 0.32.0 with a</span>
<span class="sd">               default value of ``False``. In a future version this default</span>
<span class="sd">               will be changed to ``True`` to match the behavior of the</span>
<span class="sd">               underlying VTK filter. It is recommended to explicitly pass</span>
<span class="sd">               a value for this keyword argument to prevent future changes</span>
<span class="sd">               in behavior and warnings.</span>

<span class="sd">        rotation_axis : numpy.ndarray or sequence, optional</span>
<span class="sd">            The direction vector of the axis around which the rotation is done.</span>
<span class="sd">            It requires vtk&gt;=9.1.0.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Rotationally extruded mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a &quot;spring&quot; using the rotational extrusion filter.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; profile = pyvista.Polygon(center=[1.25, 0.0, 0.0], radius=0.2,</span>
<span class="sd">        ...                           normal=(0, 1, 0), n_sides=30)</span>
<span class="sd">        &gt;&gt;&gt; extruded = profile.extrude_rotate(resolution=360, translation=4.0,</span>
<span class="sd">        ...                                   dradius=0.5, angle=1500.0,</span>
<span class="sd">        ...                                   capping=True)</span>
<span class="sd">        &gt;&gt;&gt; extruded.plot(smooth_shading=True)</span>

<span class="sd">        Create a &quot;wine glass&quot; using the rotational extrusion filter.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[-0.18, 0, 0],</span>
<span class="sd">        ...                    [-0.18, 0, 0.01],</span>
<span class="sd">        ...                    [-0.18, 0, 0.02],</span>
<span class="sd">        ...                    [-0.01, 0, 0.03],</span>
<span class="sd">        ...                    [-0.01, 0, 0.04],</span>
<span class="sd">        ...                    [-0.02, 0, 0.5],</span>
<span class="sd">        ...                    [-0.05, 0, 0.75],</span>
<span class="sd">        ...                    [-0.1, 0, 0.8],</span>
<span class="sd">        ...                    [-0.2, 0, 1.0]])</span>
<span class="sd">        &gt;&gt;&gt; spline = pyvista.Spline(points, 30)</span>
<span class="sd">        &gt;&gt;&gt; extruded = spline.extrude_rotate(resolution=20, capping=False)</span>
<span class="sd">        &gt;&gt;&gt; extruded.plot(color=&#39;tan&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">capping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">capping</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The default value of the ``capping`` keyword argument will change in &#39;</span>
                <span class="s1">&#39;a future version to ``True`` to match the behavior of VTK. We recommend &#39;</span>
                <span class="s1">&#39;passing the keyword explicitly to prevent future surprises.&#39;</span><span class="p">,</span>
                <span class="n">PyvistaFutureWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotation_axis</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">))</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rotation_axis</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Vector must be a length three vector&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">resolution</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`resolution` should be positive&#39;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkRotationalExtrusionFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetResolution</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTranslation</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetDeltaRadius</span><span class="p">(</span><span class="n">dradius</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCapping</span><span class="p">(</span><span class="n">capping</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetAngle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">vtk_version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetRotationAxis</span><span class="p">(</span><span class="n">rotation_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">if</span> <span class="n">rotation_axis</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span>
                    <span class="s1">&#39;The installed version of VTK does not support &#39;</span>
                    <span class="s1">&#39;setting the direction vector of the axis around which the rotation is done.&#39;</span>
                <span class="p">)</span>

        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extruding&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">alg</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PolyDataFilters.extrude_trim"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.extrude_trim.html#pyvista.PolyDataFilters.extrude_trim">[docs]</a>    <span class="k">def</span> <span class="nf">extrude_trim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">,</span>
        <span class="n">trim_surface</span><span class="p">,</span>
        <span class="n">extrusion</span><span class="o">=</span><span class="s2">&quot;boundary_edges&quot;</span><span class="p">,</span>
        <span class="n">capping</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extrude polygonal data trimmed by a surface.</span>

<span class="sd">        The input dataset is swept along a specified direction forming a</span>
<span class="sd">        &quot;skirt&quot; from the boundary edges 2D primitives (i.e., edges used</span>
<span class="sd">        by only one polygon); and/or from vertices and lines. The extent</span>
<span class="sd">        of the sweeping is defined where the sweep intersects a</span>
<span class="sd">        user-specified surface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        direction : numpy.ndarray or sequence</span>
<span class="sd">            Direction vector to extrude.</span>

<span class="sd">        trim_surface : pyvista.PolyData</span>
<span class="sd">            Surface which trims the surface.</span>

<span class="sd">        extrusion : str or int, optional</span>
<span class="sd">            Control the strategy of extrusion. One of the following:</span>

<span class="sd">            * ``&quot;boundary_edges&quot;``</span>
<span class="sd">            * ``&quot;all_edges&quot;``</span>

<span class="sd">            The default is ``&quot;boundary_edges&quot;``, which only generates faces on</span>
<span class="sd">            the boundary of the original input surface. When using</span>
<span class="sd">            ``&quot;all_edges&quot;``, faces are created along interior points as well.</span>

<span class="sd">        capping : str or int, optional</span>
<span class="sd">            Control the strategy of capping. One of the following:</span>

<span class="sd">            * ``&quot;intersection&quot;``</span>
<span class="sd">            * ``&quot;minimum_distance&quot;``</span>
<span class="sd">            * ``&quot;maximum_distance&quot;``</span>
<span class="sd">            * ``&quot;average_distance&quot;``</span>

<span class="sd">            The default is &quot;intersection&quot;.</span>

<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Overwrites the original mesh in-place.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Extruded mesh trimmed by a surface.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Extrude a disc.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; plane = pyvista.Plane(i_size=2, j_size=2, direction=[0, 0.8, 1])</span>
<span class="sd">        &gt;&gt;&gt; disc = pyvista.Disc(center=(0, 0, -1), c_res=50)</span>
<span class="sd">        &gt;&gt;&gt; direction = [0, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; extruded_disc = disc.extrude_trim(direction, plane)</span>
<span class="sd">        &gt;&gt;&gt; extruded_disc.plot(smooth_shading=True, split_sharp_edges=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Vector must be a length three vector&#39;</span><span class="p">)</span>

        <span class="n">extrusions</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;boundary_edges&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;all_edges&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrusion</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">extrusion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extrusions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid strategy of extrusion &quot;</span><span class="si">{</span><span class="n">extrusion</span><span class="si">}</span><span class="s1">&quot;.&#39;</span><span class="p">)</span>
            <span class="n">extrusion</span> <span class="o">=</span> <span class="n">extrusions</span><span class="p">[</span><span class="n">extrusion</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid type given to `extrusion`. Must be a string.&#39;</span><span class="p">)</span>

        <span class="n">cappings</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;intersection&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;minimum_distance&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;maximum_distance&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s2">&quot;average_distance&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">capping</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">capping</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cappings</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid strategy of capping &quot;</span><span class="si">{</span><span class="n">capping</span><span class="si">}</span><span class="s1">&quot;.&#39;</span><span class="p">)</span>
            <span class="n">capping</span> <span class="o">=</span> <span class="n">cappings</span><span class="p">[</span><span class="n">capping</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid type given to `capping`. Must be a string.&#39;</span><span class="p">)</span>

        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTrimmedExtrusionFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetExtrusionDirection</span><span class="p">(</span><span class="o">*</span><span class="n">direction</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTrimSurfaceData</span><span class="p">(</span><span class="n">trim_surface</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetExtrusionStrategy</span><span class="p">(</span><span class="n">extrusion</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCappingStrategy</span><span class="p">(</span><span class="n">capping</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Extruding with trimming&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">alg</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PolyDataFilters.strip"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.strip.html#pyvista.PolyDataFilters.strip">[docs]</a>    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_length</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">pass_cell_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">pass_cell_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">pass_point_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Strip poly data cells.</span>

<span class="sd">        Generates triangle strips and/or poly-lines from input</span>
<span class="sd">        polygons, triangle strips, and lines.</span>

<span class="sd">        Polygons are assembled into triangle strips only if they are</span>
<span class="sd">        triangles; other types of polygons are passed through to the</span>
<span class="sd">        output and not stripped. (Use ``triangulate`` filter to</span>
<span class="sd">        triangulate non-triangular polygons prior to running this</span>
<span class="sd">        filter if you need to strip all the data.) The filter will</span>
<span class="sd">        pass through (to the output) vertices if they are present in</span>
<span class="sd">        the input polydata.</span>

<span class="sd">        Also note that if triangle strips or polylines are defined in</span>
<span class="sd">        the input they are passed through and not joined nor</span>
<span class="sd">        extended. (If you wish to strip these use ``triangulate``</span>
<span class="sd">        filter to fragment the input into triangles and lines prior to</span>
<span class="sd">        running this filter.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        join : bool, optional</span>
<span class="sd">            If ``True``, the output polygonal segments will be joined</span>
<span class="sd">            if they are contiguous. This is useful after slicing a</span>
<span class="sd">            surface. The default is ``False``.</span>

<span class="sd">        max_length : int, optional</span>
<span class="sd">            Specify the maximum number of triangles in a triangle</span>
<span class="sd">            strip, and/or the maximum number of lines in a poly-line.</span>

<span class="sd">        pass_cell_data : bool, optional</span>
<span class="sd">            Enable/Disable passing of the CellData in the input to the</span>
<span class="sd">            output as FieldData. Note the field data is transformed.</span>
<span class="sd">            Default is ``False``.</span>

<span class="sd">        pass_cell_ids : bool, optional</span>
<span class="sd">            If ``True``, the output polygonal dataset will have a</span>
<span class="sd">            celldata array that holds the cell index of the original</span>
<span class="sd">            3D cell that produced each output cell. This is useful for</span>
<span class="sd">            picking. The default is ``False`` to conserve memory.</span>

<span class="sd">        pass_point_ids : bool, optional</span>
<span class="sd">            If ``True``, the output polygonal dataset will have a</span>
<span class="sd">            pointdata array that holds the point index of the original</span>
<span class="sd">            vertex that produced each output vertex. This is useful</span>
<span class="sd">            for picking. The default is ``False`` to conserve memory.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Stripped mesh.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pyvista import examples</span>
<span class="sd">        &gt;&gt;&gt; mesh = examples.load_airplane()</span>
<span class="sd">        &gt;&gt;&gt; slc = mesh.slice(normal=&#39;z&#39;, origin=(0, 0, -10))</span>
<span class="sd">        &gt;&gt;&gt; stripped = slc.strip()</span>
<span class="sd">        &gt;&gt;&gt; stripped.n_cells</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; stripped.plot(show_edges=True, line_width=3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkStripper</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetJoinContiguousSegments</span><span class="p">(</span><span class="n">join</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMaximumLength</span><span class="p">(</span><span class="n">max_length</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassCellDataAsFieldData</span><span class="p">(</span><span class="n">pass_cell_data</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassThroughCellIds</span><span class="p">(</span><span class="n">pass_cell_ids</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetPassThroughPointIds</span><span class="p">(</span><span class="n">pass_point_ids</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Stripping Mesh&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span></div>

<div class="viewcode-block" id="PolyDataFilters.collision"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.collision.html#pyvista.PolyDataFilters.collision">[docs]</a>    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other_mesh</span><span class="p">,</span>
        <span class="n">contact_mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">box_tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">cell_tolerance</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">n_cells_per_node</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">generate_scalars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform collision determination between two polyhedral surfaces.</span>

<span class="sd">        If ``collision_mode`` is set to all contacts, the output will</span>
<span class="sd">        be lines of contact. If ``collision_mode`` is first contact or half</span>
<span class="sd">        contacts then the Contacts output will be vertices.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Currently only triangles are processed. Use</span>
<span class="sd">            :func:`PolyDataFilters.triangulate` to convert any strips</span>
<span class="sd">            or polygons to triangles.  Otherwise, the mesh will be</span>
<span class="sd">            converted for you within this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_mesh : pyvista.DataSet</span>
<span class="sd">            Other mesh to test collision with.  If the other mesh is</span>
<span class="sd">            not a surface, its external surface will be extracted and</span>
<span class="sd">            triangulated.</span>

<span class="sd">        contact_mode : int, optional</span>
<span class="sd">            Contact mode.  One of the following:</span>

<span class="sd">            * 0 - All contacts. Find all the contacting cell pairs</span>
<span class="sd">              with two points per collision</span>
<span class="sd">            * 1 - First contact. Quickly find the first contact point.</span>
<span class="sd">            * 2 - Half contacts. Find all the contacting cell pairs</span>
<span class="sd">              with one point per collision.</span>

<span class="sd">        box_tolerance : float, optional</span>
<span class="sd">             Oriented bounding box (OBB) tree tolerance in world coordinates.</span>

<span class="sd">        cell_tolerance : float, optional</span>
<span class="sd">            Cell tolerance (squared value).</span>

<span class="sd">        n_cells_per_node : int, optional</span>
<span class="sd">            Number of cells in each OBB.</span>

<span class="sd">        generate_scalars : bool, optional</span>
<span class="sd">            Flag to visualize the contact cells.  If ``True``, the</span>
<span class="sd">            contacting cells will be colored from red through blue,</span>
<span class="sd">            with collisions first determined colored red.  This array</span>
<span class="sd">            is stored as ``&quot;collision_rgba&quot;``.</span>

<span class="sd">            .. note::</span>
<span class="sd">               This will remove any other cell arrays in the mesh.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Mesh containing collisions in the ``field_data``</span>
<span class="sd">            attribute named ``&quot;ContactCells&quot;``.  Array only exists</span>
<span class="sd">            when there are collisions.</span>

<span class="sd">        int</span>
<span class="sd">            Number of collisions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Due to the nature of the `vtk.vtkCollisionDetectionFilter</span>
<span class="sd">        &lt;https://vtk.org/doc/nightly/html/classvtkCollisionDetectionFilter.html&gt;`_,</span>
<span class="sd">        repeated uses of this method will be slower that using the</span>
<span class="sd">        ``vtk.vtkCollisionDetectionFilter`` directly.  The first</span>
<span class="sd">        update of the filter creates two instances of `vtkOBBTree</span>
<span class="sd">        &lt;https://vtk.org/doc/nightly/html/classvtkOBBTree.html&gt;`_,</span>
<span class="sd">        which can be subsequently updated by modifying the transform or</span>
<span class="sd">        matrix of the input meshes.</span>

<span class="sd">        This method assumes no transform and is easier to use for</span>
<span class="sd">        single collision tests, but it is recommended to use a</span>
<span class="sd">        combination of ``pyvista`` and ``vtk`` for rapidly computing</span>
<span class="sd">        repeated collisions.  See the `Collision Detection Example</span>
<span class="sd">        &lt;https://kitware.github.io/vtk-examples/site/Python/Visualization/CollisionDetection/&gt;`_</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compute the collision between a sphere and the back faces of a</span>
<span class="sd">        cube and output the cell indices of the first 10 collisions.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import pyvista</span>
<span class="sd">        &gt;&gt;&gt; mesh_a = pyvista.Sphere(radius=0.5)</span>
<span class="sd">        &gt;&gt;&gt; mesh_b = pyvista.Cube((0.5, 0.5, 0.5)).extract_cells([0, 2, 4])</span>
<span class="sd">        &gt;&gt;&gt; collision, ncol = mesh_a.collision(mesh_b, cell_tolerance=1)</span>
<span class="sd">        &gt;&gt;&gt; collision[&#39;ContactCells&#39;][:10]</span>
<span class="sd">        pyvista_ndarray([471, 471, 468, 468, 469, 469, 466, 466, 467, 467])</span>

<span class="sd">        Plot the collisions by creating a collision mask with the</span>
<span class="sd">        ``&quot;ContactCells&quot;`` field data.  Cells with a collision are</span>
<span class="sd">        colored red.</span>

<span class="sd">        &gt;&gt;&gt; scalars = np.zeros(collision.n_cells, dtype=bool)</span>
<span class="sd">        &gt;&gt;&gt; scalars[collision.field_data[&#39;ContactCells&#39;]] = True</span>
<span class="sd">        &gt;&gt;&gt; pl = pyvista.Plotter()</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(collision, scalars=scalars, show_scalar_bar=False,</span>
<span class="sd">        ...                 cmap=&#39;bwr&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(mesh_b, color=&#39;tan&#39;, line_width=5, opacity=0.7,</span>
<span class="sd">        ...                 show_edges=True)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        Alternatively, simply plot the collisions using the default</span>
<span class="sd">        ``&#39;collision_rgba&#39;`` array after enabling ``generate_scalars``.</span>

<span class="sd">        &gt;&gt;&gt; collision, ncol = mesh_a.collision(mesh_b, cell_tolerance=1,</span>
<span class="sd">        ...                                    generate_scalars=True)</span>
<span class="sd">        &gt;&gt;&gt; collision.plot()</span>

<span class="sd">        See :ref:`collision_example` for more examples using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">_vtk</span><span class="o">.</span><span class="n">VTK9</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="n">VTKVersionError</span><span class="p">(</span><span class="s1">&#39;The collision filter requires VTK 9 or newer&#39;</span><span class="p">)</span>

        <span class="c1"># other mesh must be a polydata</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_mesh</span><span class="p">,</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">):</span>
            <span class="n">other_mesh</span> <span class="o">=</span> <span class="n">other_mesh</span><span class="o">.</span><span class="n">extract_surface</span><span class="p">()</span>

        <span class="c1"># according to VTK limitations</span>
        <span class="n">poly_data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">poly_data</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="n">poly_data</span> <span class="o">=</span> <span class="n">poly_data</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_mesh</span><span class="o">.</span><span class="n">is_all_triangles</span><span class="p">:</span>
            <span class="n">other_mesh</span> <span class="o">=</span> <span class="n">other_mesh</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>

        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkCollisionDetectionFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">poly_data</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetTransform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkTransform</span><span class="p">())</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other_mesh</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetMatrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkMatrix4x4</span><span class="p">())</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetBoxTolerance</span><span class="p">(</span><span class="n">box_tolerance</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCellTolerance</span><span class="p">(</span><span class="n">cell_tolerance</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetNumberOfCellsPerNode</span><span class="p">(</span><span class="n">n_cells_per_node</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetCollisionMode</span><span class="p">(</span><span class="n">contact_mode</span><span class="p">)</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetGenerateScalars</span><span class="p">(</span><span class="n">generate_scalars</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Computing collisions&#39;</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">alg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">generate_scalars</span><span class="p">:</span>
            <span class="c1"># must rename array as VTK sets the cell scalars array name to</span>
            <span class="c1"># a nullptr.</span>
            <span class="c1"># See https://github.com/pyvista/pyvista/pull/1540</span>
            <span class="c1">#</span>
            <span class="c1"># Note: Since all other cell arrays are destroyed when</span>
            <span class="c1"># generate_scalars is True, we can always index the first cell</span>
            <span class="c1"># array.</span>
            <span class="n">output</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">GetAbstractArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="s1">&#39;collision_rgba&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">alg</span><span class="o">.</span><span class="n">GetNumberOfContacts</span><span class="p">()</span></div>

<div class="viewcode-block" id="PolyDataFilters.reconstruct_surface"><a class="viewcode-back" href="../../../../api/core/_autosummary/pyvista.PolyDataFilters.reconstruct_surface.html#pyvista.PolyDataFilters.reconstruct_surface">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbr_sz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstruct a surface from the points in this dataset.</span>

<span class="sd">        This filter takes a list of points assumed to lie on the</span>
<span class="sd">        surface of a solid 3D object. A signed measure of the distance</span>
<span class="sd">        to the surface is computed and sampled on a regular grid. The</span>
<span class="sd">        grid can then be contoured at zero to extract the surface. The</span>
<span class="sd">        default values for neighborhood size and sample spacing should</span>
<span class="sd">        give reasonable results for most uses but can be set if</span>
<span class="sd">        desired.</span>

<span class="sd">        This is helpful when generating surfaces from point clouds and</span>
<span class="sd">        is more reliable than :func:`DataSetFilters.delaunay_3d`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nbr_sz : int, optional</span>
<span class="sd">            Specify the number of neighbors each point has, used for</span>
<span class="sd">            estimating the local surface orientation.</span>

<span class="sd">            The default value of 20 should be fine for most</span>
<span class="sd">            applications, higher values can be specified if the spread</span>
<span class="sd">            of points is uneven. Values as low as 10 may yield</span>
<span class="sd">            adequate results for some surfaces. Higher values cause</span>
<span class="sd">            the algorithm to take longer and will cause</span>
<span class="sd">            errors on sharp boundaries.</span>

<span class="sd">        sample_spacing : float, optional</span>
<span class="sd">            The spacing of the 3D sampling grid.  If not set, a</span>
<span class="sd">            reasonable guess will be made.</span>

<span class="sd">        progress_bar : bool, optional</span>
<span class="sd">            Display a progress bar to indicate progress.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pyvista.PolyData</span>
<span class="sd">            Reconstructed surface.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a point cloud out of a sphere and reconstruct a surface</span>
<span class="sd">        from it.</span>

<span class="sd">        &gt;&gt;&gt; import pyvista as pv</span>
<span class="sd">        &gt;&gt;&gt; points = pv.wrap(pv.Sphere().points)</span>
<span class="sd">        &gt;&gt;&gt; surf = points.reconstruct_surface()</span>

<span class="sd">        &gt;&gt;&gt; pl = pv.Plotter(shape=(1,2))</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(points)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_title(&#39;Point Cloud of 3D Surface&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.subplot(0,1)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_mesh(surf, color=True, show_edges=True)</span>
<span class="sd">        &gt;&gt;&gt; _ = pl.add_title(&#39;Reconstructed Surface&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pl.show()</span>

<span class="sd">        See :ref:`surface_reconstruction_example` for more examples</span>
<span class="sd">        using this filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkSurfaceReconstructionFilter</span><span class="p">()</span>
        <span class="n">alg</span><span class="o">.</span><span class="n">SetInputDataObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbr_sz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetNeighborhoodSize</span><span class="p">(</span><span class="n">nbr_sz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alg</span><span class="o">.</span><span class="n">SetSampleSpacing</span><span class="p">(</span><span class="n">sample_spacing</span><span class="p">)</span>

        <span class="c1"># connect using ports as this will be slightly faster</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="n">_vtk</span><span class="o">.</span><span class="n">vtkMarchingCubes</span><span class="p">()</span>
        <span class="n">mc</span><span class="o">.</span><span class="n">SetComputeNormals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mc</span><span class="o">.</span><span class="n">SetComputeScalars</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mc</span><span class="o">.</span><span class="n">SetComputeGradients</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mc</span><span class="o">.</span><span class="n">SetInputConnection</span><span class="p">(</span><span class="n">alg</span><span class="o">.</span><span class="n">GetOutputPort</span><span class="p">())</span>
        <span class="n">mc</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">_update_alg</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">,</span> <span class="s1">&#39;Reconstructing surface&#39;</span><span class="p">)</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mc</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">surf</span></div></div>
</pre></div>

              </article>
              

              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2017-2023, The PyVista Developers.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>